/*
 * Author: Pollazzon Stefano
 * Project: ZDoom Navmesh builder
 * This module contains the navmesh generation algorythms
 */
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace ZDoomNavmesh
{
    /// <summary>
    /// Enum <c>TOrientation</c> represents the possible ways of aligning 3 points in the 2D Euclidean space.
    /// </summary>
    public enum TOrientation
    {
        CounterClockwise = -1,
        Collinear = 0,
        Clockwise = 1
    }
    /// <summary>
    /// Class <c>TPoint</c> represents a simple point in 2D Euclidean space.
    /// </summary>
    /// <remarks>
    /// It's very similar to the TMapVertex definition, but I needed some more specific behavior, including the equality operators.
    /// </remarks>
    public class TPoint : Object
    {
        /// <summary>
        /// Variable <c>X</c> represents the X coordinate.
        /// </summary>
        public int X;
        /// <summary>
        /// Variable <c>Y</c> represents the Y coordinate.
        /// </summary>
        public int Y;
        /// <summary>
        /// Constructor <c>TPoint</c> constructs a point with the given coordinates.
        /// </summary>
        public TPoint(int X, int Y) : base()
        {
            this.X = X;
            this.Y = Y;
        }
        public override bool Equals(object Obj)
        {
            if (Obj is null)
                return false;
            if (ReferenceEquals(this, Obj))
                return true;
            if (!(Obj is TPoint))
                return false;
            TPoint Other = Obj as TPoint;
            return (X == Other.X) && (Y == Other.Y);
        }
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        public static bool operator ==(TPoint A, TPoint B)
        {
            if ((A is null) || (B is null))
                return false;
            return A.Equals(B);
        }
        public static bool operator !=(TPoint A, TPoint B)
        {
            return !(A == B);
        }
    }
    /// <summary>
    /// Class <c>TLine</c> represents a simple line in 2D Euclidean space.
    /// </summary>
    /// <remarks>
    /// It's similar to the TMapLinedef definition, but I needed some more specific behavior, including the equality operators.
    /// </remarks>
    public class TLine : Object
    {
        /// <summary>
        /// Variable <c>A</c> represents the first point of the segment.
        /// </summary>
        public TPoint A;
        /// <summary>
        /// Variable <c>TLine</c> represents the second point of the segment.
        /// </summary>
        public TPoint B;
        /// <summary>
        /// Variable <c>Portal</c> is the index of the connected polygon if this line is a portal, or is -1 if this line is not a portal.
        /// </summary>
        public int Portal;
        /// <summary>
        /// Variable <c>Flags</c> contains the flags of the line.
        /// </summary>
        public int Flags;
        /// <summary>
        /// Variable <c>MapLinedef</c> contains the map LINEDEF index that generated this line, or -1 if it was generated by the polygon splitting.
        /// </summary>
        public int MapLinedef;
        /// <summary>
        /// Constructor <c>TLine</c> constructs a line with the given points.
        /// </summary>
        public TLine(TPoint A, TPoint B) : base()
        {
            this.A = A ?? throw new ArgumentNullException(nameof(A));
            this.B = B ?? throw new ArgumentNullException(nameof(B));
            Portal = -1;
            Flags = 0;
            MapLinedef = -1;
        }
        public override bool Equals(object Obj)
        {
            if (Obj is null)
                return false;
            if (ReferenceEquals(this, Obj))
                return true;
            if (!(Obj is TLine))
                return false;
            TLine Other = Obj as TLine;
            return (A == Other.A) && (B == Other.B);
        }
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        public static bool operator ==(TLine A, TLine B)
        {
            if ((A is null) || (B is null))
                return false;
            return A.Equals(B);
        }
        public static bool operator !=(TLine A, TLine B)
        {
            return !(A == B);
        }
    }
    /// <summary>
    /// Class <c>TPolygon</c> represents a simple polygon without holes in 2D Euclidean space.
    /// </summary>
    public class TPolygon : Object
    {
        /// <summary>
        /// Variable <c>Lines</c> is the list of lines, that are the edges of this polygon.
        /// </summary>
        public List<TLine> Lines;
        /// <summary>
        /// Variable <c>HeightFloor</c> is the height of the floor in the current polygon.
        /// </summary>
        public int HeightFloor;
        /// <summary>
        /// Variable <c>HeightCeiling</c> is the height of the ceiling in the current polygon.
        /// </summary>
        public int HeightCeiling;
        /// <summary>
        /// Variable <c>LineFirst</c> contains the first line of the polygon.
        /// </summary>
        public int LineFirst;
        /// <summary>
        /// Variable <c>LineCount</c> contains the number of lines.
        /// </summary>
        public int LineCount;
        /// <summary>
        /// Variable <c>Flags</c> contains the flags of the line.
        /// </summary>
        public int Flags;
        /// <summary>
        /// Variable <c>MapSector</c> contains the map SECTOR index that generated this polygon.
        /// </summary>
        public int MapSector;
        /// <summary>
        /// Constructor <c>TPolygon</c> is the index of the map SECTOR.
        /// </summary>
        public TPolygon() : base()
        {
            Lines = new List<TLine>();
            LineFirst = 0;
            LineCount = 0;
            Flags = 0;
            MapSector = -1;
        }
        /// <summary>
        /// Function <c>AddLine</c> adds a line of the polygon.
        /// </summary>
        /// <param name="Line"><c>Line</c> is the line to be added.</param>
        public void AddLine(TLine Line)
        {
            Lines.Add(Line);
        }
        /// <summary>
        /// Function <c>IsClosed</c> checks if the polygon is closed.
        /// </summary>
        /// <returns><c>True</c> if the polygon is closed.</returns>
        public bool IsClosed()
        {
            if (Lines.Count < 3)
                return false;
            List<Boolean> CheckedLine = new List<Boolean>(Lines.Count);
            for (int I = 0; I < Lines.Count; I++)
                CheckedLine.Add(false);
            int FirstLine = 0;
            int CurrentLine = FirstLine;
            do
            {
                CheckedLine[CurrentLine] = true;
                CurrentLine = Lines.FindIndex((Line) => Line.A == Lines[CurrentLine].B);
                if ((CurrentLine < 0) || ((CheckedLine[CurrentLine]) && (CurrentLine != FirstLine)))
                    return false;
            } while ((CurrentLine != 0));
            return true;
        }
        /// <summary>
        /// Function <c>SortLines</c> sorts the lines in a continuous path between points.
        /// </summary>
        public void SortLines()
        {
            if (Lines.Count < 3)
                return;
            List<Int32> LinesIndexes = new List<Int32>(Lines.Count);
            int CurrentIndex = 0;
            LinesIndexes.Add(CurrentIndex);
            do
            {
                TLine CurrentLine = Lines[CurrentIndex];
                CurrentIndex = Lines.FindIndex((Line) => Line.A == CurrentLine.B);
                if (CurrentIndex < 0)
                    return; // Only if not closed!
                if (CurrentIndex > 0)
                    LinesIndexes.Add(CurrentIndex);
            } while (CurrentIndex > 0);
            for (int I = 0; I < Lines.Count; I++)
            {
                if (LinesIndexes[I] != I)
                {
                    TLine A = Lines[LinesIndexes[I]];
                    TLine B = Lines[I];
                    Lines[LinesIndexes[I]] = B;
                    Lines[I] = A;
                    int IndexA = LinesIndexes[LinesIndexes[I]];
                    int IndexB = LinesIndexes[I];
                    LinesIndexes[LinesIndexes[I]] = IndexB;
                    LinesIndexes[I] = IndexA;
                }
            }
        }
    }
    /// <summary>
    /// Enum <c>TPPLOrientation</c> represents the possible orientations of a polygon.
    /// </summary>
    /// <remarks>
    /// TPPLOrientation looks very similar to TOrientation, and the are, but I wished to keep them separated, to avoid typing / logic errors.
    /// </remarks>
    public enum TPPLOrientation
    {
        PPLOrientationClockwise = -1,
        PPLOrientationNone = 0,
        PPLOrientationCounterClockwise = 1,
    };
    /// <summary>
    /// Class <c>TPPLPoint</c> represents a point in 2D Euclidean space, but with floating point arithmetic.
    /// </summary>
    public class TPPLPoint : Object, ICloneable
    {
        /// <summary>
        /// Variable <c>X</c> represents the X coordinate.
        /// </summary>
        public double X;
        /// <summary>
        /// Variable <c>Y</c> represents the Y coordinate.
        /// </summary>
        public double Y;
        /// <summary>
        /// Constructor <c>TPPLPoint</c> constructs a point with the given coordinates.
        /// </summary>
        public TPPLPoint(double X = 0, double Y = 0) : base()
        {
            this.X = X;
            this.Y = Y;
        }
        public override bool Equals(object Obj)
        {
            if (Obj is null)
                return false;
            if (ReferenceEquals(this, Obj))
                return true;
            if (!(Obj is TPPLPoint))
                return false;
            TPPLPoint Other = Obj as TPPLPoint;
            return (X == Other.X) && (Y == Other.Y);
        }
        public override int GetHashCode()
        {
            return base.GetHashCode();
        }
        /// <summary>
        /// Function <c>Clone</c> implements the ICloneable interface.
        /// </summary>
        /// <returns>A cloned <c>TPPLPoint</c>.</returns>
        public object Clone()
        {
            return new TPPLPoint(X, Y);
        }
        public static bool operator ==(TPPLPoint A, TPPLPoint B)
        {
            if ((A is null) || (B is null))
                return false;
            return A.Equals(B);
        }
        public static bool operator !=(TPPLPoint A, TPPLPoint B)
        {
            return !(A == B);
        }
        public static TPPLPoint operator +(TPPLPoint P1, TPPLPoint P2)
        {
            TPPLPoint Result = new TPPLPoint
            {
                X = P1.X + P2.X,
                Y = P1.Y + P2.Y
            };
            return Result;
        }
        public static TPPLPoint operator -(TPPLPoint P1, TPPLPoint P2)
        {
            TPPLPoint Result = new TPPLPoint
            {
                X = P1.X - P2.X,
                Y = P1.Y - P2.Y
            };
            return Result;
        }
        public static TPPLPoint operator *(TPPLPoint P1, double F)
        {
            TPPLPoint Result = new TPPLPoint
            {
                X = P1.X * F,
                Y = P1.Y * F
            };
            return Result;
        }
        public static TPPLPoint operator /(TPPLPoint P1, double F)
        {
            TPPLPoint Result = new TPPLPoint
            {
                X = P1.X / F,
                Y = P1.Y / F
            };
            return Result;
        }
    }
    /// <summary>
    /// Class <c>TPPLPolygon</c> represents a polygon in 2D Euclidean space, but with floating point arithmetic.
    /// It also sorts the points in clockwise or counterclockwise order, with the following rule:
    /// If the polygon represents a valid polygon: counterclockwise order is used
    /// If the polygon represents a hole: clockwise order is used
    /// </summary>
    public class TPPLPolygon : Object, ICloneable
    {
        /// <summary>
        /// Variable <c>Points</c> contains the Points of the polygon.
        /// </summary>
        public List<TPPLPoint> Points;
        /// <summary>
        /// Variable <c>FHole</c> is used internally, to represent a flag, that indicates this as a hole inside another polygon.
        /// </summary>
        private bool FHole;
        /// <summary>
        /// Constructor <c>TPPLPolygon</c> constructs a polygon.
        /// </summary>
        public TPPLPolygon()
        {
            Points = new List<TPPLPoint>();
            FHole = false;
        }
        /// <summary>
        /// Constructor <c>TPPLPolygon</c> constructs a triangle with the given points.
        /// The points are sorted in counterclockwise order during construction.
        /// </summary>
        /// <param name="P1"><c>P1</c> is the first point of the triangle.</param>
        /// <param name="P2"><c>P1</c> is the second point of the triangle.</param>
        /// <param name="P3"><c>P1</c> is the third point of the triangle.</param>
        public TPPLPolygon(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
        {
            Points = new List<TPPLPoint>(3)
            {
                P1,
                P2,
                P3
            };
            FHole = false;
        }
        /// <summary>
        /// Function <c>Clone</c> implements the ICloneable interface.
        /// </summary>
        /// <returns>A cloned <c>TPPLPolygon</c>.</returns>
        public object Clone()
        {
            TPPLPolygon Result = new TPPLPolygon();
            foreach (TPPLPoint Point in Points)
                Result.AddPoint(Point);
            Result.Hole = FHole;
            return Result;
        }
        /// <summary>
        /// Function <c>AddPoint</c> adds a point of the polygon.
        /// </summary>
        /// <param name="Point"><c>Point</c> is the point to be added.</param>
        public void AddPoint(TPPLPoint Point)
        {
            Points.Add(Point);
        }
        /// <summary>
        /// Function <c>GetOrientation</c> calculates the points orientation of the polygon.
        /// </summary>
        /// <returns>A <c>TPPLOrientation</c> value of the orientation.</returns>
        public TPPLOrientation GetOrientation()
        {
            int I1, I2;
            double Area = 0;
            for (I1 = 0; I1 < Points.Count; I1++)
            {
                I2 = I1 + 1;
                if (I2 == Points.Count)
                    I2 = 0;
                Area += Points[I1].X * Points[I2].Y - Points[I1].Y * Points[I2].X;
            }
            if (Area > 0)
                return TPPLOrientation.PPLOrientationCounterClockwise;
            if (Area < 0)
                return TPPLOrientation.PPLOrientationClockwise;
            return TPPLOrientation.PPLOrientationNone;
        }
        /// <summary>
        /// Function <c>SetOrientation</c> sets the orientation of the points of the polygon.
        /// </summary>
        /// <param name="PPLOrientation"><c>PPLOrientation</c> is the orientation to be applied.</param>
        public void SetOrientation(TPPLOrientation PPLOrientation)
        {
            TPPLOrientation ActuralOrientation = GetOrientation();
            if ((ActuralOrientation != TPPLOrientation.PPLOrientationNone) && (ActuralOrientation != PPLOrientation))
                Points.Reverse();
        }
        /// <summary>
        /// Function <c>SetHole</c> sets a flag, that specifies this is a hole inside another polygon.
        /// </summary>
        /// <param name="AHole"><c>AHole</c> is a boolean value, that specifies this is a hole inside another polygon.</param>
        /// <remarks>The vertex must be sorted in clockwise order in holes and in counterclockwise order in non-holes.</remarks>
        private void SetHole(bool AHole)
        {
            FHole = AHole;
            if (FHole)
                SetOrientation(TPPLOrientation.PPLOrientationClockwise);
            else
                SetOrientation(TPPLOrientation.PPLOrientationCounterClockwise);
        }
        /// <summary>
        /// Property <c>Hole</c> gets or sets the orientation of points of the polygon, according to the needings.
        /// </summary>
        public bool Hole
        { 
            get => FHole;
            set => SetHole(value);
        }
    }
    /// <summary>
    /// Class <c>TPartitionVertex</c> is used in the triangulation process.
    /// </summary>
    public class TPartitionVertex : Object
    {
        public TPPLPoint Point;
        public bool IsActive;
        public bool IsConvex;
        public bool IsEar;
        public double Angle;
        public TPartitionVertex Previous;
        public TPartitionVertex Next;
    }
    /// <summary>
    /// Class <c>TPPLPartition</c> is a static class, that handles three very important tasks.
    /// 1. Hole management.
    /// 2. Triangulation by ear clipping.
    /// 3. Convex partitioning with the Hertel-Mehlhorn algorithm.
    /// </summary>
    public static class TPPLPartition : Object
    {
        public static bool IsConvex(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
        {
            double Val;
            Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
            if (Val > 0)
                return true;
            else
                return false;
        }
        public static bool IsReflex(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
        {
            double Val;
            Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
            if (Val < 0)
                return true;
            else
                return false;
        }
        public static bool IsInside(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3, TPPLPoint Point)
        {
            if (IsConvex(P1, Point, P2))
                return false;
            if (IsConvex(P2, Point, P3))
                return false;
            if (IsConvex(P3, Point, P1))
                return false;
            return true;
        }
        public static bool InCone(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3, TPPLPoint Point)
        {
            bool Convex = IsConvex(P1, P2, P3);
            if (Convex)
            {
                if (!IsConvex(P1, P2, Point))
                    return false;
                if (!IsConvex(P2, P3, Point))
                    return false;
                return true;
            }
            else
            {
                if (IsConvex(P1, P2, Point))
                    return true;
                if (IsConvex(P2, P3, Point))
                    return true;
                return false;
            }
        }
        public static bool Intersects(TPPLPoint P11, TPPLPoint P12, TPPLPoint P21, TPPLPoint P22)
        {
            if ((P11.X == P21.X) && (P11.Y == P21.Y))
                return false;
            if ((P11.X == P22.X) && (P11.Y == P22.Y))
                return false;
            if ((P12.X == P21.X) && (P12.Y == P21.Y))
                return false;
            if ((P12.X == P22.X) && (P12.Y == P22.Y))
                return false;
            TPPLPoint V1Ort = new TPPLPoint();
            TPPLPoint V2Ort = new TPPLPoint();
            double Dot11, Dot12, Dot21, Dot22;
            V1Ort.X = P12.Y - P11.Y;
            V1Ort.Y = P11.X - P12.X;
            V2Ort.X = P22.Y - P21.Y;
            V2Ort.Y = P21.X - P22.X;
            TPPLPoint V = P21 - P11;
            Dot21 = V.X * V1Ort.X + V.Y * V1Ort.Y;
            V = P22 - P11;
            Dot22 = V.X * V1Ort.X + V.Y * V1Ort.Y;
            V = P11 - P21;
            Dot11 = V.X * V2Ort.X + V.Y * V2Ort.Y;
            V = P12 - P21;
            Dot12 = V.X * V2Ort.X + V.Y * V2Ort.Y;
            if (Dot11 * Dot12 > 0)
                return false;
            if (Dot21 * Dot22 > 0)
                return false;
            return true;
        }
        public static TPPLPoint Normalize(TPPLPoint Point)
        {
            TPPLPoint Result;
            double Val = Math.Sqrt(Point.X * Point.X + Point.Y * Point.Y);
            if (Val != 0)
                Result = Point / Val;
            else
                Result = new TPPLPoint
                {
                    X = 0,
                    Y = 0
                };
            return Result;
        }
        public static void UpdateVertex(TPartitionVertex Vertex, TPartitionVertex[] Vertices, int NumVertices)
        {
            TPartitionVertex V1 = Vertex.Previous;
            TPartitionVertex V3 = Vertex.Next;
            TPPLPoint Vec1, Vec3;
            Vertex.IsConvex = IsConvex(V1.Point, Vertex.Point, V3.Point);
            Vec1 = Normalize(V1.Point - Vertex.Point);
            Vec3 = Normalize(V3.Point - Vertex.Point);
            Vertex.Angle = Vec1.X * Vec3.X + Vec1.Y * Vec3.Y;
            if (Vertex.IsConvex)
            {
                Vertex.IsEar = true;
                for (int I = 0; I < NumVertices; I++)
                {
                    if ((Vertices[I].Point.X == Vertex.Point.X) && (Vertices[I].Point.Y == Vertex.Point.Y))
                        continue;
                    if ((Vertices[I].Point.X == V1.Point.X) && (Vertices[I].Point.Y == V1.Point.Y))
                        continue;
                    if ((Vertices[I].Point.X == V3.Point.X) && (Vertices[I].Point.Y == V3.Point.Y))
                        continue;
                    if (IsInside(V1.Point, Vertex.Point, V3.Point, Vertices[I].Point))
                    {
                        Vertex.IsEar = false;
                        break;
                    }
                }
            }
            else
                Vertex.IsEar = false;
        }
        /// <summary>
        /// Function <c>RemoveHoles</c> is a simple heuristic procedure for removing holes from a list of polygons.
        /// It works by creating a diagonal from the right-most hole  to some other visible vertex.
        /// </summary>
        /// <param name="InputPolygons"><c>InputPolygons</c> is a list of polygons that can contain holes.<br/>
        /// Vertices of all non-hole polys have to be in counter-clockwise order.<br/>
        /// Vertices of all hole polys have to be in clockwise order.</param>
        /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of polygons without holes.</param>
        /// <returns>True if the process is successful.</returns>
        public static bool RemoveHoles(List<TPPLPolygon> InputPolygons, List<TPPLPolygon> OutputPolygons)
        {
            TPPLPolygon Hole = null;
            TPPLPolygon Poly = null;
            TPPLPoint BestPolyPoint = null;
            int J, HolePointIndex = 0, PolyPointIndex = 0;
            // Check for the trivial case of no holes
            bool HasHoles = false;
            foreach (TPPLPolygon Polygon in InputPolygons)
                if (Polygon.Hole)
                {
                    HasHoles = true;
                    break;
                }
            if (!HasHoles)
            {
                foreach (TPPLPolygon Polygon in InputPolygons)
                    OutputPolygons.Add(Polygon);
                return true;
            }
            List<TPPLPolygon> Polygons = new List<TPPLPolygon>(InputPolygons.Count);
            InputPolygons.ForEach((Polygon) => Polygons.Add(Polygon.Clone() as TPPLPolygon));
            while (true)
            {
                // Find the hole point with the largest x
                HasHoles = false;
                foreach (TPPLPolygon Polygon in Polygons)
                {
                    if (!Polygon.Hole)
                        continue;
                    if (!HasHoles)
                    {
                        HasHoles = true;
                        Hole = Polygon;
                        HolePointIndex = 0;
                    }
                    for (int I = 0; I < Polygon.Points.Count; I++)
                    {
                        if (Polygon.Points[I].X > Hole.Points[HolePointIndex].X)
                        {
                            Hole = Polygon;
                            HolePointIndex = I;
                        }
                    }
                }
                if (!HasHoles)
                    break;
                TPPLPoint HolePoint = Hole.Points[HolePointIndex];
                bool PointFound = false;
                foreach (TPPLPolygon Polygon1 in Polygons)
                {
                    if (Polygon1.Hole)
                        continue;
                    for (int I = 0; I < Polygon1.Points.Count; I++)
                    {
                        if (Polygon1.Points[I].X <= HolePoint.X)
                            continue;
                        if (!InCone(Polygon1.Points[(I + Polygon1.Points.Count - 1) % (Polygon1.Points.Count)], Polygon1.Points[I], Polygon1.Points[(I + 1) % (Polygon1.Points.Count)], HolePoint))
                            continue;
                        TPPLPoint PolyPoint = Polygon1.Points[I];
                        if (PointFound)
                        {
                            TPPLPoint V1 = Normalize(PolyPoint - HolePoint);
                            TPPLPoint V2 = Normalize(BestPolyPoint - HolePoint);
                            if (V2.X > V1.X)
                                continue;
                        }
                        bool PointVisible = true;
                        foreach (TPPLPolygon Polygon2 in Polygons)
                        {
                            if (Polygon2.Hole)
                                continue;
                            for (J = 0; J < Polygon2.Points.Count; J++)
                            {
                                TPPLPoint LineP1 = Polygon2.Points[J];
                                TPPLPoint LineP2 = Polygon2.Points[(J + 1) % (Polygon2.Points.Count)];
                                if (Intersects(HolePoint, PolyPoint, LineP1, LineP2))
                                {
                                    PointVisible = false;
                                    break;
                                }
                            }
                            if (!PointVisible)
                                break;
                        }
                        if (PointVisible)
                        {
                            PointFound = true;
                            BestPolyPoint = PolyPoint;
                            Poly = Polygon1;
                            PolyPointIndex = I;
                        }
                    }
                }
                if (!PointFound)
                    return false;
                TPPLPolygon NewPoly = new TPPLPolygon();
                for (int I = 0; I <= PolyPointIndex; I++)
                    NewPoly.AddPoint(Poly.Points[I]);
                for (int I = 0; I <= Hole.Points.Count; I++)
                    NewPoly.AddPoint(Hole.Points[(I + HolePointIndex) % Hole.Points.Count]);
                for (int I = PolyPointIndex; I < Poly.Points.Count; I++)
                    NewPoly.AddPoint(Poly.Points[I]);
                Polygons.Remove(Hole);
                Polygons.Remove(Poly);
                Polygons.Add(NewPoly);
            }
            foreach (TPPLPolygon Polygon in Polygons)
                OutputPolygons.Add(Polygon);
            return true;
        }
        /// <summary>
        /// Function <c>Triangulate_EC</c> triangulates a polygon by ear clipping.
        /// </summary>
        /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be triangulated.<br />
        /// Vertices have to be in counter-clockwise order.</param>
        /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of triangles.</param>
        /// <returns>True if the process is successful.</returns>
        public static bool Triangulate_EC(TPPLPolygon InputPolygon, List<TPPLPolygon> OutputPolygons)
        {
            if (InputPolygon.Points.Count < 3)
                return false;
            if (InputPolygon.Points.Count == 3)
            {
                OutputPolygons.Add(InputPolygon);
                return true;
            }
            int NumVertices = InputPolygon.Points.Count;
            TPartitionVertex[] Vertices = new TPartitionVertex[NumVertices];
            TPartitionVertex Ear = null;
            for (int I = 0; I < NumVertices; I++)
                Vertices[I] = new TPartitionVertex();
            for (int I = 0; I < NumVertices; I++)
            {
                Vertices[I].IsActive = true;
                Vertices[I].Point = InputPolygon.Points[I];
                if (I == (NumVertices - 1))
                    Vertices[I].Next = Vertices[0];
                else
                    Vertices[I].Next = Vertices[I + 1];
                if (I == 0)
                    Vertices[I].Previous = Vertices[NumVertices - 1];
                else
                    Vertices[I].Previous = Vertices[I - 1];
            }
            for (int I = 0; I < NumVertices; I++)
                UpdateVertex(Vertices[I], Vertices, NumVertices);
            for (int I = 0; I < NumVertices - 3; I++)
            {
                bool EarFound = false;
                // Search the most extruded ear.
                for (int J = 0; J < NumVertices; J++)
                {
                    if (!Vertices[J].IsActive)
                        continue;
                    if (!Vertices[J].IsEar)
                        continue;
                    if (!EarFound)
                    {
                        EarFound = true;
                        Ear = Vertices[J];
                    }
                    else
                    {
                        if (Vertices[J].Angle > Ear.Angle)
                            Ear = Vertices[J];
                    }
                }
                if (!EarFound)
                    return false;
                TPPLPolygon Triangle = new TPPLPolygon(Ear.Previous.Point, Ear.Point, Ear.Next.Point);
                OutputPolygons.Add(Triangle);
                Ear.IsActive = false;
                Ear.Previous.Next = Ear.Next;
                Ear.Next.Previous = Ear.Previous;
                if (I == NumVertices - 4)
                    break;
                UpdateVertex(Ear.Previous, Vertices, NumVertices);
                UpdateVertex(Ear.Next, Vertices, NumVertices);
            }
            for (int I = 0; I < NumVertices; I++)
                if (Vertices[I].IsActive)
                {
                    TPPLPolygon Triangle = new TPPLPolygon(Vertices[I].Previous.Point, Vertices[I].Point, Vertices[I].Next.Point);
                    OutputPolygons.Add(Triangle);
                    break;
                }
            return true;
        }
        /// <summary>
        /// Function <c>Triangulate_EC</c> triangulates a list of polygons that may contain holes by ear clipping
        /// algorithm. It first calls RemoveHoles to get rid of the holes, and then calls Triangulate_EC for each resulting polygon.
        /// </summary>
        /// <param name="InputPolygons"><c>InputPolygons</c> is a list of polygons to be triangulated (can contain holes).<br />
        /// Vertices of all non-hole polys have to be in counter-clockwise order.<br />
        /// Vertices of all hole polys have to be in clockwise order.</param>
        /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of triangles.</param>
        /// <returns>True if the process is successful.</returns>
        public static bool Triangulate_EC(List<TPPLPolygon> InputPolygons, List<TPPLPolygon> OutputPolygons)
        {
            List<TPPLPolygon> Polygons = new List<TPPLPolygon>();
            if (!RemoveHoles(InputPolygons, Polygons))
                return false;
            foreach (TPPLPolygon Polygon in Polygons)
                if (!Triangulate_EC(Polygon, OutputPolygons))
                    return false;
            return true;
        }
        /// <summary>
        /// Function <c>ConvexPartition_HM</c> partitions a polygon into convex polygons by using the
        /// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm, 
        /// however, in practice it works much better than that and often gives optimal partition.
        /// It uses triangulation obtained by ear clipping as intermediate result.
        /// </summary>
        /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be partitioned.<br />
        /// Vertices have to be in counter-clockwise order.</param>
        /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of convex polygons.</param>
        /// <returns>True if the process is successful.</returns>
        public static bool ConvexPartition_HM(TPPLPolygon InputPolygon, List<TPPLPolygon> OutputPolygons)
        {
            if (InputPolygon.Points.Count < 3)
                return false;
            List<TPPLPolygon> Triangles = new List<TPPLPolygon>();
            int I11, I12, I21 = 0, I22 = 0, I13, I23;
            // Check if the poly is already convex.
            int NumReflex = 0;
            for (I11 = 0; I11 < InputPolygon.Points.Count; I11++)
            {
                if (I11 == 0)
                    I12 = InputPolygon.Points.Count - 1;
                else
                    I12 = I11 - 1;
                if (I11 == (InputPolygon.Points.Count - 1))
                    I13 = 0;
                else
                    I13 = I11 + 1;
                if (IsReflex(InputPolygon.Points[I12], InputPolygon.Points[I11], InputPolygon.Points[I13]))
                {
                    NumReflex = 1;
                    break;
                }
            }
            if (NumReflex == 0)
            {
                OutputPolygons.Add(InputPolygon);
                return true;
            }
            if (!Triangulate_EC(InputPolygon, Triangles))
                return false;
            int TriangleIndex1 = 0, TriangleIndex2;
            while (TriangleIndex1 < Triangles.Count)
            {
                TPPLPolygon Polygon1 = Triangles[TriangleIndex1];
                TPPLPolygon Polygon2 = null;
                for (I11 = 0; I11 < Polygon1.Points.Count; I11++)
                {
                    TPPLPoint D1 = Polygon1.Points[I11];
                    I12 = (I11 + 1) % (Polygon1.Points.Count);
                    TPPLPoint D2 = Polygon1.Points[I12];
                    bool IsDiagonal = false;
                    TriangleIndex2 = TriangleIndex1;
                    while (TriangleIndex2 < Triangles.Count)
                    {
                        if (TriangleIndex1 != TriangleIndex2)
                        {
                            Polygon2 = Triangles[TriangleIndex2];
                            for (I21 = 0; I21 < Polygon2.Points.Count; I21++)
                            {
                                if ((D2.X != Polygon2.Points[I21].X) || (D2.Y != Polygon2.Points[I21].Y))
                                    goto ExitWhile;
                                I22 = (I21 + 1) % (Polygon2.Points.Count);
                                if ((D1.X != Polygon2.Points[I22].X) || (D1.Y != Polygon2.Points[I22].Y))
                                    goto ExitWhile;
                                IsDiagonal = true;
                                break;
                            }
                            if (IsDiagonal)
                                break;
                        }
ExitWhile:
                        TriangleIndex2++;
                    }
                    if (!IsDiagonal)
                        continue;
                    TPPLPoint P2 = Polygon1.Points[I11];
                    if (I11 == 0)
                        I13 = Polygon1.Points.Count - 1;
                    else
                        I13 = I11 - 1;
                    TPPLPoint P1 = Polygon1.Points[I13];
                    if (I22 == (Polygon2.Points.Count - 1))
                        I23 = 0;
                    else
                        I23 = I22 + 1;
                    TPPLPoint P3 = Polygon2.Points[I23];
                    if (!IsConvex(P1, P2, P3))
                        continue;
                    P2 = Polygon1.Points[I12];
                    if (I12 == (Polygon1.Points.Count - 1))
                        I13 = 0;
                    else
                        I13 = I12 + 1;
                    P3 = Polygon1.Points[I13];
                    if (I21 == 0)
                        I23 = Polygon2.Points.Count - 1;
                    else
                        I23 = I21 - 1;
                    P1 = Polygon2.Points[I23];
                    if (!IsConvex(P1, P2, P3))
                        continue;
                    TPPLPolygon NewPolygon = new TPPLPolygon();
                    for (int J = I12; J != I11; J = (J + 1) % (Polygon1.Points.Count))
                        NewPolygon.AddPoint(Polygon1.Points[J]);
                    for (int J = I22; J != I21; J = (J + 1) % (Polygon2.Points.Count))
                        NewPolygon.AddPoint(Polygon2.Points[J]);
                    Triangles.RemoveAt(TriangleIndex2);
                    Triangles[TriangleIndex1] = NewPolygon;
                    Polygon1 = NewPolygon;
                    I11 = -1;
                    continue;
                }
                TriangleIndex1++;
            }
            foreach (TPPLPolygon Polygon in Triangles)
                OutputPolygons.Add(Polygon);
            return true;
        }
        /// <summary>
        /// Function <c>ConvexPartition_HM</c> partitions a list of polygons into convex parts by using the
        /// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm, 
        /// however, in practice it works much better than that and often gives optimal partition.
        /// It uses triangulation obtained by ear clipping as intermediate result.
        /// </summary>
        /// <param name="InputPolygons"><c>InputPolygons</c> is an input list of polygons to be partitioned.<br />
        /// Vertices of all non-hole polys have to be in counter-clockwise order.<br />
        /// Vertices of all hole polys have to be in clockwise order.</param>
        /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of convex polygons.</param>
        /// <returns>True if the process is successful.</returns>
        public static bool ConvexPartition_HM(List<TPPLPolygon> InputPolygons, List<TPPLPolygon> OutputPolygons)
        {
            List<TPPLPolygon> Polygons = new List<TPPLPolygon>();
            if (!RemoveHoles(InputPolygons, Polygons))
                return false;
            foreach (TPPLPolygon Polygon in Polygons)
                if (!ConvexPartition_HM(Polygon, OutputPolygons))
                    return false;
            return true;
        }
    }
    /// <summary>
    /// Class <c>TPolygonGroup</c> represents a polygon in the map, obtained from a SECTOR, with SIDEDEF, LINEDEF and VERTEX data.
    /// The SectorGroup is defined by the outer edges of the polygon and optionally the holes.
    /// </summary>
    public class TPolygonGroup : Object
    {
        /// <summary>
        /// Variable <c>Polygon</c> represents the outer lines of the SectorGroup.
        /// </summary>
        public TPolygon Polygon;
        /// <summary>
        /// Variable <c>Holes</c> represents the inner "holes", that are polygons themselves.
        /// </summary>
        public List<TPolygon> Holes;
        /// <summary>
        /// Constructor <c>TPolygonGroup</c> constructs and empty SectorGroup.
        /// </summary>
        public TPolygonGroup()
        {
            Holes = new List<TPolygon>();
        }
    }
    /// <summary>
    /// Class <c>TNavMeshSettings</c> is used to configure the navigation mesh generation.
    /// </summary>
    public class TNavMeshSettings : Object
    {
        /// <summary>
        /// Variable <c>ActorHeight</c> specifies the height of the Actor, that uses the NavMesh.
        /// </summary>
        public int ActorHeight;
        /// <summary>
        /// Variable <c>ActorRadius</c> specifies the radius of the Actor, that uses the NavMesh.
        /// </summary>
        public int ActorRadius;
    }
    /// <summary>
    /// Class <c>TNavMesh</c> represents the navigation mesh of the processing map.
    /// </summary>
    public class TNavMesh : Object
    {
        /// <summary>
        /// Class <c>TMapDoor</c> stores the doors, that will be included of the mesh.
        /// </summary>
        internal class TMapDoor : Object
        {
            internal int DoorHeightCeiling;
            internal TMapSector DoorSector;
            internal TMapLinedef SideLine1;
            internal TMapLinedef SideLine2;
            internal TMapSector SideSector1;
            internal TMapSector SideSector2;
        }
        /// <summary>
        /// Class <c>TMapSector3D</c> stores the 3D sectors, that will be included of the mesh.
        /// </summary>
        internal class TMapSector3D : Object
        {
            internal int SectorTag;
            internal bool Swimmable;
            internal TMapLinedef ControlLinedef;
            internal TMapSector ControlSector;
        }
        /// <summary>
        /// Class <c>TMapTeleporter</c> stores the teleporters, that will be included of the mesh.
        /// </summary>
        internal class TMapTeleporter : Object
        {
            internal int SectorTag;
            internal TMapLinedef MapLinedef;
            internal TMapThing DestinationThing;
        }
        /// <summary>
        /// Variable <c>NavMeshSettings</c> stores the settings of the process.
        /// </summary>
        internal TNavMeshSettings NavMeshSettings;
        /// <summary>
        /// Variable <c>MapDefinition</c> stores the map definition, which we are processing.
        /// </summary>
        internal TMapDefinition MapDefinition;
        /// <summary>
        /// Variable <c>MapGridLines</c> stores the map grid of LINEDEF, for collision detection.
        /// </summary>
        internal List<Int32>[,] MapGridLines;
        /// <summary>
        /// Constant <c>GridOffset</c> is the offset added to VERTEX coordinates in the map grid.
        /// </summary>
        internal const int GridOffset = 32768;
        /// <summary>
        /// Variable <c>Lines</c> stores the lines of the navigation mesh.
        /// </summary>
        internal List<TLine> FLines;
        /// <summary>
        /// Variable <c>FPolygons</c> stores the polygons of the navigation mesh.
        /// </summary>
        internal List<TPolygon> FPolygons;
        /// <summary>
        /// Variable <c>FCells</c> stores the cells partitioning system of the navigation mesh.
        /// </summary>
        internal List<Int32>[,] FCells;
        /// <summary>
        /// Variable <c>FOffsetCellX</c> stores the first cell's X coordinate.
        /// </summary>
        internal int FOffsetCellX;
        /// <summary>
        /// Variable <c>FOffsetCellY</c> stores the first cell's Y coordinate.
        /// </summary>
        internal int FOffsetCellY;
        /// <summary>
        /// Variable <c>FNumCellX</c> stores the number of cells in the X axis.
        /// </summary>
        internal int FNumCellX;
        /// <summary>
        /// Variable <c>FNumCellY</c> stores the number of cells in the Y axis.
        /// </summary>
        internal int FNumCellY;
        /// <summary>
        /// Variable <c>MapDoors</c> stors the list of doors.
        /// </summary>
        internal List<TMapDoor> MapDoors;
        /// <summary>
        /// Variable <c>MapTeleporters</c> stores the list of teleporters.
        /// </summary>
        internal List<TMapTeleporter> MapTeleporters;
        /// <summary>
        /// Variable <c>MapSectors3D</c> stores the list of 3D sectors.
        /// </summary>
        internal List<TMapSector3D> MapSectors3D;
        /// <summary>
        /// Variable <c>Lines</c> stores the lines of the navigation mesh.
        /// </summary>
        public List<TLine> Lines { get => FLines; }
        /// <summary>
        /// Variable <c>Polygons</c> stores the polygons of the navigation mesh.
        /// </summary>
        public List<TPolygon> Polygons { get => FPolygons; }
        public List<Int32>[,] Cells { get => FCells; }
        public int OffsetCellX { get => FOffsetCellX; }
        public int OffsetCellY { get => FOffsetCellY; }
        public int NumCellX { get => FNumCellX; }
        public int NumCellY { get => FNumCellY; }
        /// <summary>
        /// Constructor <c>TNavMesh</c> constructs the navigation mesh.
        /// </summary>
        public TNavMesh() : base()
        {
            FLines = new List<TLine>();
            FPolygons = new List<TPolygon>();
            MapDoors = new List<TMapDoor>();
            MapTeleporters = new List<TMapTeleporter>();
            MapSectors3D = new List<TMapSector3D>();
        }
        internal static TOrientation CalcDirection(TPoint A, TPoint B, TPoint C)
        {
            if (A is null)
                throw new ArgumentNullException(nameof(A));
            if (B is null)
                throw new ArgumentNullException(nameof(B));
            if (C is null)
                throw new ArgumentNullException(nameof(C));
            int CrossProduct = (B.Y - A.Y) * (C.X - B.X) - (B.X - A.X) * (C.Y - B.Y);
            if (CrossProduct == 0)
                return TOrientation.Collinear;
            else
                if (CrossProduct < 0)
                return TOrientation.CounterClockwise;
            else
                return TOrientation.Clockwise;
        }
        internal static bool PointOnLine(TLine Line, TPoint Point)
        {
            if (Point is null)
                throw new ArgumentNullException(nameof(Point));
            if ((Point.X <= Math.Max(Line.A.X, Line.B.X)) && (Point.X >= Math.Min(Line.A.X, Line.B.X)) && (Point.Y <= Math.Max(Line.A.Y, Line.B.Y)) && (Point.Y >= Math.Min(Line.A.Y, Line.B.Y)))
                return true;
            else
                return false;
        }
        internal static bool LineIntersectLine(TLine Line1, TLine Line2)
        {
            if (Line1 is null)
                throw new ArgumentNullException(nameof(Line1));
            if (Line2 is null)
                throw new ArgumentNullException(nameof(Line2));
            TOrientation Direction1 = CalcDirection(Line1.A, Line1.B, Line2.A);
            TOrientation Direction2 = CalcDirection(Line1.A, Line1.B, Line2.B);
            TOrientation Direction3 = CalcDirection(Line2.A, Line2.B, Line1.A);
            TOrientation Direction4 = CalcDirection(Line2.A, Line2.B, Line1.B);
            if ((Direction1 != Direction2) && (Direction3 != Direction4))
                return true;
            if ((Direction1 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.A)))
                return true;
            if ((Direction2 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.B)))
                return true;
            if ((Direction3 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.A)))
                return true;
            if ((Direction4 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.B)))
                return true;
            return false;
        }
        internal static bool PointInsidePolygon(TPolygon Polygon, TPoint Point)
        {
            if (Polygon.Lines.Count < 3)
                return false;
            TLine ExtendedLine = new TLine(Point, new TPoint(65536, Point.Y));
            int Count = 0;
            foreach (TLine Line in Polygon.Lines)
            {
                if (LineIntersectLine(Line, ExtendedLine))
                    if (CalcDirection(Line.A, Point, Line.B) == TOrientation.Collinear)
                        return PointOnLine(Line, Point);
                    else
                        Count++;
            }
            return (Count & 1) > 0;
        }
        internal static bool PolygonInsidePolygon(TPolygon OuterPolygon, TPolygon TestPoligon)
        {
            if ((OuterPolygon.Lines.Count < 3) || (TestPoligon.Lines.Count < 3))
                return false;
            else
                return (PointInsidePolygon(OuterPolygon, TestPoligon.Lines[0].A)) && (PointInsidePolygon(OuterPolygon, TestPoligon.Lines[0].B));
        }
        /// <summary>
        /// Function <c>CalcMapGrid</c> builds the map grids of LINEDEF.
        /// </summary>
        /// <remarks>It sets the MapGridLines variable of the object.</remarks>
        internal void CalcMapGrid()
        {
            MapGridLines = new List<Int32>[256, 256];
            for (int Y = 0; Y < 256; Y++)
                for (int X = 0; X < 256; X++)
                    MapGridLines[Y, X] = new List<Int32>();
            foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
            {
                int MaxX = Int32.MinValue;
                int MaxY = Int32.MinValue;
                int MinX = Int32.MaxValue;
                int MinY = Int32.MaxValue;
                if (MapDefinition.MapVertex[MapLinedef.V1].X > MaxX)
                    MaxX = MapDefinition.MapVertex[MapLinedef.V1].X;
                if (MapDefinition.MapVertex[MapLinedef.V1].Y > MaxY)
                    MaxY = MapDefinition.MapVertex[MapLinedef.V1].Y;
                if (MapDefinition.MapVertex[MapLinedef.V2].X > MaxX)
                    MaxX = MapDefinition.MapVertex[MapLinedef.V2].X;
                if (MapDefinition.MapVertex[MapLinedef.V2].Y > MaxY)
                    MaxY = MapDefinition.MapVertex[MapLinedef.V2].Y;
                if (MapDefinition.MapVertex[MapLinedef.V1].X < MinX)
                    MinX = MapDefinition.MapVertex[MapLinedef.V1].X;
                if (MapDefinition.MapVertex[MapLinedef.V1].Y < MinY)
                    MinY = MapDefinition.MapVertex[MapLinedef.V1].Y;
                if (MapDefinition.MapVertex[MapLinedef.V2].X < MinX)
                    MinX = MapDefinition.MapVertex[MapLinedef.V2].X;
                if (MapDefinition.MapVertex[MapLinedef.V2].Y < MinY)
                    MinY = MapDefinition.MapVertex[MapLinedef.V2].Y;
                MinX = (MinX + GridOffset) >> 8;
                MinY = (MinY + GridOffset) >> 8;
                MaxX = (MaxX + GridOffset) >> 8;
                MaxY = (MaxY + GridOffset) >> 8;
                for (int Y = MinY; Y <= MaxY; Y++)
                    for (int X = MinX; X <= MaxX; X++)
                        MapGridLines[Y, X].Add(MapLinedef.Index);
            }
        }
        /// <summary>
        /// Function <c>GetMapGridIntersect</c> gets the LINEDEF lines, that intersect a square centered on a point,
        /// using the map grid data.
        /// </summary>
        /// <param name="CenterPoint"><c>CenterPoint</c> is the center of the square.</param>
        /// <param name="Radius"><c>Radius</c> is the radius of the square.</param>
        /// <returns>The list of LINEDEF indexes.</returns>
        internal List<Int32> GetMapGridIntersect(TPoint CenterPoint, int Radius)
        {
            List<Int32> Result = new List<Int32>();
            int X1 = (CenterPoint.X - Radius + GridOffset) >> 8;
            int Y1 = (CenterPoint.Y - Radius + GridOffset) >> 8;
            int X2 = (CenterPoint.X + Radius + GridOffset) >> 8;
            int Y2 = (CenterPoint.Y + Radius + GridOffset) >> 8;
            for (int X = X1; X <= X2; X++)
                for (int Y = Y1; Y <= Y2; Y++)
                    Result.AddRange(MapGridLines[Y, X]);
            if (Result.Count > 0)
                return Result;
            else
                return null;
        }
        /// <summary>
        /// Function <c>CheckLinedefCrushing</c> checks if a linedef has crushing damage effects.
        /// </summary>
        /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
        internal bool CheckLinedefCrushing(TMapLinedef MapLinedef)
        {
            bool Result = false;
            if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
                switch (MapDefinition.MapNamespace)
                {
                    case TMapNamespace.MapNamespaceDoom:
                        if ((MapLinedef.Special == 6)
                            || (MapLinedef.Special == 25)
                            || (MapLinedef.Special == 49)
                            || (MapLinedef.Special == 55)
                            || (MapLinedef.Special == 56)
                            || (MapLinedef.Special == 57)
                            || (MapLinedef.Special == 65)
                            || (MapLinedef.Special == 73)
                            || (MapLinedef.Special == 74)
                            || (MapLinedef.Special == 77)
                            || (MapLinedef.Special == 94)
                            || (MapLinedef.Special == 141)
                            || (MapLinedef.Special == 150)
                            || (MapLinedef.Special == 164)
                            || (MapLinedef.Special == 165)
                            || (MapLinedef.Special == 168)
                            || (MapLinedef.Special == 183)
                            || (MapLinedef.Special == 184)
                            || (MapLinedef.Special == 185)
                            || (MapLinedef.Special == 188)
                            || ((MapLinedef.Special >= 0x2F80) && (MapLinedef.Special <= 0x2FFF))
                            || ((MapLinedef.Special >= 0x4000) && (MapLinedef.Special <= 0x5FFF))
                            || ((MapLinedef.Special >= 0x6000) && (MapLinedef.Special <= 0x7FFF)))
                            Result = true;
                        break;
                    case TMapNamespace.MapNamespaceZDoom:
                        if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial)
                            && ((MapLinedef.Special == 28)
                            || (MapLinedef.Special == 42)
                            || (MapLinedef.Special == 43)
                            || (MapLinedef.Special == 45)
                            || (MapLinedef.Special == 97)
                            || (MapLinedef.Special == 99)
                            || (MapLinedef.Special == 104)
                            || (MapLinedef.Special == 168)
                            || (MapLinedef.Special == 169)
                            || (MapLinedef.Special == 195)
                            || (MapLinedef.Special == 196)
                            || (MapLinedef.Special == 197)
                            || (MapLinedef.Special == 205)
                            || (MapLinedef.Special == 284)))
                                Result = true;
                        break;
                }
            return Result;
        }
        /// <summary>
        /// Function <c>CheckLinedefDoor</c> checks if a linedef has door special.
        /// </summary>
        /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
        internal bool CheckLinedefDoor(TMapLinedef MapLinedef)
        {
            bool Result = false;
            if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
                switch (MapDefinition.MapNamespace)
                {
                    case TMapNamespace.MapNamespaceDoom:
                        if ((MapLinedef.Special == 1) || (MapLinedef.Special == 32) || (MapLinedef.Special == 33) || (MapLinedef.Special == 34))
                            Result = true;
                        break;
                    case TMapNamespace.MapNamespaceZDoom:
                        if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial))
                           if ((MapLinedef.Special == 11) || (MapLinedef.Special == 12))
                               Result = true;
                        break;
                }
            if (Result)
            {
                // Check if the LINEDEF is connected to the back SIDEDEF's SECTOR tag ID.
                if (MapLinedef.Arg0 != 0)
                {
                    int BackSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                    if (MapDefinition.MapSector[BackSector].ID != MapLinedef.Arg0)
                        Result = false;
                }
            }
            return Result;
        }
        /// <summary>
        /// Function <c>CheckLinedefTeleporter</c> checks if a linedef has teleporter special.
        /// </summary>
        /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
        internal bool CheckLinedefTeleporter(TMapLinedef MapLinedef)
        {
            bool Result = false;
            if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
                switch (MapDefinition.MapNamespace)
                {
                    case TMapNamespace.MapNamespaceDoom:
                        if ((MapLinedef.Special == 97) || (MapLinedef.Special == 126))
                            Result = true;
                        break;
                    default:
                        if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial))
                            if ((MapLinedef.Special == 70) || (MapLinedef.Special == 71))
                                Result = true;
                        break;
                }
            return Result;
        }
        /// <summary>
        /// Function <c>CheckLinedef3D</c> checks if a linedef has 3D special.
        /// </summary>
        /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
        internal bool CheckLinedef3D(TMapLinedef MapLinedef)
        {
            bool Result = false;
            if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom)
                if ((MapLinedef.Special == 160) && ((((MapLinedef.Arg1 & 0x0003) == 0x0001) || ((MapLinedef.Arg1 & 0x0003) == 0x0002))))
                    Result = true;
            return Result;
        }
        /// <summary>
        /// Function <c>PreProcessMapData</c> ignores lines and sectors according to some criteria.
        /// </summary>
        internal void PreProcessMapData()
        {
            // Ignore the doors that close after 30 seconds after level start.
            foreach (TMapSector MapSector in MapDefinition.MapSector)
                if (MapSector.Special == 10)
                    MapSector.Ignored = true;
            foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
            {
                // Ignore the crushing ceilings and other dangerous sectors.
                if (CheckLinedefCrushing(MapLinedef))
                {
                    if (MapLinedef.Arg0 == 0)
                    {
                        if (MapLinedef.SideBack >= 0)
                        {
                            int SectorIndex = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                            MapDefinition.MapSector[SectorIndex].Ignored = true;
                        }
                    }
                    else
                        foreach (TMapSector MapSector in MapDefinition.MapSector)
                            if (MapSector.ID == MapLinedef.Arg0)
                                MapSector.Ignored = true;
                }
                // Process the doors: adds the necessary data into the MapDoors list.
                if (CheckLinedefDoor(MapLinedef))
                {
                    int DoorSide1Sector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                    int DoorSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                    int OtherLinedef = -1;
                    foreach (TMapSidedef SearchSidedef in MapDefinition.MapSidedef.FindAll((Sidedef) => (Sidedef.Sector == DoorSector) && (Sidedef.Index != MapLinedef.SideBack)))
                        foreach (TMapLinedef SearchLinedef in MapDefinition.MapLinedef)
                            if ((SearchLinedef.SideBack == SearchSidedef.Index) && (CheckLinedefDoor(SearchLinedef)))
                            {
                                OtherLinedef = SearchLinedef.Index;
                                break;
                            }
                    if (OtherLinedef >= 0)
                    {
                        int DoorSide2Sector = MapDefinition.MapSidedef[MapDefinition.MapLinedef[OtherLinedef].SideFront].Sector;
                        TMapDoor MapDoor = new TMapDoor();
                        MapDoor.DoorSector = MapDefinition.MapSector[DoorSector];
                        MapDoor.SideLine1 = MapLinedef;
                        MapDoor.SideLine2 = MapDefinition.MapLinedef[OtherLinedef];
                        MapDoor.SideSector1 = MapDefinition.MapSector[DoorSide1Sector];
                        MapDoor.SideSector2 = MapDefinition.MapSector[DoorSide2Sector];
                        MapDoor.DoorHeightCeiling = Math.Min(MapDoor.SideSector1.HeightCeiling, MapDoor.SideSector2.HeightCeiling) - 8;
                        MapDoors.Add(MapDoor);
                    }
                }
                // Process the teleporters: adds the necessary data into the MapDoors list.
                if (CheckLinedefTeleporter(MapLinedef))
                {
                    TMapTeleporter MapTeleporter;
                    switch (MapDefinition.MapNamespace)
                    {
                        case TMapNamespace.MapNamespaceDoom:
                            MapTeleporter = new TMapTeleporter();
                            MapTeleporter.MapLinedef = MapLinedef;
                            MapTeleporter.SectorTag = MapLinedef.Arg0;
                            MapTeleporters.Add(MapTeleporter);
                            break;
                        case TMapNamespace.MapNamespaceHexen:
                            int DestinationCount = 0;
                            int ThingIndex = 0;
                            foreach (TMapThing MapThing in MapDefinition.MapThing)
                                if ((MapThing.ThingType == 14) && (MapThing.ID == MapLinedef.Arg0))
                                {
                                    ThingIndex = MapThing.Index;
                                    DestinationCount++;
                                    if (DestinationCount > 1)
                                        break;
                                }
                            if (DestinationCount == 1)
                            {
                                MapTeleporter = new TMapTeleporter();
                                MapTeleporter.MapLinedef = MapLinedef;
                                MapTeleporter.SectorTag = MapLinedef.Arg1;
                                MapTeleporter.DestinationThing = MapDefinition.MapThing[ThingIndex];
                                MapTeleporters.Add(MapTeleporter);
                            }
                            break;
                        case TMapNamespace.MapNamespaceZDoom:
                            DestinationCount = 0;
                            ThingIndex = 0;
                            foreach (TMapThing MapThing in MapDefinition.MapThing)
                                if (((MapThing.ThingType == 14) || (MapThing.ThingType == 9044)) && (MapThing.ID == MapLinedef.Arg0))
                                {
                                    ThingIndex = MapThing.Index;
                                    DestinationCount++;
                                    if (DestinationCount > 1)
                                        break;
                                }
                            if (DestinationCount == 1)
                            {
                                MapTeleporter = new TMapTeleporter();
                                MapTeleporter.MapLinedef = MapLinedef;
                                MapTeleporter.SectorTag = MapLinedef.Arg1;
                                MapTeleporter.DestinationThing = MapDefinition.MapThing[ThingIndex];
                                MapTeleporters.Add(MapTeleporter);
                            }
                            break;
                    }
                }
                // Process the 3D sectors.
                if (CheckLinedef3D(MapLinedef))
                {
                    TMapSector3D MapSector3D = new TMapSector3D();
                    MapSector3D.SectorTag = MapLinedef.Arg0;
                    if ((MapLinedef.Arg1 & 0x0003) == 0x0001)
                        MapSector3D.Swimmable = false;
                    MapSector3D.ControlLinedef = MapLinedef;
                    int ControlSector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                    MapSector3D.ControlSector = MapDefinition.MapSector[ControlSector];
                    MapSectors3D.Add(MapSector3D); 
                }
            }
        }
        /// <summary>
        /// Function <c>GetPolygonGroups</c> creates the list of SectorGroup from a SECTOR.
        /// </summary>
        /// <param name="Sector"><c>Sector</c> is the map's SECTOR to split into a list of SectorGroup.</param>
        /// <returns>A list of <c>TPolygonGroup</c>, each one represents a closed region, that can contain holes.</returns>
        internal List<TPolygonGroup> GetPolygonGroups(TPolygon Sector)
        {
            // If the SECTOR has less than 3 LINEDEF, then it's scrapped.
            if (Sector.Lines.Count < 3)
                return null;
            List<TPolygonGroup> SectorPolygons = new List<TPolygonGroup>();
            // Split the closed regions of the SECTOR.
            List<TPolygon> Sectors = new List<TPolygon>();
            List<Boolean> CheckedLine = new List<Boolean>(Sector.Lines.Count);
            for (int I = 0; I < Sector.Lines.Count; I++)
                CheckedLine.Add(false);
            do
            {
                int FirstLine = CheckedLine.FindIndex((Line) => Line == false);
                if (FirstLine >= 0)
                {
                    TPolygon Polygon = new TPolygon();
                    Polygon.HeightFloor = Sector.HeightFloor;
                    Polygon.HeightCeiling = Sector.HeightCeiling;
                    Polygon.MapSector = Sector.MapSector;
                    Polygon.AddLine(Sector.Lines[FirstLine]);
                    CheckedLine[FirstLine] = true;
                    int CurrentLine = FirstLine;
                    int NextLine;
                    do
                    {
                        NextLine = Sector.Lines.FindIndex((Line) => Line.A == Sector.Lines[CurrentLine].B);
                        if ((NextLine >= 0) && (CheckedLine[NextLine]))
                            break;
                        if ((NextLine >= 0) && (NextLine != FirstLine))
                        {
                            Polygon.AddLine(Sector.Lines[NextLine]);
                            CheckedLine[NextLine] = true;
                            CurrentLine = NextLine;
                        }
                    } while ((NextLine >= 0) && (NextLine != FirstLine));
                    if (Polygon.IsClosed())
                    {
                        Polygon.SortLines();
                        Sectors.Add(Polygon);
                    }
                }
            } while (!CheckedLine.All((Line) => Line == true));
            if (Sectors.Count == 0)
                return null;
            if (Sectors.Count == 1)
            {
                // Only one closed region.
                TPolygonGroup SectorPolygon = new TPolygonGroup();
                SectorPolygon.Polygon = Sectors[0];
                SectorPolygons.Add(SectorPolygon);
            }
            else
            {
                // Multiple closed regions.
                // Check the holes and nested regions / holes.
                int[] PolygonDepthLevel = new int[Sectors.Count];
                for (int I = 0; I < Sectors.Count; I++)
                    PolygonDepthLevel[I] = 0;
                for (int I = 0; I < Sectors.Count; I++)
                    for (int J = 0; J < Sectors.Count; J++)
                        if (I != J)
                            if (PolygonInsidePolygon(Sectors[I], Sectors[J]))
                                PolygonDepthLevel[J]++;
                int MaxDepthLevel = PolygonDepthLevel.Max();
                for (int DepthLevel = 0; DepthLevel <= MaxDepthLevel; DepthLevel += 2)
                    for (int I = 0; I < Sectors.Count; I++)
                        if (PolygonDepthLevel[I] == DepthLevel)
                        {
                            TPolygonGroup SectorPolygon = new TPolygonGroup();
                            SectorPolygon.Polygon = Sectors[I];
                            for (int J = 0; J < Sectors.Count; J++)
                                if ((I != J) && (PolygonInsidePolygon(Sectors[I], Sectors[J])))
                                    SectorPolygon.Holes.Add(Sectors[J]);
                            SectorPolygons.Add(SectorPolygon);
                        }
            }
            return SectorPolygons;
        }
        /// <summary>
        /// Function <c>ProcessPolygonMesh</c> adds a mesh to the navigation mesh.
        /// </summary>
        /// <param name="Polygon"><c>Polygon</c> is the mesh to be added.</param>
        internal void ProcessPolygonMesh(TPolygon Polygon, int MapSector)
        {
            // Check if there is enough vertical space.
            int MapDoorIndex = MapDoors.FindIndex((MapDoor) => MapDoor.DoorSector.Index == MapSector);
            if (MapDoorIndex >= 0)
                Polygon.HeightCeiling = MapDoors[MapDoorIndex].DoorHeightCeiling;
            if ((Polygon.HeightCeiling - Polygon.HeightFloor) < NavMeshSettings.ActorHeight)
                return;
            // Search for portals.
            foreach (TLine Line in Polygon.Lines)
            {
                // Check for portals.
                int CurrentPolygonIndex = 0;
                int CurrentPolygonLine = 0;
                for (int I = 0; I < FLines.Count; I++)
                {
                    if (((Line.A == FLines[I].A) && (Line.B == FLines[I].B)) || ((Line.A == FLines[I].B) && (Line.B == FLines[I].A)))
                    {
                        bool LineIsPortal = true;
                        int MapLinedefIndex = MapDefinition.MapLinedef.FindIndex((Linedef) =>
                            {
                                TMapVertex V1 = MapDefinition.MapVertex[Linedef.V1];
                                TMapVertex V2 = MapDefinition.MapVertex[Linedef.V2];
                                return ((Line.A.X == V1.X) && (Line.A.Y == V1.Y) && (Line.B.X == V2.X) && (Line.B.Y == V2.Y))
                                    || ((Line.A.X == V2.X) && (Line.A.Y == V2.Y) && (Line.B.X == V1.X) && (Line.B.Y == V1.Y));
                            }
                        );
                        // If the line is generated from the splitting of the SECTOR, then it's a portal, else check further.
                        if (MapLinedefIndex >= 0)
                        {
                            // Check if the LINEDEF blocks monsters.
                            TMapLinedef MapLinedef = MapDefinition.MapLinedef[MapLinedefIndex];
                            if ((MapLinedef.Blocking) || (MapLinedef.SideFront < 0) || (MapLinedef.SideBack < 0) || (MapLinedef.Ignored))
                                LineIsPortal = false;
                            // Check if the two floor heights are too different.
                            int HeightFloorDifference = Math.Abs(Polygon.HeightFloor - FPolygons[CurrentPolygonIndex].HeightFloor);
                            if (HeightFloorDifference > 24)
                                LineIsPortal = false;
                            // Check if there is enough vertical space between the two connecting sectors.
                            int VerticalSpace = Math.Min(Polygon.HeightCeiling, FPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, FPolygons[CurrentPolygonIndex].HeightFloor);
                            if (VerticalSpace < NavMeshSettings.ActorHeight)
                                LineIsPortal = false;
                        }
                        if (LineIsPortal)
                        {
                            Line.Portal = CurrentPolygonIndex;
                            FLines[I].Portal = FPolygons.Count;
                        }
                        Line.MapLinedef = MapLinedefIndex;
                        FLines[I].MapLinedef = MapLinedefIndex;
                    }
                    CurrentPolygonLine++;
                    if (CurrentPolygonLine == FPolygons[CurrentPolygonIndex].LineCount)
                    {
                        CurrentPolygonLine = 0;
                        CurrentPolygonIndex++;
                    }
                }
            }
            // Add the polygon.
            Polygon.LineFirst = FLines.Count;
            Polygon.LineCount = Polygon.Lines.Count;
            FPolygons.Add(Polygon);
            // Add the lines.
            foreach (TLine Line in Polygon.Lines)
                FLines.Add(Line);
        }
        /// <summary>
        /// Function <c>ProcessTeleporters</c> sets the portals between teleporters.
        /// </summary>
        internal void ProcessTeleporters()
        {
            TPoint V1 = new TPoint(0, 0);
            TPoint V2 = new TPoint(0, 0);
            TPoint TeleporterDestinationCenter = new TPoint(0, 0);
            foreach (TLine Line in FLines)
            {
                V1.X = Line.A.X;
                V1.Y = Line.A.Y;
                V2.X = Line.B.X;
                V2.Y = Line.B.Y;
                foreach (TMapTeleporter MapTeleporter in MapTeleporters)
                {
                    if (!(MapTeleporter.DestinationThing is null))
                    {
                        if (((Line.A == V1) && (Line.B == V2)) || ((Line.A == V2) && (Line.B == V1)))
                        {
                            // Get the polygon, that contains the teleporter destination.
                            TeleporterDestinationCenter.X = MapTeleporter.DestinationThing.X;
                            TeleporterDestinationCenter.Y = MapTeleporter.DestinationThing.Y;
                            int PolygonIndex = 0;
                            bool NotFound = true;
                            while ((NotFound) && (PolygonIndex < FPolygons.Count))
                                if (PointInsidePolygon(FPolygons[PolygonIndex], TeleporterDestinationCenter))
                                    if ((MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom) && (MapTeleporter.DestinationThing.ThingType == 9044))
                                        if ((MapTeleporter.DestinationThing.Z >= FPolygons[PolygonIndex].HeightFloor) && (MapTeleporter.DestinationThing.Z <= FPolygons[PolygonIndex].HeightCeiling))
                                            NotFound = false;
                                        else
                                            PolygonIndex++;
                                    else
                                        PolygonIndex++;
                            if (!NotFound)
                                Line.Portal = PolygonIndex;
                        }
                    }
                }
            }
        }
        /// <summary>
        /// Function <c>ProcessCells</c> builds the cell space partitioning system of the navigation mesh.
        /// </summary>
        internal void ProcessCells()
        {
            int MaxX = Int32.MinValue;
            int MaxY = Int32.MinValue;
            int MinX = Int32.MaxValue;
            int MinY = Int32.MaxValue;
            foreach (TLine Line in FLines)
            {
                if (Line.A.X > MaxX)
                    MaxX = Line.A.X;
                if (Line.A.Y > MaxY)
                    MaxY = Line.A.Y;
                if (Line.B.X > MaxX)
                    MaxX = Line.B.X;
                if (Line.B.Y > MaxY)
                    MaxY = Line.B.Y;
                if (Line.A.X < MinX)
                    MinX = Line.A.X;
                if (Line.A.Y < MinY)
                    MinY = Line.A.Y;
                if (Line.B.X < MinX)
                    MinX = Line.B.X;
                if (Line.B.Y < MinY)
                    MinY = Line.B.Y;
            }
            FOffsetCellX = (MinX + GridOffset) >> 8;
            FOffsetCellY = (MinY + GridOffset) >> 8;
            int LastCellX = (MaxX + GridOffset) >> 8;
            int LastCellY = (MaxY + GridOffset) >> 8;
            FNumCellX = LastCellX - FOffsetCellX + 1;
            FNumCellY = LastCellY - FOffsetCellY + 1;
            FCells = new List<Int32>[FNumCellY, FNumCellX];
            for (int Y = 0; Y < FNumCellY; Y++)
                for (int X = 0; X < FNumCellX; X++)
                    FCells[Y, X] = new List<Int32>();
            for (int PolygonIndex = 0; PolygonIndex < FPolygons.Count; PolygonIndex++)
            {
                MaxX = Int32.MinValue;
                MaxY = Int32.MinValue;
                MinX = Int32.MaxValue;
                MinY = Int32.MaxValue;
                foreach (TLine Line in FPolygons[PolygonIndex].Lines)
                {
                    if (Line.A.X > MaxX)
                        MaxX = Line.A.X;
                    if (Line.A.Y > MaxY)
                        MaxY = Line.A.Y;
                    if (Line.B.X > MaxX)
                        MaxX = Line.B.X;
                    if (Line.B.Y > MaxY)
                        MaxY = Line.B.Y;
                    if (Line.A.X < MinX)
                        MinX = Line.A.X;
                    if (Line.A.Y < MinY)
                        MinY = Line.A.Y;
                    if (Line.B.X < MinX)
                        MinX = Line.B.X;
                    if (Line.B.Y < MinY)
                        MinY = Line.B.Y;
                }
                MinX = (MinX + GridOffset) >> 8;
                MinY = (MinY + GridOffset) >> 8;
                MaxX = (MaxX + GridOffset) >> 8;
                MaxY = (MaxY + GridOffset) >> 8;
                for (int Y = MinY; Y <= MaxY; Y++)
                    for (int X = MinX; X <= MaxX; X++)
                        FCells[Y - FOffsetCellY, X - FOffsetCellX].Add(PolygonIndex);
            }
        }
        /// <summary>
        /// Function <c>ProcessPolygons</c> receives the polygons from the a group of polygons from a map SECTORS and processes them.
        /// </summary>
        /// <param name="HeightCeiling"><c>HeightCeiling</c> is the height of the ceiling of the map SECTOR or 3D sector.</param>
        /// <param name="HeightFloor"><c>HeightFloor</c> is the height of the floor of the map SECTOR or 3D sector.</param>
        /// <param name="Polygons"><c>Polygons</c> contains the list of PolygonGroup from the map SECTOR.</param>
        internal void ProcessPolygons(List<TPPLPolygon> Polygons, int HeightFloor, int HeightCeiling, int MapSector, int Flags = 0)
        {
            foreach (TPPLPolygon Polygon in Polygons)
            {
                // Generate the mesh polygon.
                TPolygon Mesh = new TPolygon();
                Mesh.HeightFloor = HeightFloor;
                Mesh.HeightCeiling = HeightCeiling;
                Mesh.MapSector = MapSector;
                Mesh.Flags = Flags;
                for (int I = 0; I < Polygon.Points.Count; I++)
                {
                    int J = (I + 1) % Polygon.Points.Count;
                    Mesh.Lines.Add(
                        new TLine(
                            new TPoint(Convert.ToInt32(Polygon.Points[I].X), Convert.ToInt32(Polygon.Points[I].Y)),
                            new TPoint(Convert.ToInt32(Polygon.Points[J].X), Convert.ToInt32(Polygon.Points[J].Y))
                        )
                    );
                }
                // Append the mesh polygon to the navigation mesh.
                Polygon.SetOrientation(TPPLOrientation.PPLOrientationCounterClockwise);
                ProcessPolygonMesh(Mesh, MapSector);
            }
        }
        /// <summary>
        /// Function <c>ProcessMapData</c> processes the map lines and sectors into convex polygons.
        /// </summary>
        internal void ProcessMapData()
        {
            foreach (TMapSector MapSector in MapDefinition.MapSector)
                if (!MapSector.Ignored)
                {
                    TPolygon SectorPolygon = new TPolygon();
                    SectorPolygon.MapSector = MapSector.Index;
                    foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
                        if ((MapLinedef.SideFront >= 0) && (MapDefinition.MapSidedef[MapLinedef.SideFront].Sector == MapSector.Index))
                        {
                            TLine Line = new TLine(
                                new TPoint(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y),
                                new TPoint(MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y)
                            );
                            Line.MapLinedef = MapLinedef.Index;
                            SectorPolygon.AddLine(Line);
                        }
                    foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
                        if ((MapLinedef.SideBack >= 0) && (MapDefinition.MapSidedef[MapLinedef.SideBack].Sector == MapSector.Index))
                        {
                            TLine Line = new TLine(
                                new TPoint(MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y),
                                new TPoint(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y)
                            );
                            Line.MapLinedef = MapLinedef.Index;
                            SectorPolygon.AddLine(Line);
                        }
                    // Split the map sectors into a list of TPolygonGroup.
                    List<TPolygonGroup> PolygonGroups = GetPolygonGroups(SectorPolygon);
                    if (!(PolygonGroups is null))
                    {
                        foreach (TPolygonGroup PolygonGroup in PolygonGroups)
                        {
                            List<TPPLPolygon> InputPolygons = new List<TPPLPolygon>();
                            // Outer polygon edges.
                            TPPLPolygon Polygon = new TPPLPolygon();
                            foreach (TLine Line in PolygonGroup.Polygon.Lines)
                                Polygon.AddPoint(new TPPLPoint(Line.A.X, Line.A.Y));
                            Polygon.Hole = false;
                            InputPolygons.Add(Polygon);
                            // Inner holes polygon edges.
                            foreach (TPolygon Sector in PolygonGroup.Holes)
                            {
                                TPPLPolygon Hole = new TPPLPolygon();
                                foreach (TLine Line in Sector.Lines)
                                    Hole.AddPoint(new TPPLPoint(Line.A.X, Line.A.Y));
                                Hole.Hole = true;
                                InputPolygons.Add(Hole);
                            }
                            // Search for teleporter destinations.
                            if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceDoom)
                            {
                                foreach (TMapTeleporter MapTeleporter in MapTeleporters)
                                {
                                    if (MapTeleporter.SectorTag == MapSector.ID)
                                    {
                                        TPoint TeleporterDestinationCenter = new TPoint(0, 0);
                                        int ThingIndex = 0;
                                        bool NotFound = true;
                                        while ((!NotFound) && (ThingIndex < MapDefinition.MapThing.Count))
                                        {
                                            if (MapDefinition.MapThing[ThingIndex].ThingType == 14)
                                            {
                                                bool DestinationInSector = false;
                                                bool DestinationInHoles = false;
                                                TeleporterDestinationCenter.X = MapDefinition.MapThing[ThingIndex].X;
                                                TeleporterDestinationCenter.Y = MapDefinition.MapThing[ThingIndex].Y;
                                                if (PointInsidePolygon(PolygonGroup.Polygon, TeleporterDestinationCenter))
                                                {
                                                    DestinationInSector = true;
                                                    foreach (TPolygon HolePolygon in PolygonGroup.Holes)
                                                        if (PointInsidePolygon(HolePolygon, TeleporterDestinationCenter))
                                                        {
                                                            DestinationInHoles = true;
                                                            break;
                                                        }
                                                }
                                                if ((DestinationInSector) && (!DestinationInHoles))
                                                    NotFound = false;
                                                else
                                                    ThingIndex++;
                                            }
                                            else
                                                ThingIndex++;
                                        }
                                        if (NotFound)
                                            // Remove the teleporter.
                                            MapTeleporter.DestinationThing = null;
                                        else
                                            MapTeleporter.DestinationThing = MapDefinition.MapThing[ThingIndex];
                                    }
                                }
                            }
                            // Perform the polygon partitioning into convex subpolygons.
                            List<TPPLPolygon> OutputPolygons = new List<TPPLPolygon>();
                            //TPPLPartition.Triangulate_EC(InputPolygons, OutputPolygons);
                            TPPLPartition.ConvexPartition_HM(InputPolygons, OutputPolygons);
                            // Search for 3D sectors.
                            int Sector3D = MapSectors3D.FindIndex((MapSector3D) => MapSector3D.SectorTag == MapSector.ID);
                            if (Sector3D >= 0)
                            {
                                int MiddleFloor = MapSectors3D[Sector3D].ControlSector.HeightFloor;
                                int MiddleCeiling = MapSectors3D[Sector3D].ControlSector.HeightCeiling;
                                if (MiddleFloor > MapSector.HeightFloor)
                                    ProcessPolygons(OutputPolygons, MapSector.HeightFloor, MiddleFloor, MapSector.Index, 0);
                                if (MiddleCeiling < MapSector.HeightCeiling)
                                    ProcessPolygons(OutputPolygons, MiddleCeiling, MapSector.HeightCeiling, MapSector.Index, MapSectors3D[Sector3D].Swimmable ? 0x0003 : 0x0001);
                            }
                            else
                                ProcessPolygons(OutputPolygons, MapSector.HeightFloor, MapSector.HeightCeiling, MapSector.Index);
                        }
                    }
                }
        }
        public void Build(TNavMeshSettings NavMeshSettings, TMapDefinition MapDefinition)
        {
            this.NavMeshSettings = NavMeshSettings ?? throw new ArgumentNullException(nameof(NavMeshSettings));
            this.MapDefinition = MapDefinition ?? throw new ArgumentNullException(nameof(MapDefinition));
            // Builds the map grid.
            CalcMapGrid();
            // Performs some filtering.
            PreProcessMapData();
            // Process the map data.
            ProcessMapData();
            // Final processing.
            if (FPolygons.Count > 0)
            {
                ProcessTeleporters();
                ProcessCells();
            }
        }
        public override string ToString()
        {
            StringBuilder SB = new StringBuilder();
            SB.AppendLine("# ZDOOMNAVMESH");
            SB.AppendLine();
            SB.AppendLine("# lines");
            for (int I = 0; I < Lines.Count; I++)
                SB.AppendFormat("l {0} {1} {2} {3} {4} {5} {6}", Lines[I].A.X, Lines[I].A.Y, Lines[I].B.X, Lines[I].B.Y, Lines[I].Portal, Lines[I].MapLinedef, Lines[I].Flags).AppendLine();
            SB.AppendLine();
            SB.AppendLine("# polygons");
            for (int I = 0; I < Polygons.Count; I++)
                SB.AppendFormat("p {0} {1} {2} {3} {4} {5}", Polygons[I].HeightFloor, Polygons[I].HeightCeiling, Polygons[I].LineFirst, Polygons[I].LineCount, Polygons[I].MapSector, Polygons[I].Flags).AppendLine();
            SB.AppendLine();
            SB.AppendLine("# cells space partitioning");
            SB.AppendFormat("o {0} {1} {2} {3}", OffsetCellX, OffsetCellY, NumCellX, NumCellY).AppendLine();
            for (int Y = 0; Y < NumCellY; Y++)
                for (int X = 0; X < NumCellX; X++)
                    if (Cells[Y, X].Count > 0)
                    {
                        SB.AppendFormat("c {0}", Y * NumCellX + X);
                        foreach (Int32 PolygonIndex in Cells[Y, X])
                            SB.AppendFormat(" {0}", PolygonIndex);
                        SB.AppendLine();
                    }
            return SB.ToString();
        }
    }
}
