//==============================================================================
//
// Navigation mesh ZScript module for ZDoom.
//
//==============================================================================

// -----------------------------------------------------------------------------
// Memory management classes.
// -----------------------------------------------------------------------------

// Base class for NavMesh classes.
class TCustomNavMesh : Object abstract
{
}

// Class TGridPage allocates space for 1024 FAT-like entries.
class TGridPage: TCustomNavMesh
{
	int Values[1024];
	int Chains[1024];
	static TGridPage Create()
	{
		return New('TGridPage');
	}
}

// Class TGridLast is used to dynamically allocate FAT-like arrays.
// It also manages the "Per-sector polygons chain".
class TGridList: TCustomNavMesh
{
	const MaxPages = 1024;
	const MaxGridChains = 65536;
	const MaxSearchResults = 4096;
	TGridPage GridPages[MaxPages];
	int GridChains[MaxGridChains];
	int GridCount;
	int SearchResults[MaxSearchResults];
	int SearchResultCount;
	void Clear()
	{
		GridCount = 0;
		for (int I = 0; I < MaxGridChains; I++)
			GridChains[I] = -1;
		SearchResultCount = 0;
	}
	void ClearSearchResult()
	{
		SearchResultCount = 0;
	}
	void SearchResult(int Value)
	{
		int First = 0;
		int Last = SearchResultCount - 1;
		int Pivot;
		while (First <= Last)
		{
			Pivot = (First + Last) / 2;
			if (SearchResults[Pivot] == Value)
				return;
			if (SearchResults[Pivot] < Value)
				First = Pivot + 1;
			else
				Last = Pivot - 1;
		}
		if (SearchResultCount >= MaxSearchResults)
		{
			Console.Printf("NavMesh building, TGridList.SearchResult: hit limit reached, %i", MaxSearchResults);
			return;
		}
		for (int I = SearchResultCount - 1; I >= First; I--)
			SearchResults[I + 1] = SearchResults[I];
		SearchResults[First] = Value;
		SearchResultCount++;
	}
	void Search(int ChainNumber)
	{
		int LastChain = GridChains[ChainNumber];
		while (LastChain >= 0)
		{
			int PageNumber = LastChain >> 10;
			int PageIndex = LastChain & 1023;
			int Value = GridPages[PageNumber].Values[PageIndex];
			SearchResult(Value);
			LastChain = GridPages[PageNumber].Chains[PageIndex];
		}
	}
	void SearchOneCell(int GridX, int GridY)
	{
		int ChainNumber = (GridY << 8) + GridX;
		Search(ChainNumber);
	}
	void SearchGrid(int MinX, int MaxX, int MinY, int MaxY)
	{
		for (int Y = MinY; Y <= MaxY; Y++)
			for (int X = MinX; X <= MaxX; X++)
				SearchOneCell(X, Y);
	}
	void Add(int ChainNumber, int Value)
	{
		// Add the entry in the polygon chains.
		int PageNumber = GridCount >> 10;
		int PageIndex = GridCount & 1023;
		if (!GridPages[PageNumber])
			GridPages[PageNumber] = TGridPage.Create();
		GridPages[PageNumber].Values[PageIndex] = Value;
		GridPages[PageNumber].Chains[PageIndex] = GridChains[ChainNumber];
		GridChains[ChainNumber] = GridCount;
		GridCount++;
	}
	void AddGrid(int GridX, int GridY, int Value)
	{
		int ChainNumber = (GridY << 8) + GridX;
		Add(ChainNumber, Value);
	}
	void AddGrids(int MinX, int MinY, int MaxX, int MaxY, int Value)
	{
		for (int Y = MinY; Y <= MaxY; Y++)
			for (int X = MinX; X <= MaxX; X++)
				AddGrid(X, Y, Value);
	}
	void Fill(int ChainNumber, out Array<int> Result)
	{
		int LastChain = GridChains[ChainNumber];
		while (LastChain >= 0)
		{
			int PageNumber = LastChain >> 10;
			int PageIndex = LastChain & 1023;
			int Value = GridPages[PageNumber].Values[PageIndex];
			if (Result.Find(Value) == Result.Size())
				Result.Push(Value);
			LastChain = GridPages[PageNumber].Chains[PageIndex];
		}
	}
	void FillOneCell(int GridX, int GridY, out Array<int> Result)
	{
		int ChainNumber = (GridY << 8) + GridX;
		Fill(ChainNumber, Result);
	}
	void FillGrid(int MinX, int MaxX, int MinY, int MaxY, out Array<int> Result)
	{
		for (int Y = MinY; Y <= MaxY; Y++)
			for (int X = MinX; X <= MaxX; X++)
				FillOneCell(X, Y, Result);
	}
	static TGridList Create()
	{
		TGridList Result = New('TGridList');
		Result.Clear();
		return Result;
	}
	override void OnDestroy()
	{
		for (int PageNumber = 0; PageNumber < MaxPages; PageNumber++)
			if (GridPages[PageNumber])
				GridPages[PageNumber].Destroy();
	}
}

// -----------------------------------------------------------------------------
// Data classes, that will store the navigation mesh.
// -----------------------------------------------------------------------------

// Class representing a line of the NavMesh.
class TNavMeshLine : TCustomNavMesh
{
	short X1, Y1, X2, Y2;
	int Portal;
	int MapLinedef;
}

// Class representing a polygon of the NavMesh.
class TNavMeshPolygon : TCustomNavMesh
{
	short HeightFloor, HeightCeiling;
	int LineFirst, LineCount;
	int MapSector;
}

// Class representing a node in the search algorithm.
class TNavMeshNode : TCustomNavMesh
{
	bool Closed, Visited;
	int F, G, H;
	int LinePortal;
	int Parent;
	void Initialize()
	{
		Closed = False;
		Visited = False;
		F = 0;
		G = 0;
		H = 0;
		LinePortal = -1;
		Parent = -1;
	}
}

// Class representing a step in the route.
class TNavMeshRoute : TCustomNavMesh
{
	int Polygon;
	int LinePortal;
	Vector3 Position;
}

// Class implementing the NavMesh and the A* algorithm.
class TNavMesh : TCustomNavMesh
{
	const GridOffset = 32768;
	// Lines storage.
	int LineCount;
	Array<TNavMeshLine> NavMeshLines;
	// Polygons storage.
	int PolygonCount;
	Array<TNavMeshPolygon> NavMeshPolygons;
	// Cells space partitioning storage.
	int CellOffsetX;
	int CellOffsetY;
	int CellNumX;
	int CellNumY;
	Array<Int> Cells;
	Array<Int> CellsIndex;
	// "Per-sector polygons chain".
	TGridList PolygonChain;
	// Node list and temp arrays.
	Array<TNavMeshNode> NavNodes;
	int SearchPolygons[64];
	// Node list.
	// Checks if a point is inside a convex polygon.
	bool PointInPolygon(Vector3 Point, int PolygonIndex)
	{
		TNavMeshPolygon NavMeshPolygon = NavMeshPolygons[PolygonIndex];
		// Check if Z is inside polygon floor and ceiling heights.
		if ((Point.Z < NavMeshPolygon.HeightFloor) || (Point.Z > NavMeshPolygon.HeightCeiling))
			return False;
		// Keep track of cross product sign changes.
		int Positive = 0;
		int Negative = 0;
		int LineIndex = NavMeshPolygon.LineFirst;
		for (int I = 0; I < NavMeshPolygon.LineCount; I++)
		{
			// Check if Point is in the polygon.
			TNavMeshLine NavMeshLine = NavMeshLines[LineIndex];
			if ((NavMeshLine.X1 == Point.X) && (NavMeshLine.Y1 == Point.Y))
				return True;
			int CrossProduct = (Point.X - NavMeshLine.X1) * (NavMeshLine.Y2 - NavMeshLine.Y1) - (Point.Y - NavMeshLine.Y1) * (NavMeshLine.X2 - NavMeshLine.X1);
			if (CrossProduct > 0)
				Positive++;
			if (CrossProduct < 0)
				Negative++;
			// If the sign changes, the point is outside.
			if ((Positive > 0) && (Negative > 0))
				return False;
			LineIndex++;
		}
		// The point is on same side of all polygon lines.
		return True;
	}
	// Searchs the polygon index in NavMeshPolygons, that contains the given point; -1 if not found.
	int SearchPolygon(Vector3 Point)
	{
		// Use the cells partitioning system if available.
		int CellPointX = Point.X + GridOffset;
		int CellPointY = Point.Y + GridOffset;
		CellPointX = (CellPointX >> 8) - CellOffsetX;
		CellPointY = (CellPointY >> 8) - CellOffsetY;
		if ((CellPointX >= 0) && (CellPointX < CellNumX) && (CellPointY >= 0) && (CellPointY < CellNumY))
		{
			int CellIndex = CellPointY * CellNumX + CellPointX;
			int CurrentCellIndex = CellsIndex[CellIndex];
			int NextCellIndex = CellsIndex[CellIndex + 1];
			while (CurrentCellIndex < NextCellIndex)
			{
				int PolygonIndex = Cells[CurrentCellIndex];
				if (PointInPolygon(Point, PolygonIndex))
					return PolygonIndex;
				CurrentCellIndex++;
			}
		}
		// Use the "Per-sector polygons chain" if available.
		if (PolygonChain)
		{
			PolygonChain.ClearSearchResult();
			PolygonChain.Search(Level.PointInSector(Point.XY).Index());
			for (int I = 0; I < PolygonChain.SearchResultCount; I++)
				if (PointInPolygon(Point, PolygonChain.SearchResults[I]))
					return PolygonChain.SearchResults[I];
		}
		return -1;
	}
	// Euclidean distance.
	int IntDistance(int X1, int Y1, int X2, int Y2)
	{
		Vector2 Result = (X1 - X2, Y1 - Y2);
		return Result.Length();
	}
	// Perform the A* algorythm.
	bool SearchRoute(int StartPolygon, int StopPolygon, in out Array<TNavMeshRoute> Route)
	{
		// Safety check.
		Route.Clear();
		if ((StartPolygon < 0) || (StopPolygon < 0) ||(StartPolygon == StopPolygon))
			return False;
		int StopX = (NavMeshLines[NavMeshPolygons[StopPolygon].LineFirst].X1 + NavMeshLines[NavMeshPolygons[StopPolygon].LineFirst].X2) / 2;
		int StopY = (NavMeshLines[NavMeshPolygons[StopPolygon].LineFirst].Y1 + NavMeshLines[NavMeshPolygons[StopPolygon].LineFirst].Y2) / 2;
		// Initialize the open list and the closed list.
		Array<int> OpenList;
		int CurrentNode;
		int I, J, LineIndex, MinF, MinNode, NodeIndex, Portal;
		bool NotFound;
		// Reset the nodes.
		for (I = 0; I < NavNodes.Size(); I++)
			NavNodes[I].Initialize();
		// Put the starting node on the open list.
		OpenList.Push(StartPolygon);
		// While the open list is not empty.
		while (OpenList.Size() > 0)
		{
			// Find the node with the least f on the open list, call it "MinNode".
			MinNode = 0;
			MinF = NavNodes[OpenList[MinNode]].F;
			for (I = 1; I < OpenList.Size(); I++)
				if (MinF > NavNodes[OpenList[I]].F)
				{
					MinNode = I;
					MinF = NavNodes[OpenList[MinNode]].F;
				}
			// Pop "MinNode" off the open list.
			CurrentNode = OpenList[MinNode];
			OpenList.Delete(MinNode);
			//CurrentNode = OpenList[OpenList.Size() - 1];
			//OpenList.Pop();
			NavNodes[CurrentNode].Closed = True;
			// Generate "MinNode"'s successors.
			I = 0;
			LineIndex = NavMeshPolygons[CurrentNode].LineFirst;
			while (I < NavMeshPolygons[CurrentNode].LineCount)
			{
				// For each successor.
				//LineIndex = I + NavMeshPolygons[CurrentNode.Polygon].LineFirst;
				Portal = NavMeshLines[LineIndex].Portal;
				if (Portal >= 0)
				{
					// If successor is the goal, stop search.
					if (Portal == StopPolygon)
					{
						TNavMeshRoute NavRoute = New('TNavMeshRoute');
						NavRoute.Polygon = StopPolygon;
						NavRoute.LinePortal = LineIndex;
						NavRoute.Position.X = (NavMeshLines[LineIndex].X1 + NavMeshLines[LineIndex].X2) / 2;
						NavRoute.Position.Y = (NavMeshLines[LineIndex].Y1 + NavMeshLines[LineIndex].Y2) / 2;
						NavRoute.Position.Z = NavMeshPolygons[StopPolygon].HeightFloor;
						Route.Push(NavRoute);
						NodeIndex = CurrentNode;
						while ((NodeIndex >= 0) && (NodeIndex != StartPolygon))
						{
							TNavMeshRoute NavRoute = New('TNavMeshRoute');
							NavRoute.Polygon = NodeIndex;
							NavRoute.LinePortal = NavNodes[NodeIndex].LinePortal;
							NavRoute.Position.X = (NavMeshLines[NavNodes[NodeIndex].LinePortal].X1 + NavMeshLines[NavNodes[NodeIndex].LinePortal].X2) / 2;
							NavRoute.Position.Y = (NavMeshLines[NavNodes[NodeIndex].LinePortal].Y1 + NavMeshLines[NavNodes[NodeIndex].LinePortal].Y2) / 2;
							NavRoute.Position.Z = NavMeshPolygons[NodeIndex].HeightFloor;
							Route.Push(NavRoute);
							NodeIndex = NavNodes[NodeIndex].Parent;
						}
						return True;
					}
					// Else, compute both g and h for successor.
					NodeIndex = Portal;
					if (!NavNodes[NodeIndex].Closed)
						if ((!NavNodes[NodeIndex].Visited) || ((NavNodes[CurrentNode].G + 1) < NavNodes[NodeIndex].G))
						{
							NavNodes[NodeIndex].H = IntDistance(
								(NavMeshLines[LineIndex].X1 + NavMeshLines[LineIndex].X2) / 2,
								(NavMeshLines[LineIndex].Y1 + NavMeshLines[LineIndex].Y2) / 2,
								StopX,
								StopY
							);
							NavNodes[NodeIndex].G = NavNodes[CurrentNode].G + 1;
							NavNodes[NodeIndex].F = NavNodes[NodeIndex].G + NavNodes[NodeIndex].H;
							if (!NavNodes[NodeIndex].Visited)
								OpenList.Push(NodeIndex);
							NavNodes[NodeIndex].Parent = CurrentNode;
							NavNodes[NodeIndex].LinePortal = LineIndex;
							NavNodes[NodeIndex].Visited = True;
						}
				}
				I++;
				LineIndex++;
			}
		}
		return False;
	}
	// Update an existing path.
	bool UpdateRoute(int LastStopPolygon, int CurrentStopPolygon, in out Array<TNavMeshRoute> Route, in out int RouteStep)
	{
		// Trivial case.
		if (LastStopPolygon == CurrentStopPolygon)
			return True;
		// Search the neighbors of the last polygon.
		int I = 0;
		int LineIndex = NavMeshPolygons[LastStopPolygon].LineFirst;
		while (I < NavMeshPolygons[LastStopPolygon].LineCount)
		{
			if (NavMeshLines[LineIndex].Portal == CurrentStopPolygon)
			{
				TNavMeshRoute NavRoute = New('TNavMeshRoute');
				NavRoute.Polygon = CurrentStopPolygon;
				NavRoute.LinePortal = LineIndex;
				NavRoute.Position.X = (NavMeshLines[LineIndex].X1 + NavMeshLines[LineIndex].X2) / 2;
				NavRoute.Position.Y = (NavMeshLines[LineIndex].Y1 + NavMeshLines[LineIndex].Y2) / 2;
				NavRoute.Position.Z = NavMeshPolygons[CurrentStopPolygon].HeightFloor;
				Route.Insert(0, NavRoute);
				RouteStep = RouteStep + 1;
				return True;
			}
			I++;
		}
		// A new route is needed.
		return False;
	}
	static TNavMesh Create()
	{
		TNavMesh NavMesh = New('TNavMesh');
		NavMesh.LineCount = 0;
		NavMesh.PolygonCount = 0;
		NavMesh.PolygonChain = null;
		return NavMesh;
	}
}

// -----------------------------------------------------------------------------
// NavMesh reader.
// -----------------------------------------------------------------------------

// Simple lexer for the NavMesh files.
class TNavMeshReader : TCustomNavMesh
{
	String SourceCode;
	int SourceCodeLength;
	int Position;
	bool EOF()
	{
		return Position >= SourceCodeLength;
	}
	bool IsWhitespace(int Ch)
	{
		return (Ch == 9) || (Ch == 10) || (Ch == 13) || (Ch == 32);
	}
	String GetNextToken()
	{
		String Result = "";
		int Ch;
		[Ch, Position] = SourceCode.GetNextCodePoint(Position);
		// Skip comments.
		if (Ch == "#")
		{
			do
			{
				[Ch, Position] = SourceCode.GetNextCodePoint(Position);
			}
			while ((!EOF()) && (IsWhitespace(Ch)));
		}
		// Skip whitespaces.
		while ((!EOF()) && (IsWhitespace(Ch)))
			[Ch, Position] = SourceCode.GetNextCodePoint(Position);
		while ((!EOF()) && (!IsWhitespace(Ch)))
		{
			Result.AppendCharacter(Ch);
			[Ch, Position] = SourceCode.GetNextCodePoint(Position);
		}
		return Result;
	}
	String PeekNextToken()
	{
		int SavedPosition = Position;
		String Result = GetNextToken();
		Position = SavedPosition;
		return Result;
	}
	bool Read(String MapName, TNavMesh NavMesh)
	{
		String LumpName = String.Format("NAVMESHES/%s.txt", MapName);
		int LumpNumber = Wads.CheckNumForFullName(LumpName);
		if (LumpNumber < 0)
			return False;
		SourceCode = Wads.ReadLump(LumpNumber);
		SourceCodeLength = SourceCode.CodePointCount();
		// Check the header.
		if (!(SourceCode.Mid(0, 14) ~== "# ZDOOMNAVMESH"))
			return False;
		// Parse the source code.
		Position = 14;
		int Ch;
		[Ch, Position] = SourceCode.GetNextCodePoint(Position);
		while ((EOF()) && (IsWhitespace(Ch)))
		{
			[Ch, Position] = SourceCode.GetNextCodePoint(Position);
		}
		int CurrentCell = 0;
		int CurrentCellIndex = 0;
		while (!EOF())
		{
			String Token = GetNextToken();
			// Line command.
			if (Token ~== "L")
			{
				if (NavMesh.NavMeshLines.Size() == NavMesh.LineCount)
					NavMesh.NavMeshLines.Reserve(1024);
				NavMesh.NavMeshLines[NavMesh.LineCount] = New('TNavMeshLine');
				NavMesh.NavMeshLines[NavMesh.LineCount].X1 = GetNextToken().ToInt();
				NavMesh.NavMeshLines[NavMesh.LineCount].Y1 = GetNextToken().ToInt();
				NavMesh.NavMeshLines[NavMesh.LineCount].X2 = GetNextToken().ToInt();
				NavMesh.NavMeshLines[NavMesh.LineCount].Y2 = GetNextToken().ToInt();
				NavMesh.NavMeshLines[NavMesh.LineCount].Portal = GetNextToken().ToInt();
				NavMesh.NavMeshLines[NavMesh.LineCount].MapLinedef = GetNextToken().ToInt();
				NavMesh.LineCount++;
			}
			// Polygon command.
			if (Token ~== "P")
			{
				if (NavMesh.NavMeshPolygons.Size() == NavMesh.PolygonCount)
					NavMesh.NavMeshPolygons.Reserve(1024);
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount] = New('TNavMeshPolygon');
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount].HeightFloor = GetNextToken().ToInt();
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount].HeightCeiling = GetNextToken().ToInt();
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount].LineFirst = GetNextToken().ToInt();
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount].LineCount = GetNextToken().ToInt();
				NavMesh.NavMeshPolygons[NavMesh.PolygonCount].MapSector = GetNextToken().ToInt();
				NavMesh.PolygonCount++;
			}
			// Cells origin and size command.
			if (Token ~== "O")
			{
				NavMesh.CellOffsetX = GetNextToken().ToInt();
				NavMesh.CellOffsetY = GetNextToken().ToInt();
				NavMesh.CellNumX = GetNextToken().ToInt();
				NavMesh.CellNumY = GetNextToken().ToInt();
			}
			// Cells space partitioning command.
			if (Token ~== "C")
			{
				int CellNumber = GetNextToken().ToInt();
				// Cells indexes management.
				while (CurrentCellIndex <= CellNumber)
				{
					NavMesh.CellsIndex.Push(CurrentCell);
					CurrentCellIndex++;
				}
				String NextToken = PeekNextToken().Left(1);
				while ((NextToken >= "0") && (NextToken <= "9"))
				{
					NavMesh.Cells.Push(GetNextToken().ToInt());
					CurrentCell++;
					NextToken = PeekNextToken().Left(1);
				}
			}
		}
		// Add last cell index.
		NavMesh.CellsIndex.Push(CurrentCell);
		// Build the node list.
		for (int I = 0; I < NavMesh.PolygonCount; I++)
		{
			TNavMeshNode NavMeshNode = New('TNavMeshNode');
			NavMeshNode.Initialize();
			NavMesh.NavNodes.Push(NavMeshNode);
		}
		return True;
	}
	static TNavMeshReader Create()
	{
		TNavMeshReader NavMeshReader = New('TNavMeshReader');
		return NavMeshReader;
	}
}

// -----------------------------------------------------------------------------
// NavMesh builder.
// -----------------------------------------------------------------------------

class TPolygons : TCustomNavMesh
{
	const MaxPoints = 8192;
	const MaxPolygons = 2048;
	enum TOrientation
	{
		Clockwise = -1,
		Collinear = 0,
		CounterClockwise = 1
	}
	int Points[MaxPoints];
	short PointCount;
	short PolygonCount;
	short PolygonsCount[MaxPolygons];
	short PolygonsFirst[MaxPolygons];
	void Clear()
	{
		PointCount = 0;
		PolygonCount = 0;
	}
	int GetPolygonCount()
	{
		return PolygonCount;
	}
	int GetPolygonPointCount(int PolygonNumber)
	{
		return PolygonsCount[PolygonNumber];
	}
	int GetPolygonPoint(int PolygonNumber, int Index)
	{
		return Points[PolygonsFirst[PolygonNumber] + Index];
	}
	int NewPolygon(int FirstPoint)
	{
		int Result = PolygonCount;
		Points[PointCount] = FirstPoint;
		PolygonsCount[Result] = 1;
		PolygonsFirst[Result] = Pointcount;
		PointCount++;
		PolygonCount++;
		return Result;
	}
	void NewPoint(int PolygonNumber, int Point, int Index = -1)
	{
		int PointIndex = PolygonsFirst[PolygonNumber];
		if (Index >= 0)
			PointIndex += Index;
		else
			PointIndex += PolygonsCount[PolygonNumber];
		// Shifts the subsequent points.
		for (int I = PointCount - 1; I > PointIndex; I--)
			Points[I + 1] = Points[I];
		Points[PointIndex] = Point;
		// Shifts the subsequent polygons starting points.
		for (int I = PolygonNumber + 1; I < PolygonCount; I++)
			PolygonsFirst[I] += 1;
		PolygonsCount[PolygonNumber] += 1;
		PointCount++;
	}
	int NewTriangle(int P1, int P2, int P3)
	{
		int Triangle = NewPolygon(P1);
		NewPoint(Triangle, P2);
		NewPoint(Triangle, P3);
		return Triangle;
	}
	void UpdatePoint(int PolygonNumber, int Index, int Point)
	{
		if (Index < PolygonsCount[PolygonNumber])
			Points[PolygonsFirst[PolygonNumber] + Index] = Point;
		if (Index == PolygonsCount[PolygonNumber])
			NewPoint(PolygonNumber, Point);
	}
	void DeletePoint(int PolygonNumber, int PointIndex)
	{
		// Shifts the subsequent points.
		PointCount--;
		for (int I = PolygonsFirst[PolygonNumber] + PointIndex; I < PointCount; I++)
			Points[I] = Points[I + 1];
		// Shifts the subsequent polygons starting points.
		for (int I = PolygonNumber + 1; I < PolygonCount; I++)
			PolygonsFirst[I] -= 1;
		PolygonsCount[PolygonNumber] -= 1;
		if (PolygonsCount[PolygonNumber] == 0)
		{
			// Delete the null polygon.
			PolygonCount--;
			for (int I = PolygonNumber; I < PolygonCount; I++)
			{
				PolygonsCount[I] = PolygonsCount[I + 1];
				PolygonsFirst[I] = PolygonsFirst[I + 1];
			}
		}
	}
	void DeletePolygon(int PolygonNumber)
	{
		int Count = PolygonsCount[PolygonNumber];
		DeletePoint(PolygonNumber, 0);
	}
	static int GetX(int VertexIndex)
	{
		return Level.Vertexes[VertexIndex].P.X;
	}
	static int GetY(int VertexIndex)
	{
		return Level.Vertexes[VertexIndex].P.Y;
	}
	TOrientation GetOrientation(int PolygonNumber)
	{
		int I, J;
		int FirstPoint = PolygonsFirst[PolygonNumber];
		double Area = 0;
		for (I = 0; I < PolygonsCount[PolygonNumber]; I++)
		{
			J = (I + 1) % PolygonsCount[PolygonNumber];
			Area += GetX(Points[FirstPoint + I]) * GetY(Points[FirstPoint + J]) - GetY(Points[FirstPoint + I]) * GetX(Points[FirstPoint + J]);
		}
		if (Area > 0)
			return CounterClockwise;
		if (Area < 0)
			return Clockwise;
		return Collinear;
	}
	void SetOrientation(int PolygonNumber, TOrientation Orientation)
	{
		int FirstPoint, LastPoint, Temp;
		TOrientation ActuralOrientation = GetOrientation(PolygonNumber);
		if ((ActuralOrientation != Collinear) && (ActuralOrientation != Orientation))
		{
			// Reverse the array.
			int FirstPoint = PolygonsFirst[PolygonNumber];
			int LastPoint = FirstPoint + PolygonsFirst[PolygonNumber] - 1;
			while (FirstPoint < LastPoint)
			{
				Temp = Points[FirstPoint];
				Points[FirstPoint] = Points[LastPoint];
				Points[LastPoint] = Temp;
				FirstPoint++;
				LastPoint--;
			}
		}
	}
	void SetHole(int PolygonNumber, bool Hole)
	{
		if (Hole)
			SetOrientation(PolygonNumber, Clockwise);
		else
			SetOrientation(PolygonNumber, CounterClockwise);
	}
	static TPolygons Create()
	{
		TPolygons Polygons = New('TPolygons');
		Polygons.Clear();
		return Polygons;
	}
}

class TNavMeshBuilder: TCustomNavMesh
{
	// Offset added to each coordinate, to have non-negative values.
	const GridOffset = 32768;
	// Settings of the NavMesh agents.
	int ActorHeight;
	int ActorWidth;
	// NavMesh being built.
	TNavMesh NavMesh;
	// Caches.
	TGridList GridLinedef;
	TGridList GridNavMeshLine;
	TPolygons InputPolygons;
	TPolygons OutputPolygons;
	TPolygons SectorPolygons;
	TPolygons Triangles;
	// ProcessMapData data.
	const MaxPlanes = 32;
	const MaxVertexes = 2048;
	int PlaneCeilings[MaxPlanes];
	int PlaneFloors[MaxPlanes];
	short PlaneCount;
	int PolyhedronCeilings[MaxPlanes];
	int PolyhedronFloors[MaxPlanes];
	short PolyhedronCount;
	int VertexBegin[MaxVertexes];
	int VertexEnd[MaxVertexes];
	short VertexCount;
	// ProcessSectors data.
	const StackLength = MaxPoints * 4;
	const MaxStack = 128;
	const MaxPoints = MaxVertexes * 2;
	const MaxPolygons = MaxVertexes;
	int Points[MaxPoints];
	short PointCount;
	short LinesA[MaxVertexes];
	short LinesB[MaxVertexes];
	short LineCount;
	short PointCardinality[MaxPoints];
	short PolygonDepthLevel[MaxPoints];
	bool OpenPoints[MaxPoints];
	bool OpenLines[MaxPoints];
	short PointQueue[MaxPoints];
	short PointQueueHead;
	short PointQueueTail;
	short MeshStackPoints[MaxStack * MaxPoints];
	short MeshStackCount[MaxStack];
	short MeshStackTOS;
	short OuterPerimeterPoints[MaxPoints];
	short OuterPerimeterPointCount, OuterPerimeterPointStart;
	short InnerChordPoints[MaxPoints];
	short InnerChordPointCount, InnerChordPointLoop;
	short OuterChordPoints[MaxPoints];
	short OuterChordPointCount, ChordBegin, ChordEnd;
	// ProcessSectors data.
	int PartitionPoint[MaxPoints];
	bool PartitionPointIsActive[MaxPoints];
	bool PartitionPointIsConvex[MaxPoints];
	bool PartitionPointIsEar[MaxPoints];
	float PartitionPointAngle[MaxPoints];
	short PartitionPointPrev[MaxPoints];
	short PartitionPointNext[MaxPoints];
	int NewPolygons[MaxPoints];
	// Helper function, that get the X coordinate of a vertex.
	static int GetX(int VertexIndex)
	{
		return Level.Vertexes[VertexIndex].P.X;
	}
	// Helper function, that get the X coordinate of a vertex.
	static int GetY(int VertexIndex)
	{
		return Level.Vertexes[VertexIndex].P.Y;
	}
	static bool IsConvex(int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y)
	{
		return (P3Y - P1Y) * (P2X - P1X) - (P3X - P1X) * (P2Y - P1Y) > 0;
	}
	static bool IsConvexPoint(int P1, int P2, int P3)
	{
		return (GetY(P3) - GetY(P1)) * (GetX(P2) - GetX(P1)) - (GetX(P3) - GetX(P1)) * (GetY(P2) - GetY(P1)) > 0;
	}
	static bool IsReflex(int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y)
	{
		return (P3Y - P1Y) * (P2X - P1X) - (P3X - P1X) * (P2Y - P1Y) < 0;
	}
	static bool IsReflexPoint(int P1, int P2, int P3)
	{
		return (GetY(P3) - GetY(P1)) * (GetX(P2) - GetX(P1)) - (GetX(P3) - GetX(P1)) * (GetY(P2) - GetY(P1)) < 0;
	}
	static bool IsInsidePoint(int P1, int P2, int P3, int Point)
	{
		if (IsConvexPoint(P1, Point, P2))
			return False;
		if (IsConvexPoint(P2, Point, P3))
			return False;
		if (IsConvexPoint(P3, Point, P1))
			return False;
		return True;
	}
	static bool InCone(int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y, int PointX, int PointY)
	{
		if (IsConvex(P1X, P1Y, P2X, P2Y, P3X, P3Y))
		{
			if (!IsConvex(P1X, P1Y, P2X, P2Y, PointX, PointY))
				return False;
			if (!IsConvex(P2X, P2Y, P3X, P3Y, PointX, PointY))
				return False;
			return True;
		}
		else
		{
			if (IsConvex(P1X, P1Y, P2X, P2Y, PointX, PointY))
				return True;
			if (IsConvex(P2X, P2Y, P3X, P3Y, PointX, PointY))
				return True;
			return False;
		}
	}
	static bool InConePoint(int P1, int P2, int P3, int Point)
	{
		if (IsConvexPoint(P1, P2, P3))
		{
			if (!IsConvexPoint(P1, P2, Point))
				return False;
			if (!IsConvexPoint(P2, P3, Point))
				return False;
			return True;
		}
		else
		{
			if (IsConvexPoint(P1, P2, Point))
				return True;
			if (IsConvexPoint(P2, P3, Point))
				return True;
			return False;
		}
	}
	static bool Intersects(int P11, int P12, int P21, int P22)
	{
		if ((GetX(P11) == GetX(P21)) && (GetY(P11) == GetY(P21)))
			return False;
		if ((GetX(P11) == GetX(P22)) && (GetY(P11) == GetY(P22)))
			return False;
		if ((GetX(P12) == GetX(P21)) && (GetY(P12) == GetY(P21)))
			return False;
		if ((GetX(P12) == GetX(P22)) && (GetY(P12) == GetY(P22)))
			return False;
		double V1OrtX = GetY(P12) - GetY(P11);
		double V1OrtY = GetX(P11) - GetX(P12);
		double V2OrtX = GetY(P22) - GetY(P21);
		double V2OrtY = GetX(P21) - GetX(P22);
		double Dot21 = (GetX(P21) - GetX(P11)) * V1OrtX + (GetY(P21) - GetY(P11)) * V1OrtY;
		double Dot22 = (GetX(P22) - GetX(P11)) * V1OrtX + (GetY(P22) - GetY(P11)) * V1OrtY;
		double Dot11 = (GetX(P11) - GetX(P21)) * V2OrtX + (GetY(P11) - GetY(P21)) * V2OrtY;
		double Dot12 = (GetX(P12) - GetX(P21)) * V2OrtX + (GetY(P12) - GetY(P21)) * V2OrtY;
		if (Dot11 * Dot12 > 0)
			return False;
		if (Dot21 * Dot22 > 0)
			return False;
		return True;
	}
	static Vector2 VectorDifference(int V1, int V2)
	{
		Vector2 Result = Level.Vertexes[V1].P - Level.Vertexes[V2].P;
		return Result.Unit();
	}
	void UpdatePartitionPoint(int NumVertices, int PartitionPointIndex)
	{
		int PrevIndex = PartitionPointPrev[PartitionPointIndex];
		int NextIndex = PartitionPointNext[PartitionPointIndex];
		int This = PartitionPoint[PartitionPointIndex];
		int Prev = PartitionPoint[PrevIndex];
		int Next = PartitionPoint[NextIndex];
		PartitionPointIsConvex[PartitionPointIndex] = IsConvexPoint(Prev, This, Next);
		PartitionPointAngle[PartitionPointIndex] = VectorDifference(Prev, This) dot VectorDifference(Next, This);
		if (PartitionPointIsConvex[PartitionPointIndex])
		{
			PartitionPointIsEar[PartitionPointIndex] = True;
			for (int I = 0; I < NumVertices; I++)
			{
				if ((GetX(PartitionPoint[I]) == GetX(This)) && (GetY(PartitionPoint[I]) == GetY(This)))
					continue;
				if ((GetX(PartitionPoint[I]) == GetX(Prev)) && (GetY(PartitionPoint[I]) == GetY(Prev)))
					continue;
				if ((GetX(PartitionPoint[I]) == GetX(Next)) && (GetY(PartitionPoint[I]) == GetY(Next)))
					continue;
				if (IsInsidePoint(Prev, This, Next, PartitionPoint[I]))
				{
					PartitionPointIsEar[PartitionPointIndex] = False;
					break;
				}
			}
		}
		else
			PartitionPointIsEar[PartitionPointIndex];
	}
// -----------------------------------------------------------------------------
// RemoveHoles
// -----------------------------------------------------------------------------
// Function RemoveHoles is a simple heuristic procedure for removing holes from a list of polygons.
// It works by creating a diagonal from the right-most hole  to some other visible vertex.
// Vertices of all non-hole polys have to be in counter-clockwise order.
// Vertices of all hole polys have to be in clockwise order.
// Returns True if the process is successful.
// -----------------------------------------------------------------------------
	bool RemoveHoles()
	{
		int CurrentPolygon;
		// Check for the trivial case of no holes.
		if (InputPolygons.GetPolygonCount() == 1)
			return True;
		while (InputPolygons.GetPolygonCount() > 1)
		{
			// Find the hole point with the largest X.
			int SelectedHole = 1;
			int HolePointIndex = 0;
			int PolyPointIndex = 0;
			for (int J = 1; J < InputPolygons.GetPolygonCount(); J++)
			{
				for (int I = 0; I < InputPolygons.GetPolygonPointCount(J); I++)
				{
					if (GetX(InputPolygons.GetPolygonPoint(J, I)) > GetX(InputPolygons.GetPolygonPoint(SelectedHole, HolePointIndex)))
					{
						SelectedHole = J;
						HolePointIndex = I;
					}
				}
			}
			int HolePoint = InputPolygons.GetPolygonPoint(SelectedHole, HolePointIndex);
			bool PointFound = False;
			int BestPolyPoint = InputPolygons.GetPolygonPoint(0, 0);
			for (int I = 0; I < InputPolygons.GetPolygonPointCount(0); I++)
			{
				if (GetX(InputPolygons.GetPolygonPoint(0, I)) <= GetX(HolePoint))
					continue;
				if (!InConePoint(
					InputPolygons.GetPolygonPoint(0, (I + InputPolygons.GetPolygonPointCount(0) - 1) % InputPolygons.GetPolygonPointCount(0)),
					InputPolygons.GetPolygonPoint(0, I),
					InputPolygons.GetPolygonPoint(0, (I + 1) % (InputPolygons.GetPolygonPointCount(0))),
					HolePoint))
				continue;
				int PolyPoint = InputPolygons.GetPolygonPoint(0, I);
				if (PointFound)
				{
					Vector2 V1 = VectorDifference(PolyPoint, HolePoint).Unit();
					Vector2 V2 = VectorDifference(BestPolyPoint, HolePoint).Unit();
					if (V2.X > V1.X)
						continue;
				}
				bool PointVisible = True;
				for (int J = 0; J < InputPolygons.GetPolygonPointCount(0); J++)
				{
					int LineP1 = InputPolygons.GetPolygonPoint(0, J);
					int LineP2 = InputPolygons.GetPolygonPoint(0, (J + 1) % (InputPolygons.GetPolygonPointCount(0)));
					if (Intersects(HolePoint, PolyPoint, LineP1, LineP2))
					{
						PointVisible = False;
						break;
					}
				}
				if (PointVisible)
				{
					PointFound = True;
					BestPolyPoint = PolyPoint;
					PolyPointIndex = I;
				}
			}
			if (!PointFound)
				return False;
			for (int I = 0; I <= InputPolygons.GetPolygonPointCount(SelectedHole); I++)
				InputPolygons.NewPoint(0, InputPolygons.GetPolygonPoint(SelectedHole, (I + HolePointIndex) % InputPolygons.GetPolygonPointCount(SelectedHole)), PolyPointIndex + I + 1);
			InputPolygons.NewPoint(0, InputPolygons.GetPolygonPoint(0, PolyPointIndex), PolyPointIndex + InputPolygons.GetPolygonPointCount(SelectedHole) + 2);
			InputPolygons.DeletePolygon(SelectedHole);
		}
		return True;
	}
// -----------------------------------------------------------------------------
// Triangulate_EC
// -----------------------------------------------------------------------------
// Function Triangulate_EC triangulates a polygon by ear clipping.
// Returns True if the process is successful.
// -----------------------------------------------------------------------------
	bool Triangulate_EC()
	{
		int NumVertices = InputPolygons.GetPolygonPointCount(0);
		if (NumVertices < 3)
			return False;
		// Check if the poly is already a triangle.
		if (NumVertices == 3)
		{
			Triangles.NewTriangle(
				InputPolygons.GetPolygonPoint(0, 0),
				InputPolygons.GetPolygonPoint(0, 1),
				InputPolygons.GetPolygonPoint(0, 2)
			);
			return True;
		}
		for (int I = 0; I < NumVertices; I++)
		{
			PartitionPoint[I] = InputPolygons.GetPolygonPoint(0, I);
			PartitionPointIsActive[I] = True;
			PartitionPointIsConvex[I] = False;
			PartitionPointIsEar[I] = False;
			PartitionPointAngle[I] = 0;
			PartitionPointPrev[I] = (I + NumVertices - 1) % NumVertices;
			PartitionPointNext[I] = (I + 1) % NumVertices;
		}
		for (int I = 0; I < NumVertices; I++)
			UpdatePartitionPoint(NumVertices, I);
		int EarIndex = 0;
		for (int I = 0; I < NumVertices - 3; I++)
		{
			bool EarFound = False;
			// Search the most extruded ear.
			for (int J = 0; J < NumVertices; J++)
			{
				if (!PartitionPointIsActive[J])
					continue;
				if (!PartitionPointIsEar[J])
					continue;
				if (!EarFound)
				{
					EarFound = True;
					EarIndex = J;
				}
				else
				{
					if (PartitionPointAngle[J] > PartitionPointAngle[EarIndex])
						EarIndex = J;
				}
			}
			if (!EarFound)
				return False;
			int Triangle = Triangles.NewTriangle(
				PartitionPoint[PartitionPointPrev[EarIndex]],
				PartitionPoint[EarIndex],
				PartitionPoint[PartitionPointNext[EarIndex]]
			);
			PartitionPointIsEar[EarIndex] = False;
			PartitionPointNext[PartitionPointPrev[EarIndex]] = PartitionPointNext[EarIndex];
			PartitionPointPrev[PartitionPointNext[EarIndex]] = PartitionPointPrev[EarIndex];
			if (I == (NumVertices - 4))
				break;
			UpdatePartitionPoint(NumVertices, PartitionPointPrev[EarIndex]);
			UpdatePartitionPoint(NumVertices, PartitionPointNext[EarIndex]);
		}
		for (int I = 0; I < NumVertices; I++)
			if (PartitionPointIsActive[I])
			{
				int Triangle = Triangles.NewTriangle(
					PartitionPoint[PartitionPointPrev[I]],
					PartitionPoint[I],
					PartitionPoint[PartitionPointNext[I]]
				);
				break;
			}
		return True;
	}
// -----------------------------------------------------------------------------
// ConvexPartition_HM
// -----------------------------------------------------------------------------
// Function ConvexPartition_HM partitions a polygon into convex polygons by using the
// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm,
// however, in practice it works much better than that and often gives optimal partition.
// It uses triangulation obtained by ear clipping as intermediate result.
// Returns True if the process is successful.
// -----------------------------------------------------------------------------
	bool ConvexPartition_HM()
	{
		int NumVertices = InputPolygons.GetPolygonPointCount(0);
		if (NumVertices < 3)
			return False;
		int I11, I12, I21 = 0, I22 = 0, I13, I23;
		// Check if the poly is already convex.
		int NumReflex = 0;
		for (I11 = 0; I11 < NumVertices; I11++)
		{
			I12 = (I11 + NumVertices - 1) % NumVertices;
			I13 = (I11 + 1) % NumVertices;
			if (IsReflexPoint(InputPolygons.GetPolygonPoint(0, I12), InputPolygons.GetPolygonPoint(0, I11), InputPolygons.GetPolygonPoint(0, I13)))
			{
				NumReflex = 1;
				break;
			}
		}
		if (NumReflex == 0)
		{
			int CurrentPolygon = OutputPolygons.NewPolygon(InputPolygons.GetPolygonPoint(0, 0));
			for (int I = 1; I < NumVertices; I++)
				OutputPolygons.NewPoint(CurrentPolygon, InputPolygons.GetPolygonPoint(0, I));
			return True;
		}
		if (!Triangulate_EC())
			return False;
		int Polygon1 = 0;
		int Polygon2 = 0;
		int TriangleIndex1 = 0;
		int TriangleIndex2 = 0;
		while (TriangleIndex1 < Triangles.GetPolygonCount())
		{
			Polygon1 = TriangleIndex1;
			I11 = 0;
			while (I11 < Triangles.GetPolygonPointCount(Polygon1))
			{
				int D1 = Triangles.GetPolygonPoint(Polygon1, I11);
				I12 = (I11 + 1) % (Triangles.GetPolygonPointCount(Polygon1));
				int D2 = Triangles.GetPolygonPoint(Polygon1, I12);
				bool IsDiagonal = False;
				TriangleIndex2 = TriangleIndex1;
				while (TriangleIndex2 < Triangles.GetPolygonCount())
				{
					if (TriangleIndex1 != TriangleIndex2)
					{
						Polygon2 = TriangleIndex2;
						for (I21 = 0; I21 < Triangles.GetPolygonPointCount(Polygon2); I21++)
						{
							if ((GetX(D2) != GetX(Triangles.GetPolygonPoint(Polygon2, I21))) || (GetY(D2) != GetY(Triangles.GetPolygonPoint(Polygon2, I21))))
								continue;
							I22 = (I21 + 1) % (Triangles.GetPolygonPointCount(Polygon2));
							if ((GetX(D1) != GetX(Triangles.GetPolygonPoint(Polygon2, I22))) || (GetY(D1) != GetY(Triangles.GetPolygonPoint(Polygon2, I22))))
								continue;
							IsDiagonal = True;
							break;
						}
						if (IsDiagonal)
							break;
					}
					TriangleIndex2++;
				}
				if (!IsDiagonal)
				{
					I11++;
					continue;
				}
				int P2 = Triangles.GetPolygonPoint(Polygon1, I11);
				if (I11 == 0)
					I13 = Triangles.GetPolygonPointCount(Polygon1) - 1;
				else
					I13 = I11 - 1;
				int P1 = Triangles.GetPolygonPoint(Polygon1, I13);
				if (I22 == (Triangles.GetPolygonPointCount(Polygon2) - 1))
					I23 = 0;
				else
					I23 = I22 + 1;
				int P3 = Triangles.GetPolygonPoint(Polygon2, I23);
				if (!IsConvexPoint(P1, P2, P3))
				{
					I11++;
					continue;
				}
				P2 = Triangles.GetPolygonPoint(Polygon1, I12);
				if (I12 == (Triangles.GetPolygonPointCount(Polygon1) - 1))
					I13 = 0;
				else
					I13 = I12 + 1;
				P3 = Triangles.GetPolygonPoint(Polygon1, I13);
				if (I21 == 0)
					I23 = Triangles.GetPolygonPointCount(Polygon2) - 1;
				else
					I23 = I21 - 1;
				P1 = Triangles.GetPolygonPoint(Polygon2, I23);
				if (!IsConvexPoint(P1, P2, P3))
				{
					I11++;
					continue;
				}
				int NewPolygonCount = 0;
				for (int J = I12; J != I11; J = (J + 1) % (Triangles.GetPolygonPointCount(Polygon1)))
				{
					NewPolygons[NewPolygonCount] = Triangles.GetPolygonPoint(Polygon1, J);
					NewPolygonCount++;
				}
				for (int J = I22; J != I21; J = (J + 1) % (Triangles.GetPolygonPointCount(Polygon2)))
				{
					NewPolygons[NewPolygonCount] = Triangles.GetPolygonPoint(Polygon2, J);
					NewPolygonCount++;
				}
				Triangles.DeletePolygon(TriangleIndex2);
				for (int J = 0; J < NewPolygonCount; J++)
					Triangles.UpdatePoint(TriangleIndex1, J, NewPolygons[J]);
				Polygon1 = TriangleIndex1;
				I11 = 0;
			}
			TriangleIndex1++;
		}
		for (int I = 0; I < Triangles.GetPolygonCount(); I++)
		{
			int CurrentPolygon = OutputPolygons.NewPolygon(Triangles.GetPolygonPoint(I, 0));
			for (int J = 1; J < Triangles.GetPolygonPointCount(I); J++)
				OutputPolygons.NewPoint(CurrentPolygon, Triangles.GetPolygonPoint(I, J));
		}
		return True;
	}
// -----------------------------------------------------------------------------
// PointInsidePolygon
// -----------------------------------------------------------------------------
// Function PointInsidePolygon checks if a point is contained in a polygon.
// The polygon doesn't need to be convex.
// -----------------------------------------------------------------------------
	bool PointInsidePolygon(int Polygon, int Point)
	{
		if (SectorPolygons.GetPolygonPointCount(Polygon) < 3)
			return False;
		bool Result = False;
		int I;
		int P1 = SectorPolygons.GetPolygonPoint(Polygon, 0);
		int P2;
		for (I = 0; I < SectorPolygons.GetPolygonPointCount(Polygon); I++)
		{
			P2 = SectorPolygons.GetPolygonPoint(Polygon, (I + 1) % SectorPolygons.GetPolygonPointCount(Polygon));
			if ((GetY(Point) > Min(GetY(P1), GetY(P2)))
			&& (GetY(Point) <= Max(GetY(P1), GetY(P2)))
			&& (GetX(Point) <= Max(GetX(P1), GetX(P2)))
			&& ((GetX(P1) == GetX(P2)) || (GetX(Point) <= ((GetY(Point) - GetY(P1)) * (GetX(P2) - GetX(P1)) / (GetY(P2) - GetY(P1)) + GetX(P1)))))
				Result = !Result;
			P1 = P2;
		}
		return Result;
	}
// -----------------------------------------------------------------------------
// PolygonInsidePolygon
// -----------------------------------------------------------------------------
// Function PolygonInsidePolygon checks if a polygon fits inside another one.
// This function simply checks the first two point of the tested polygon
// against the other one.
// -----------------------------------------------------------------------------
	bool PolygonInsidePolygon(int OuterPolygon, int TestPoligon)
	{
		if ((SectorPolygons.GetPolygonPointCount(OuterPolygon) < 3) || (SectorPolygons.GetPolygonPointCount(TestPoligon) < 3))
			return False;
		else
			return (PointInsidePolygon(OuterPolygon, SectorPolygons.GetPolygonPoint(TestPoligon, 0))) && (PointInsidePolygon(OuterPolygon, SectorPolygons.GetPolygonPoint(TestPoligon, 1)));
	}
// -----------------------------------------------------------------------------
// GetGridExtent
// -----------------------------------------------------------------------------
// Function GetGridExtent gets the bounding box of a line.
// -----------------------------------------------------------------------------
	void GetGridExtent(int X1, int Y1, int X2, int Y2, out int MinX, out int MaxX, out int MinY, out int MaxY)
	{
		if (X1 > X2)
		{
			MaxX = X1;
			MinX = X2;
		}
		else
		{
			MaxX = X2;
			MinX = X1;
		}
		if (Y2 > Y1)
		{
			MaxY = Y2;
			MinY = Y1;
		}
		else
		{
			MaxY = Y1;
			MinY = Y2;
		}
		MinX = (MinX + GridOffset) >> 8;
		MaxX = (MaxX + GridOffset) >> 8;
		MinY = (MinY + GridOffset) >> 8;
		MaxY = (MaxY + GridOffset) >> 8;
	}
// -----------------------------------------------------------------------------
// PreProcessMapData
// -----------------------------------------------------------------------------
// Function PreProcessMapData caches the map's linedef into GridLinedef.
// -----------------------------------------------------------------------------
	void PreProcessMapData()
	{
		int MinX, MaxX, MinY, MaxY, I, X, Y;
		for (I = 0; I < Level.Lines.Size(); I++)
		{
			GetGridExtent(Level.Lines[I].V1.P.X, Level.Lines[I].V1.P.Y, Level.Lines[I].V2.P.X, Level.Lines[I].V2.P.Y, MinX, MaxX, MinY, MaxY);
			GridLinedef.AddGrids(MinX, MinY, MaxX, MaxY, Level.Lines[I].Index());
		}
	}
// -----------------------------------------------------------------------------
// ProcessPolygons
// -----------------------------------------------------------------------------
// Function ProcessPolygons decomposes "multipolygons" into convex polygons.
// Get the polygons from InputPolygons and decomposes them into OutputPolygons.
// -----------------------------------------------------------------------------
	void ProcessPolygons(int SectorNumber)
	{
		int CurrentNavMeshLine = NavMesh.LineCount;
		int CurrentNavMeshPolygon = NavMesh.PolygonCount;
		int I, Index, LineBegin, LineEnd, Polygon, MinX, MaxX, MinY, MaxY;
		int PolyhedronIndex, CurrentPolygonIndex, CurrentPolygonStartLine, NextPolygonStart;
		bool NotFound, LineIsPortal, PolygonNotFound;
		Vertex V1, V2;
		Line MapLinedef;
		TNavMeshLine NavMeshLine;
		TNavMeshPolygon NavMeshPolygon;
		if (RemoveHoles())
		{
			Triangles.Clear();
			OutputPolygons.Clear();
			if (ConvexPartition_HM())
			{
				for (Polygon = 0; Polygon < OutputPolygons.GetPolygonCount(); Polygon++)
				{
					for (PolyhedronIndex = 0; PolyhedronIndex < PolyhedronCount; PolyhedronIndex++)
					{
						NavMeshPolygon = New('TNavMeshPolygon');
						NavMeshPolygon.HeightFloor = PolyhedronFloors[PolyhedronIndex];
						NavMeshPolygon.HeightCeiling = PolyhedronCeilings[PolyhedronIndex];
						NavMeshPolygon.LineFirst = CurrentNavMeshLine;
						NavMeshPolygon.LineCount = OutputPolygons.GetPolygonPointCount(Polygon);
						NavMesh.PolygonChain.Add(SectorNumber, NavMesh.PolygonCount);
						if (NavMesh.PolygonCount == NavMesh.NavMeshPolygons.Size())
							NavMesh.NavMeshPolygons.Reserve(1024);
						NavMesh.NavMeshPolygons[NavMesh.PolygonCount] = NavMeshPolygon;
						NavMesh.PolygonCount++;
						for (LineBegin = 0; LineBegin < NavMeshPolygon.LineCount; LineBegin++)
						{
							LineEnd = (LineBegin + 1) % OutputPolygons.GetPolygonPointCount(Polygon);
							NavMeshLine = New('TNavMeshLine');
							NavMeshLine.X1 = GetX(OutputPolygons.GetPolygonPoint(Polygon, LineBegin));
							NavMeshLine.Y1 = GetY(OutputPolygons.GetPolygonPoint(Polygon, LineBegin));
							NavMeshLine.X2 = GetX(OutputPolygons.GetPolygonPoint(Polygon, LineEnd));
							NavMeshLine.Y2 = GetY(OutputPolygons.GetPolygonPoint(Polygon, LineEnd));
							NavMeshLine.MapLinedef = -1;
							NavMeshLine.Portal = -1;
							GetGridExtent(NavMeshLine.X1, NavMeshLine.Y1, NavMeshLine.X2, NavMeshLine.Y2, MinX, MaxX, MinY, MaxY);
							GridLinedef.ClearSearchResult();
							GridLinedef.SearchGrid(MinX, MaxX, MinY, MaxY);
							NotFound = True;
							I = 0;
							while ((NotFound) && (I < GridLinedef.SearchResultCount))
							{
								V1 = Level.Lines[GridLinedef.SearchResults[I]].V1;
								V2 = Level.Lines[GridLinedef.SearchResults[I]].V2;
								if (((NavMeshLine.X1 == V1.P.X) && (NavMeshLine.Y1 == V1.P.Y) && (NavMeshLine.X2 == V2.P.X) && (NavMeshLine.Y2 == V2.P.Y))
								|| ((NavMeshLine.X1 == V2.P.X) && (NavMeshLine.Y1 == V2.P.Y) && (NavMeshLine.X2 == V1.P.X) && (NavMeshLine.Y2 == V1.P.Y)))
									NotFound = False;
								else
									I++;
							}
							if (!NotFound)
								NavMeshLine.MapLinedef = GridLinedef.SearchResults[I];
							// Check for portals.
							GridNavMeshLine.ClearSearchResult();
							GridNavMeshLine.SearchGrid(MinX, MaxX, MinY, MaxY);
							for (Index = GridNavMeshLine.SearchResultCount - 1; Index >= 0; Index--)
							{
								I = GridNavMeshLine.SearchResults[Index];
								CurrentPolygonIndex = 0;
								CurrentPolygonStartLine = 0;
								PolygonNotFound = True;
								do
								{
									NextPolygonStart = CurrentPolygonStartLine + NavMesh.NavMeshPolygons[CurrentPolygonIndex].LineCount;
									if (NextPolygonStart > I)
										PolygonNotFound = False;
									else
									{
										CurrentPolygonStartLine = NextPolygonStart;
										CurrentPolygonIndex++;
									}
								} while ((PolygonNotFound) && (CurrentPolygonIndex < (NavMesh.PolygonCount - 1)));
								if (((NavMeshLine.X1 == NavMesh.NavMeshLines[I].X1) && (NavMeshLine.Y1 == NavMesh.NavMeshLines[I].Y1) && (NavMeshLine.X2 == NavMesh.NavMeshLines[I].X2) && (NavMeshLine.Y2 == NavMesh.NavMeshLines[I].Y2))
								|| ((NavMeshLine.X1 == NavMesh.NavMeshLines[I].X2) && (NavMeshLine.Y1 == NavMesh.NavMeshLines[I].Y2) && (NavMeshLine.X2 == NavMesh.NavMeshLines[I].X1) && (NavMeshLine.Y2 == NavMesh.NavMeshLines[I].Y1)))
								{
									LineIsPortal = True;
									// Check if the two floor heights are too different.
									if (Abs(NavMeshPolygon.HeightFloor - NavMesh.NavMeshPolygons[CurrentPolygonIndex].HeightFloor) > 24)
										LineIsPortal = False;
									// Check if there is enough vertical space between the two connecting sectors.
									if (Min(NavMeshPolygon.HeightCeiling, NavMesh.NavMeshPolygons[CurrentPolygonIndex].HeightCeiling) - Max(NavMeshPolygon.HeightFloor, NavMesh.NavMeshPolygons[CurrentPolygonIndex].HeightFloor) < ActorHeight)
										LineIsPortal = False;
									if (NavMeshLine.MapLinedef >= 0)
									{
										// Check if the LINEDEF blocks monsters.
										MapLinedef = Level.Lines[NavMeshLine.MapLinedef];
										if ((MapLinedef.Flags & Line.ML_BLOCKING)
										|| (MapLinedef.Flags & Line.ML_BLOCKMONSTERS)
										|| (!MapLinedef.FrontSector)
										|| (!MapLinedef.BackSector))
											LineIsPortal = False;
									}
									if (LineIsPortal)
									{
										NavMeshLine.Portal = CurrentPolygonIndex;
										NavMesh.NavMeshLines[I].Portal = NavMesh.PolygonCount;
									}
								}
							}
							GridNavMeshLine.AddGrids(MinY, MinY, MaxX, MaxY, NavMesh.LineCount);
							if (NavMesh.LineCount == NavMesh.NavMeshLines.Size())
								NavMesh.NavMeshLines.Reserve(1024);
							NavMesh.NavMeshLines[NavMesh.LineCount] = NavMeshLine;
							NavMesh.LineCount++;
						}
						// Update the NavMesh nodes.
						if (NavMesh.NavMeshPolygons.Size() > NavMesh.NavNodes.Size())
							NavMesh.NavNodes.Reserve(1024);
						TNavMeshNode NavMeshNode = New('TNavMeshNode');
						NavMeshNode.Initialize();
						NavMesh.NavNodes[NavMesh.PolygonCount - 1] = NavMeshNode;
					}
				}
			}
		}
	}
// -----------------------------------------------------------------------------
// ProcessSector
// -----------------------------------------------------------------------------
// Function ProcessSector decomposes a sector into "multipolygons".
// Fills the SectorPolygons and InputPolygons objects.
// -----------------------------------------------------------------------------
	bool ProcessSector(int SectorNumber)
	{
		int I, J, K, CurrentPolygon, CurrentPoint, FirstPoint, NextPoint, OtherPoint, PreviousPoint, TestPoint;
		int NextLine = 0, InfiniteLoopLine = -1;
		int NextDifference, TestDifference;
		double NextAngle, PreviousAngle, TestAngle;
		bool NotFound, HasMoreIterations, AllPointsVisited;
		// Fills the Points and Lines arrays.
		PointCount = 0;
		LineCount = 0;
		for (I = 0; I < VertexCount; I++)
		{
			NotFound = True;
			J = 0;
			while ((NotFound) && (J < PointCount))
				if (Points[J] == VertexBegin[I])
					NotFound = False;
				else
					J++;
			if (NotFound)
			{
				Points[PointCount] = VertexBegin[I];
				LinesA[LineCount] = PointCount;
				PointCount++;
			}
			else
				LinesA[LineCount] = J;
			NotFound = True;
			J = 0;
			while ((NotFound) && (J < PointCount))
				if (Points[J] == VertexEnd[I])
					NotFound = False;
				else
					J++;
			if (NotFound)
			{
				Points[PointCount] = VertexEnd[I];
				LinesB[LineCount] = PointCount;
				PointCount++;
			}
			else
				LinesB[LineCount] = J;
			LineCount++;
		}
		// Initialization.
		for (I = 0; I < PointCount; I++)
			OpenPoints[I] = True;
		for (I = 0; I < LineCount; I++)
			OpenLines[I] = True;
		SectorPolygons.Clear();
		// Polygon splitting loop.
		do
		{
			// Find the left-most and bottom-most open point.
			FirstPoint = -1;
			for (I = 0; I < PointCount; I++)
			{
				if (OpenPoints[I])
				{
					if (FirstPoint < 0)
						FirstPoint = I;
					else
						if ((GetX(Points[I]) < GetX(Points[FirstPoint])) || ((GetX(Points[I]) == GetX(Points[FirstPoint])) && (GetY(Points[I]) < GetY(Points[FirstPoint]))))
							FirstPoint = I;
				}
			}
			PointQueue[0] = FirstPoint;
			PointQueueHead = 0;
			PointQueueTail = 1;
			// Walk through all lines from the first point.
			while (PointQueueTail > PointQueueHead)
			{
				CurrentPoint = PointQueue[PointQueueTail - 1];
				if (PointQueueTail == 1)
				{
					// Search the second point.
					NextDifference = 0;
					NextPoint = -1;
					for (I = 0; I < LineCount; I++)
					{
						if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
						{
							if (LinesA[I] == CurrentPoint)
								TestPoint = LinesB[I];
							else
								TestPoint = LinesA[I];
							TestDifference = GetY(Points[TestPoint]) - GetY(Points[CurrentPoint]);
							if (NextPoint < 0)
							{
								NextPoint = TestPoint;
								NextDifference = TestDifference;
								NextLine = I;
							}
							else
							{
								if (TestDifference < NextDifference)
								{
									NextPoint = TestPoint;
									NextDifference = TestDifference;
									NextLine = I;
								}
							}
						}
					}
				}
				else
				{
					PreviousPoint = PointQueue[PointQueueTail - 2];
					PreviousAngle = Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
					// Search the next points.
					NextPoint = -1;
					NextAngle = 0;
					for (I = 0; I < LineCount; I++)
					{
						if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
						{
							if (LinesA[I] == CurrentPoint)
								TestPoint = LinesB[I];
							else
								TestPoint = LinesA[I];
							if (TestPoint != PreviousPoint)
							{
								TestAngle = Atan2(GetY(Points[TestPoint]) - GetY(Points[CurrentPoint]), GetX(Points[TestPoint]) - GetX(Points[CurrentPoint])) - PreviousAngle;
								if (TestAngle < -M_PI)
									TestAngle += M_PI * 2;
								if (NextPoint < 0)
								{
									NextPoint = TestPoint;
									NextAngle = TestAngle;
									NextLine = I;
								}
								else
								{
									if (TestAngle < NextAngle)
									{
										NextPoint = TestPoint;
										NextAngle = TestAngle;
										NextLine = I;
									}
								}
							}
						}
					}
				}
				if (NextPoint >= 0)
				{
					NotFound = True;
					OuterPerimeterPointStart = PointQueueHead;
					while ((NotFound) && (OuterPerimeterPointStart < PointQueueTail))
						if (PointQueue[OuterPerimeterPointStart] == NextPoint)
							NotFound = False;
						else
							OuterPerimeterPointStart++;
					if (NotFound)
					{
						PointQueue[PointQueueTail] = NextPoint;
						PointQueueTail++;
					}
					else
					{
						OuterPerimeterPointCount = 0;
						for (I = OuterPerimeterPointStart; I < PointQueueTail; I++)
						{
							OuterPerimeterPoints[OuterPerimeterPointCount] = PointQueue[I];
							OuterPerimeterPointCount++;
						}
						// Push the outer perimeter on the stack.
						MeshStackTOS = 0;
						MeshStackCount[MeshStackTOS] = OuterPerimeterPointCount;
						for (I = 0; I < OuterPerimeterPointCount; I++)
							MeshStackPoints[MeshStackTos * StackLength + I] = OuterPerimeterPoints[I];
						while (MeshStackTOS >= 0)
						{
							// Calculate the point cardinality.
							for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
								PointCardinality[I] = 2; // The default previous and next lines attached to each point.
							for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
							{
								CurrentPoint = MeshStackPoints[MeshStackTos * StackLength + I];
								NextPoint = MeshStackPoints[MeshStackTos * StackLength + (I + 1) % MeshStackCount[MeshStackTOS]];
								PreviousPoint = MeshStackPoints[MeshStackTos * StackLength + (I + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
								for (J = 0; J < LineCount; J++)
								{
									if (((LinesA[J] == CurrentPoint) && (LinesB[J] != NextPoint) && (LinesB[J] != PreviousPoint)) || ((LinesB[J] == CurrentPoint) && (LinesA[J] != NextPoint) && (LinesA[J] != PreviousPoint)))
									{
										if (LinesA[J] == CurrentPoint)
											TestPoint = LinesB[J];
										else
											TestPoint = LinesA[J];
										if (InCone(GetX(Points[PreviousPoint]), GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]), GetY(Points[CurrentPoint]), GetX(Points[NextPoint]), GetY(Points[NextPoint]), GetX(Points[TestPoint]), GetY(Points[TestPoint])))
											PointCardinality[I]++;
									}
								}
							}
							// Search the left-most and bottom-most point of cardinality greather than 2, if exists.
							InnerChordPointLoop = -1;
							FirstPoint = -1;
							for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
							{
								if (PointCardinality[I] > 2)
								{
									TestPoint = MeshStackPoints[MeshStackTos * StackLength + I];
									if (FirstPoint < 0)
									{
										FirstPoint = TestPoint;
									}
									else
									{
										if ((GetX(Points[TestPoint]) < GetX(Points[FirstPoint])) || ((GetX(Points[TestPoint]) == GetX(Points[FirstPoint])) && (GetY(Points[TestPoint]) < GetY(Points[FirstPoint]))))
											FirstPoint = TestPoint;
									}
								}
							}
							if (FirstPoint >= 0)
							{
								InnerChordPoints[0] = FirstPoint;
								InnerChordPointCount = 1;
								HasMoreIterations = True;
								while (HasMoreIterations)
								{
									CurrentPoint = InnerChordPoints[InnerChordPointCount - 1];
									if (InnerChordPointCount == 1)
									{
										NotFound = True;
										I = 0;
										while ((NotFound) && (I < MeshStackCount[MeshStackTOS]))
											if (MeshStackPoints[MeshStackTos * StackLength + I] == FirstPoint)
												NotFound = False;
											else
												I++;
										OtherPoint = MeshStackPoints[MeshStackTos * StackLength + (I + 1) % MeshStackCount[MeshStackTOS]];
										PreviousPoint = MeshStackPoints[MeshStackTos * StackLength + (I + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
										PreviousAngle = Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
										NextAngle = Atan2(GetY(Points[OtherPoint]) - GetY(Points[CurrentPoint]), GetX(Points[OtherPoint]) - GetX(Points[CurrentPoint]));
										NextPoint = -1;
										for (I = 0; I < LineCount; I++)
										{
											if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
											{
												if (LinesA[I] == CurrentPoint)
													TestPoint = LinesB[I];
												else
													TestPoint = LinesA[I];
												if ((TestPoint != PreviousPoint) && (TestPoint != OtherPoint) && (InCone(GetX(Points[PreviousPoint]), GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]), GetY(Points[CurrentPoint]), GetX(Points[OtherPoint]), GetY(Points[OtherPoint]), GetX(Points[TestPoint]), GetY(Points[TestPoint]))))
												{
													TestAngle = Atan2(GetY(Points[TestPoint]) - GetY(Points[FirstPoint]), GetX(Points[TestPoint]) - GetX(Points[FirstPoint])) - PreviousAngle;
													if (TestAngle < -M_PI)
														TestAngle += M_PI * 2;
													if (NextPoint < 0)
													{
														NextPoint = TestPoint;
														NextAngle = TestAngle;
														NextLine = I;
													}
													else
													{
														if (TestAngle < NextAngle)
														{
															NextPoint = TestPoint;
															NextAngle = TestAngle;
															NextLine = I;
														}
													}
												}
											}
										}
									}
									else
									{
										PreviousPoint = InnerChordPoints[InnerChordPointCount - 2];
										PreviousAngle = Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
										NextPoint = -1;
										NextAngle = 0;
										for (I = 0; I < LineCount; I++)
										{
											if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
											{
												if (LinesA[I] == CurrentPoint)
													TestPoint = LinesB[I];
												else
													TestPoint = LinesA[I];
												if (TestPoint != PreviousPoint)
												{
													TestAngle = Atan2(GetY(Points[TestPoint]) - GetY(Points[FirstPoint]), GetX(Points[TestPoint]) - GetX(Points[FirstPoint])) - PreviousAngle;
													if (TestAngle < -M_PI)
														TestAngle += M_PI * 2;
													if (NextPoint < 0)
													{
														NextPoint = TestPoint;
														NextAngle = TestAngle;
														NextLine = I;
													}
													else
													{
														if (TestAngle < NextAngle)
														{
															NextPoint = TestPoint;
															NextAngle = TestAngle;
															NextLine = I;
														}
													}
												}
											}
										}
									}
									if (NextPoint >= 0)
									{
										OpenLines[NextLine] = False;
										InnerChordPoints[InnerChordPointCount] = NextPoint;
										InnerChordPointCount++;
										NotFound = True;
										I = 0;
										while ((NotFound) && (I < MeshStackCount[MeshStackTOS]))
											if (MeshStackPoints[MeshStackTos * StackLength + I] == NextPoint)
												NotFound = False;
											else
												I++;
										if (NotFound)
										{
											NotFound = True;
											I = 1;
											while ((NotFound) && (I < InnerChordPointCount - 1))
												if (InnerChordPoints[I] == NextPoint)
													NotFound = False;
												else
													I++;
											if (NotFound)
												OpenPoints[NextPoint] = False;
											else
											{
												InnerChordPointLoop = I;
												HasMoreIterations = False;
											}
										}
										else
										{
											HasMoreIterations = False;
										}
									}
									else
									{
										if (NextLine == InfiniteLoopLine)
											return False; // Bad SECTOR lines.
										OpenLines[NextLine] = False;
										InfiniteLoopLine = NextLine;
										AllPointsVisited = True;
										for (I = 0; I < LineCount; I++)
											if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
												AllPointsVisited = False;
										if (AllPointsVisited)
										{
											OpenPoints[CurrentPoint] = False;
											InnerChordPointCount++;
										}
										if (InnerChordPointCount == 0)
											HasMoreIterations = False;
									}
								}
								if (InnerChordPointCount > 0)
								{
									if (InnerChordPointLoop > 0)
									{
										return False; // I need more study and work to finish this part.
									}
									else
									{
										ChordBegin = 0;
										while (MeshStackPoints[MeshStackTos * StackLength + ChordBegin] != InnerChordPoints[0])
											ChordBegin++;
										PreviousPoint = MeshStackPoints[MeshStackTos * StackLength + (ChordBegin + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
										ChordEnd = MeshStackCount[MeshStackTOS] - 1;
										while (MeshStackPoints[MeshStackTos * StackLength + ChordEnd] != InnerChordPoints[InnerChordPointCount - 1])
											ChordEnd--;
										NextPoint = MeshStackPoints[MeshStackTos * StackLength + (ChordEnd + 1) % MeshStackCount[MeshStackTOS]];
										OuterChordPointCount = ChordEnd - ChordBegin + 1;
										if (OuterChordPointCount < 0)
										{
											OuterChordPointCount = OuterChordPointCount + MeshStackCount[MeshStackTOS];
											for (I = ChordBegin; I <= ChordEnd + MeshStackCount[MeshStackTOS]; I++)
												OuterChordPoints[I - ChordBegin] = MeshStackPoints[MeshStackTos * StackLength + I % MeshStackCount[MeshStackTOS]];
										}
										else
										{
											for (I = ChordBegin; I <= ChordEnd; I++)
												OuterChordPoints[I - ChordBegin] = MeshStackPoints[MeshStackTos * StackLength + I];
										}
										if (InnerChordPointCount > OuterChordPointCount)
										{
											MeshStackCount[MeshStackTOS] = MeshStackCount[MeshStackTOS] - OuterChordPointCount + InnerChordPointCount;
											for (I = MeshStackCount[MeshStackTOS] - 1; I >= ChordEnd; I--)
												MeshStackPoints[MeshStackTos * StackLength + I + InnerChordPointCount - OuterChordPointCount] = MeshStackPoints[MeshStackTos * StackLength + I];
										}
										else if (InnerChordPointCount < OuterChordPointCount)
										{
											MeshStackCount[MeshStackTOS] = MeshStackCount[MeshStackTOS] - OuterChordPointCount + InnerChordPointCount;
											if (ChordBegin > ChordEnd)
												for (I = ChordEnd; I <= ChordBegin; I++)
													MeshStackPoints[MeshStackTos * StackLength + I - ChordEnd] = MeshStackPoints[MeshStackTos * StackLength + I];
											else
												for (I = ChordBegin + 1; I < MeshStackCount[MeshStackTOS]; I++)
													MeshStackPoints[MeshStackTos * StackLength + I] = MeshStackPoints[MeshStackTos * StackLength + I + OuterChordPointCount - InnerChordPointCount];
										}
										for (I = 1; I < InnerChordPointCount - 1; I++)
											MeshStackPoints[MeshStackTos * StackLength + (ChordBegin + I - 1) % MeshStackCount[MeshStackTOS]] = InnerChordPoints[I];
										MeshStackTOS++;
										MeshStackCount[MeshStackTOS] = InnerChordPointCount + OuterChordPointCount - 2;
										TestAngle = Atan2(GetY(Points[NextPoint]) - GetY(Points[InnerChordPoints[InnerChordPointCount - 1]]), GetX(Points[NextPoint]) - GetX(Points[InnerChordPoints[InnerChordPointCount - 1]]));
										if (TestAngle < 0)
										{
											for (I = 0; I < OuterChordPointCount; I++)
												MeshStackPoints[MeshStackTos * StackLength + I] = OuterChordPoints[I];
											for (I = 1; I < InnerChordPointCount - 1; I++)
												MeshStackPoints[MeshStackTos * StackLength + OuterChordPointCount + I - 1] = InnerChordPoints[InnerChordPointCount - I - 1];
										}
										else
										{
											for (I = 0; I < InnerChordPointCount; I++)
												MeshStackPoints[MeshStackTos * StackLength + I] = InnerChordPoints[InnerChordPointCount - I - 1];
											for (I = 1; I < OuterChordPointCount - 1; I++)
												MeshStackPoints[MeshStackTos * StackLength + InnerChordPointCount + I - 1] = OuterChordPoints[I];
										}
									}
								}
								else
								{
									return False; // I need more study and work to finish this part.
								}
							}
							else
							{
								CurrentPolygon = SectorPolygons.NewPolygon(Points[MeshStackPoints[MeshStackTos * StackLength + 0]]);
								for (I = 1; I < MeshStackCount[MeshStackTOS]; I++)
									SectorPolygons.NewPoint(CurrentPolygon, Points[MeshStackPoints[MeshStackTos * StackLength + I]]);;
								MeshStackTOS--;
							}
						}
						for (J = OuterPerimeterPointStart; J <= PointQueueTail; J++)
							for (I = 0; I < LineCount; I++)
								if (((LinesA[I] == OuterPerimeterPoints[(J + OuterPerimeterPointCount - 1) % OuterPerimeterPointCount]) && (LinesB[I] == OuterPerimeterPoints[J % OuterPerimeterPointCount])) || ((LinesA[I] == OuterPerimeterPoints[J % OuterPerimeterPointCount]) && (LinesB[I] == OuterPerimeterPoints[(J + OuterPerimeterPointCount - 1) % OuterPerimeterPointCount])))
									OpenLines[I] = False;
						for (J = 0; J < OuterPerimeterPointCount; J++)
						{
							AllPointsVisited = True;
							for (I = 0; I < LineCount; I++)
								if ((OpenLines[I]) && ((LinesA[I] == OuterPerimeterPoints[J]) || (LinesB[I] == OuterPerimeterPoints[J])))
									AllPointsVisited = False;
							if (AllPointsVisited)
								OpenPoints[OuterPerimeterPoints[J]] = False;
						}
						PointQueueTail = OuterPerimeterPointStart;
					}
				}
				else
				{
					if (NextLine == InfiniteLoopLine)
						return False; // Bad SECTOR lines.
					OpenLines[NextLine] = False;
					InfiniteLoopLine = NextLine;
					AllPointsVisited = True;
					for (I = 0; I < LineCount; I++)
						if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
						{
							AllPointsVisited = False;
							break;
						}
					if (AllPointsVisited)
					{
						OpenPoints[CurrentPoint] = False;
						PointQueueTail--;
					}
				}
			}
			// Check if all points are closed.
			AllPointsVisited = True;
			for (I = 0; I < PointCount; I++)
				if (OpenPoints[I])
				{
					AllPointsVisited = False;
					break;
				}
		} while (!AllPointsVisited);
		if (SectorPolygons.GetPolygonCount() == 0)
			return False;
		InputPolygons.Clear();
		if (SectorPolygons.GetPolygonCount() == 1)
		{
			// Only one closed region.
			CurrentPolygon = InputPolygons.NewPolygon(SectorPolygons.GetPolygonPoint(0, 0));
			for (K = 1; K < SectorPolygons.GetPolygonPointCount(0); K++)
				InputPolygons.NewPoint(CurrentPolygon, SectorPolygons.GetPolygonPoint(0, K));
			InputPolygons.SetHole(CurrentPolygon, False);
			ProcessPolygons(SectorNumber);
		}
		else
		{
			// Multiple closed regions: check the holes and nested regions.
			int MaxDepthLevel = 0;
			for (I = 0; I < SectorPolygons.GetPolygonCount(); I++)
				PolygonDepthLevel[I] = 0;
			for (I = 0; I < SectorPolygons.GetPolygonCount(); I++)
				for (J = 0; J < SectorPolygons.GetPolygonCount(); J++)
					if ((I != J) && (PolygonInsidePolygon(I, J)))
					{
						PolygonDepthLevel[J]++;
						if (PolygonDepthLevel[J] > MaxDepthLevel)
							MaxDepthLevel = PolygonDepthLevel[J];
					}
			for (int DepthLevel = 0; DepthLevel <= MaxDepthLevel; DepthLevel += 2)
				for (I = 0; I < SectorPolygons.GetPolygonCount(); I++)
					if (PolygonDepthLevel[I] == DepthLevel)
					{
						InputPolygons.Clear();
						CurrentPolygon = InputPolygons.NewPolygon(SectorPolygons.GetPolygonPoint(I, 0));
						for (K = 1; K < SectorPolygons.GetPolygonPointCount(I); K++)
							InputPolygons.NewPoint(CurrentPolygon, SectorPolygons.GetPolygonPoint(I, K));
						InputPolygons.SetHole(CurrentPolygon, False);
						for (J = 0; J < SectorPolygons.GetPolygonCount(); J++)
						{
							if ((PolygonDepthLevel[J] == (PolygonDepthLevel[I] + 1)) && (PolygonInsidePolygon(I, J)))
							{
								CurrentPolygon = InputPolygons.NewPolygon(SectorPolygons.GetPolygonPoint(J, 0));
								for (K = 1; K < SectorPolygons.GetPolygonPointCount(J); K++)
									InputPolygons.NewPoint(CurrentPolygon, SectorPolygons.GetPolygonPoint(J, K));
								InputPolygons.SetHole(CurrentPolygon, True);
							}
						}
						ProcessPolygons(SectorNumber);
					}
		}
		return True;
	}
// -----------------------------------------------------------------------------
// ProcessMapData
// -----------------------------------------------------------------------------
// Function ProcessMapData processes one map sector at a time.
// Fills PlaneCeilings and PlaneFloors up to MaxPlanes.
// Fills PolyhedronCeilings and PolyhedronFloors accordingly to the geometry.
// Fills VertexBegin and VertexEnd up to MaxVertexes vertices, accordingly
// to the line geometry and sides (front: V1 -> V2, back: V2 -> V1).
// -----------------------------------------------------------------------------
	void ProcessMapData(int SectorNumber)
	{
		int BackSector, FrontSector, HeightCeiling, HeightFloor, StartFloor;
		int I, J, Temp;
		Vector2 TestPoint;
		// Ignore the doors that close after 30 seconds after level start.
		if (Level.Sectors[SectorNumber].Special == 10)
			return;
		// Check for enough vertical space.
		TestPoint = Level.Sectors[SectorNumber].Lines[0].V1.P;
		HeightFloor = Level.Sectors[SectorNumber].FloorPlane.ZatPoint(TestPoint);
		HeightCeiling = Level.Sectors[SectorNumber].CeilingPlane.ZatPoint(TestPoint);
		if ((HeightCeiling - HeightFloor) < ActorHeight)
			return;
		// Get the 3D sectors.
		PlaneCount = 0;
		for (int I = 0; I < Level.Sectors[SectorNumber].Get3DFloorCount(); I++)
		{
			F3DFloor FF = Level.Sectors[SectorNumber].Get3DFloor(I);
			if (!(FF.Flags & F3DFloor.FF_EXISTS))
			{
				// Yes, this is actually needed!
				// Do no remove these lines!
				continue;
			}
			PlaneFloors[PlaneCount] = FF.Bottom.ZatPoint(TestPoint);
			PlaneCeilings[PlaneCount] = FF.Top.ZatPoint(TestPoint);
			PlaneCount++;
		}
		// Sort the 3D sectors.
		for (I = 0; I < PlaneCount - 1; I++)
			for (J = I + 1; J < PlaneCount; J++)
				if (PlaneCeilings[I] > PlaneCeilings[J])
				{
					Temp = PlaneCeilings[I];
					PlaneCeilings[I] = PlaneCeilings[J];
					PlaneCeilings[J] = Temp;
					Temp = PlaneFloors[I];
					PlaneFloors[I] = PlaneFloors[J];
					PlaneFloors[J] = Temp;
				}
		// Fill the polyhedron arrays.
		PolyhedronCount = 0;
		if (PlaneCount > 0)
		{
			StartFloor = HeightFloor;
			for (I = 0; I < PlaneCount; I++)
			{
				if ((PlaneFloors[I] - StartFloor) > ActorHeight)
				{
					PolyhedronCeilings[PolyhedronCount] = PlaneFloors[I];
					PolyhedronFloors[PolyhedronCount] = StartFloor;
					PolyhedronCount++;
				}
				StartFloor = PlaneCeilings[I];
			}
		}
		else
		{
			PolyhedronCeilings[PolyhedronCount] = HeightCeiling;
			PolyhedronFloors[PolyhedronCount] = HeightFloor;
			PolyhedronCount++;
		}
		// Fill the vertices arrays.
		VertexCount = 0;
		for (I = 0; I < Level.Sectors[SectorNumber].Lines.Size(); I++)
		{
			FrontSector = -1;
			if (Level.Sectors[SectorNumber].Lines[I].FrontSector)
				FrontSector = Level.Sectors[SectorNumber].Lines[I].FrontSector.Index();
			BackSector = -2;
			if (Level.Sectors[SectorNumber].Lines[I].BackSector)
				BackSector = Level.Sectors[SectorNumber].Lines[I].BackSector.Index();
			//if (FrontSector == BackSector)
			//	continue;
			if (FrontSector == SectorNumber)
			{
				VertexBegin[VertexCount] = Level.Sectors[SectorNumber].Lines[I].V1.Index();
				VertexEnd[VertexCount] = Level.Sectors[SectorNumber].Lines[I].V2.Index();
				VertexCount++;
			}
			else
			{
				VertexBegin[VertexCount] = Level.Sectors[SectorNumber].Lines[I].V2.Index();
				VertexEnd[VertexCount] = Level.Sectors[SectorNumber].Lines[I].V1.Index();
				VertexCount++;
			}
		}
		if (VertexCount < 3)
			return;
		ProcessSector(SectorNumber);
	}
	// Function ProcessCells builds the cell space partitioning system of the navigation mesh.
	void ProcessCells()
	{
		int CurrentCell = 0;
		int CurrentCellIndex = 0;
		int CellNumber;
		int MaxX = NavMesh.NavMeshLines[0].X1;
		int MaxY = NavMesh.NavMeshLines[0].Y1;
		int MinX = NavMesh.NavMeshLines[0].X1;
		int MinY = NavMesh.NavMeshLines[0].Y1;
		for (int I = 0; I < NavMesh.NavMeshLines.Size(); I++)
		{
			if (NavMesh.NavMeshLines[I].X1 > MaxX)
				MaxX = NavMesh.NavMeshLines[I].X1;
			if (NavMesh.NavMeshLines[I].Y1 > MaxY)
				MaxY = NavMesh.NavMeshLines[I].Y1;
			if (NavMesh.NavMeshLines[I].X2 > MaxX)
				MaxX = NavMesh.NavMeshLines[I].X2;
			if (NavMesh.NavMeshLines[I].Y2 > MaxY)
				MaxY = NavMesh.NavMeshLines[I].Y2;
			if (NavMesh.NavMeshLines[I].X1 < MinX)
				MinX = NavMesh.NavMeshLines[I].X1;
			if (NavMesh.NavMeshLines[I].Y1 < MinY)
				MinY = NavMesh.NavMeshLines[I].Y1;
			if (NavMesh.NavMeshLines[I].X2 < MinX)
				MinX = NavMesh.NavMeshLines[I].X2;
			if (NavMesh.NavMeshLines[I].Y2 < MinY)
				MinY = NavMesh.NavMeshLines[I].Y2;
		}
		NavMesh.CellOffsetX = (MinX + GridOffset) >> 8;
		NavMesh.CellOffsetY = (MinY + GridOffset) >> 8;
		int LastCellX = (MaxX + GridOffset) >> 8;
		int LastCellY = (MaxY + GridOffset) >> 8;
		NavMesh.CellNumX = LastCellX - NavMesh.CellOffsetX + 1;
		NavMesh.CellNumY = LastCellY - NavMesh.CellOffsetY + 1;
		for (int Y = 0; Y < NavMesh.CellNumY; Y++)
			for (int X = 0; X < NavMesh.CellNumX; X++)
			{
				CellNumber = Y * NavMesh.CellNumX + X;
				while (CurrentCellIndex <= CellNumber)
				{
					NavMesh.CellsIndex.Push(CurrentCell);
					CurrentCellIndex++;
				}
				for (int PolygonIndex = 0; PolygonIndex < NavMesh.NavMeshPolygons.Size(); PolygonIndex++)
				{
					MaxX = NavMesh.NavMeshLines[0].X1;
					MaxY = NavMesh.NavMeshLines[0].Y1;
					MinX = NavMesh.NavMeshLines[0].X1;
					MinY = NavMesh.NavMeshLines[0].Y1;
					for (int I = 0; I < NavMesh.NavMeshPolygons[PolygonIndex].LineCount; I++)
					{
						TNavMeshLine NavMeshLine = NavMesh.NavMeshLines[NavMesh.NavMeshPolygons[PolygonIndex].LineFirst + I];
						if (NavMesh.NavMeshLines[I].X1 > MaxX)
							MaxX = NavMesh.NavMeshLines[I].X1;
						if (NavMesh.NavMeshLines[I].Y1 > MaxY)
							MaxY = NavMesh.NavMeshLines[I].Y1;
						if (NavMesh.NavMeshLines[I].X2 > MaxX)
							MaxX = NavMesh.NavMeshLines[I].X2;
						if (NavMesh.NavMeshLines[I].Y2 > MaxY)
							MaxY = NavMesh.NavMeshLines[I].Y2;
						if (NavMesh.NavMeshLines[I].X1 < MinX)
							MinX = NavMesh.NavMeshLines[I].X1;
						if (NavMesh.NavMeshLines[I].Y1 < MinY)
							MinY = NavMesh.NavMeshLines[I].Y1;
						if (NavMesh.NavMeshLines[I].X2 < MinX)
							MinX = NavMesh.NavMeshLines[I].X2;
						if (NavMesh.NavMeshLines[I].Y2 < MinY)
							MinY = NavMesh.NavMeshLines[I].Y2;
					}
					MinX = (MinX + GridOffset) >> 8 - NavMesh.CellOffsetX;
					MinY = (MinY + GridOffset) >> 8 - NavMesh.CellOffsetY;
					MaxX = (MaxX + GridOffset) >> 8 - NavMesh.CellOffsetX;
					MaxY = (MaxY + GridOffset) >> 8 - NavMesh.CellOffsetY;
					if ((X >= MinX) && (X <= MaxX) && (Y >= MinY) && (Y <= MaxY))
					{
						NavMesh.Cells.Push(PolygonIndex);
						CurrentCell++;
					}
				}
			}
		// Add last cell index.
		NavMesh.CellsIndex.Push(CurrentCell);
		// Delete the "Per-sector polygons chain".
		NavMesh.PolygonChain.Destroy();
		NavMesh.PolygonChain = null;
	}
	// Function Build produces a NavMesh with the specified map and settings.
	void Build(TNavMesh NavMesh, int ActorHeight, int ActorRadius)
	{
		self.ActorHeight = ActorHeight;
		self.ActorWidth = ActorWidth;
		self.NavMesh = NavMesh;
		NavMesh.PolygonChain = TGridList.Create();
		PreProcessMapData();
	}
	static TNavMeshBuilder Create()
	{
		TNavMeshBuilder NavMeshBuilder = New('TNavMeshBuilder');
		NavMeshBuilder.GridLinedef = TGridList.Create();
		NavMeshBuilder.GridNavMeshLine = TGridList.Create();
		NavMeshBuilder.InputPolygons = TPolygons.Create();
		NavMeshBuilder.OutputPolygons = TPolygons.Create();
		NavMeshBuilder.SectorPolygons = TPolygons.Create();
		NavMeshBuilder.Triangles = TPolygons.Create();
		return NavMeshBuilder;
	}
	override void OnDestroy()
	{
		GridLinedef.Destroy();
		GridNavMeshLine.Destroy();
		InputPolygons.Destroy();
		OutputPolygons.Destroy();
		SectorPolygons.Destroy();
		Triangles.Destroy();
		super.OnDestroy();
	}
}

// -----------------------------------------------------------------------------
// NavMesh level handler.
// -----------------------------------------------------------------------------

class TNavMeshBuilderWorker : Thinker
{
	const MaxTime = 5; // Maximum time of computation in milliseconds.
	TNavMeshBuilder NavMeshBuilder;
	int CurrentSector;
	void Link(TNavMeshBuilder NavMeshBuilder)
	{
		CurrentSector = 0;
		self.NavMeshBuilder = NavMeshBuilder;
	}
	override void Tick()
	{
		super.Tick();
		if (CurrentSector < Level.Sectors.Size())
		{
			int StartTime = MSTime();
			while ((CurrentSector < Level.Sectors.Size()) && ((MSTime() - StartTime) < MaxTime))
			{
				NavMeshBuilder.ProcessMapData(CurrentSector);
				CurrentSector++;
			}
			//Console.Printf("Processed sector %i, elapsed time = %i", CurrentSector, MSTime() - StartTime);
		}
		else
		{
			NavMeshBuilder.Destroy();
			Destroy();
		}
	}
}

// Level handler, that instantiates the NavMesh.
class TNavMeshHandler : EventHandler
{
	TNavMesh NavMesh;
	override void WorldLoaded(WorldEvent E)
	{
		NavMesh = TNavMesh.Create();
		TNavMeshReader NavMeshReader = TNavMeshReader.Create();
		if (!NavMeshReader.Read(Level.MapName, NavMesh))
		{
			TNavMeshBuilder NavMeshBuilder = TNavMeshBuilder.Create();
			NavMeshBuilder.Build(NavMesh, 64, 32);
			TNavMeshBuilderWorker NavMeshBuilderWorker = New('TNavMeshBuilderWorker');
			NavMeshBuilderWorker.Link(NavMeshBuilder);
		}
	}
	override void WorldUnloaded(WorldEvent E)
	{
		NavMesh.Destroy();
		NavMesh = null;
	}
}

// -----------------------------------------------------------------------------
// NavMesh base Actor.
// -----------------------------------------------------------------------------
class TCustomNavMeshActor : KAI_Actor abstract
{
	TNavMesh NavMesh;
	// True if the route is valid.
	bool RouteActive;
	// The Route is simply an array of points.
	Array<TNavMeshRoute> Route;
	int RouteStep;
	// The last polygon of the self Actor.
	int  RouteLastSelfPolygon;
	// The last polygon of the Target Actor.
	int  RouteLastTargetPolygon;
	// Route management functions.
	void RouteBegin()
	{
		RouteActive = True;
		RouteStep = Route.Size() - 1;
	}
	void RouteEnd()
	{
		Route.Clear();
		RouteActive = False;
	}
	bool RouteSearch(Vector3 Destination)
	{
		int CurrentSelfPolygon = NavMesh.SearchPolygon(Pos);
		int CurrentTargetPolygon = NavMesh.SearchPolygon(Destination);
		if ((CurrentSelfPolygon >= 0) && (CurrentTargetPolygon >= 0) && (CurrentSelfPolygon != CurrentTargetPolygon))
		{
			RouteLastSelfPolygon = CurrentSelfPolygon;
			RouteLastTargetPolygon = CurrentTargetPolygon;
			return NavMesh.SearchRoute(CurrentSelfPolygon, CurrentTargetPolygon, Route);
		}
		return False;
	}
	void RouteChase(Vector3 Destination)
	{
		// Update the current position and the target position.
		int CurrentSelfPolygon = NavMesh.SearchPolygon(Pos);
		int CurrentTargetPolygon = NavMesh.SearchPolygon(Destination);
		if ((CurrentSelfPolygon < 0) || (CurrentTargetPolygon < 0))
		{
			// No route!
			RouteEnd();
			KAI_MoveTowards(Target.Pos);;
			return;
		}
		// Update the next step.
		if ((RouteStep > 0) && (CurrentSelfPolygon == Route[RouteStep].Polygon))
		{
			RouteStep--;
			if (RouteStep == 0)
			{
				// Destination reached, the Route is no longer necessary.
				RouteEnd();
				KAI_MoveTowards(Target.Pos);;
				return;
			}
		}
		if (CurrentTargetPolygon != RouteLastTargetPolygon)
		{
			// Checks if the target has moved slightly.
			if (NavMesh.UpdateRoute(RouteLastTargetPolygon, CurrentTargetPolygon, Route, RouteStep))
				RouteLastTargetPolygon = CurrentTargetPolygon;
			else
			{
				// A new route is needed.
				RouteEnd();
				KAI_MoveTowards(Target.Pos);;
				return;
			}
		}
		// Move towards the current destination.
		KAI_MoveTowards(Route[RouteStep].Position);
	}
	void SightChase()
	{
		int ChaseFlags = 0;
		KAI_Chase_PreChecks(ChaseFlags);
		KAI_MoveTowards(Target.Pos);
		ShouldAttack();
	}
	void A_CustomChase()
	{
		if (Target)
		{
			if (CheckSight(Target))
			{
				if (RouteActive)
					RouteEnd();
				SightChase();
			}
			else
			{
				if (NavMesh)
					if (RouteActive)
						RouteChase(Target.Pos);
					else
					{
						if (RouteSearch(Target.Pos))
						{
							RouteBegin();
							RouteChase(Target.Pos);
						}
						else
							KAI_MoveTowards(Target.Pos);
					}
				else
					KAI_MoveTowards(Target.Pos);
			}
		}
	}
	override void PostBeginPlay()
	{
		super.PostBeginPlay();
		let NavMeshHandler = TNavMeshHandler(EventHandler.Find('TNavMeshHandler'));
		if (NavMeshHandler)
			NavMesh = NavMeshHandler.NavMesh;
		else
			NavMesh = null;
	}
}
