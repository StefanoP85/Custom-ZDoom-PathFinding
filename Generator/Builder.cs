/*
 * Author: Pollazzon Stefano
 * Project: ZDoom Navmesh builder
 * This module contains the navmesh generation algorythms
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace NavmeshBuilder;

/// <summary>
/// Enum <c>TOrientation</c> represents the possible ways of aligning 3 points in the 2D Euclidean space.
/// </summary>
public enum TOrientation
{
    Clockwise = -1,
    Collinear = 0,
    CounterClockwise = 1
}
/// <summary>
/// Class <c>TPoint</c> represents a simple point in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's very similar to the TMapVertex definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TPoint : Object
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public int X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public int Y;
    /// <summary>
    /// Constructor <c>TPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TPoint(int X, int Y) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TPoint)
            return false;
        TPoint Other = (TPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TPoint A, TPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TPoint A, TPoint B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TLine</c> represents a simple line in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's similar to the TMapLinedef definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TLine : Object
{
    /// <summary>
    /// Variable <c>A</c> represents the first point of the segment.
    /// </summary>
    public TPoint A;
    /// <summary>
    /// Variable <c>TLine</c> represents the second point of the segment.
    /// </summary>
    public TPoint B;
    /// <summary>
    /// Variable <c>Portal</c> is the index of the connected polygon if this line is a portal, or is -1 if this line is not a portal.
    /// </summary>
    public int Portal;
    /// <summary>
    /// Variable <c>Flags</c> contains the flags of the line.
    /// </summary>
    public int Flags;
    /// <summary>
    /// Variable <c>MapLinedef</c> contains the map LINEDEF index that generated this line, or -1 if it was generated by the polygon splitting.
    /// </summary>
    public int MapLinedef;
    /// <summary>
    /// Constructor <c>TLine</c> constructs a line with the given points.
    /// </summary>
    public TLine(TPoint A, TPoint B) : base()
    {
        this.A = A ?? throw new ArgumentNullException(nameof(A));
        this.B = B ?? throw new ArgumentNullException(nameof(B));
        Portal = -1;
        Flags = 0;
        MapLinedef = -1;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TLine)
            return false;
        TLine Other = (TLine)Obj;
        return (A == Other.A) && (B == Other.B);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TLine A, TLine B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TLine A, TLine B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TPolygon</c> represents a simple polygon without holes in 2D Euclidean space.
/// </summary>
public class TPolygon : Object
{
    /// <summary>
    /// Variable <c>Lines</c> is the list of lines, that are the edges of this polygon.
    /// </summary>
    public List<TLine> Lines;
    /// <summary>
    /// Variable <c>HeightFloor</c> is the height of the floor in the current polygon.
    /// </summary>
    public int HeightFloor;
    /// <summary>
    /// Variable <c>HeightCeiling</c> is the height of the ceiling in the current polygon.
    /// </summary>
    public int HeightCeiling;
    /// <summary>
    /// Variable <c>LineFirst</c> contains the first line of the polygon.
    /// </summary>
    public int LineFirst;
    /// <summary>
    /// Variable <c>LineCount</c> contains the number of lines.
    /// </summary>
    public int LineCount;
    /// <summary>
    /// Variable <c>Flags</c> contains the flags of the line.
    /// </summary>
    public int Flags;
    /// <summary>
    /// Variable <c>MapSector</c> contains the map SECTOR index that generated this polygon.
    /// </summary>
    public int MapSector;
    /// <summary>
    /// Constructor <c>TPolygon</c> is the index of the map SECTOR.
    /// </summary>
    public TPolygon() : base()
    {
        Lines = new List<TLine>();
        LineFirst = 0;
        LineCount = 0;
        Flags = 0;
        MapSector = -1;
    }
    /// <summary>
    /// Function <c>AddLine</c> adds a line of the polygon.
    /// </summary>
    /// <param name="Line"><c>Line</c> is the line to be added.</param>
    public void AddLine(TLine Line)
    {
        Lines.Add(Line);
    }
    /// <summary>
    /// Function <c>IsClosed</c> checks if the polygon is closed.
    /// </summary>
    /// <returns><c>True</c> if the polygon is closed.</returns>
    public bool IsClosed()
    {
        if (Lines.Count < 3)
            return false;
        List<Boolean> CheckedLine = new List<Boolean>(Lines.Count);
        for (int I = 0; I < Lines.Count; I++)
            CheckedLine.Add(false);
        int FirstLine = 0;
        int CurrentLine = FirstLine;
        do
        {
            CheckedLine[CurrentLine] = true;
            CurrentLine = Lines.FindIndex((Line) => Line.A == Lines[CurrentLine].B);
            if ((CurrentLine < 0) || ((CheckedLine[CurrentLine]) && (CurrentLine != FirstLine)))
                return false;
        } while ((CurrentLine != 0));
        return true;
    }
    /// <summary>
    /// Function <c>SortLines</c> sorts the lines in a continuous path between points.
    /// </summary>
    public void SortLines()
    {
        if (Lines.Count < 3)
            return;
        List<Int32> LinesIndexes = new List<Int32>(Lines.Count);
        int CurrentIndex = 0;
        LinesIndexes.Add(CurrentIndex);
        do
        {
            TLine CurrentLine = Lines[CurrentIndex];
            CurrentIndex = Lines.FindIndex((Line) => Line.A == CurrentLine.B);
            if (CurrentIndex < 0)
                return; // Only if not closed!
            if (CurrentIndex > 0)
                LinesIndexes.Add(CurrentIndex);
        } while (CurrentIndex > 0);
        for (int I = 0; I < Lines.Count; I++)
        {
            if (LinesIndexes[I] != I)
            {
                TLine A = Lines[LinesIndexes[I]];
                TLine B = Lines[I];
                Lines[LinesIndexes[I]] = B;
                Lines[I] = A;
                int IndexA = LinesIndexes[LinesIndexes[I]];
                int IndexB = LinesIndexes[I];
                LinesIndexes[LinesIndexes[I]] = IndexB;
                LinesIndexes[I] = IndexA;
            }
        }
    }
}
/// <summary>
/// Class <c>TPPLPoint</c> represents a point in 2D Euclidean space, but with floating point arithmetic.
/// </summary>
public class TPPLPoint : Object, ICloneable
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public double X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public double Y;
    /// <summary>
    /// Constructor <c>TPPLPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TPPLPoint(double X = 0, double Y = 0) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TPPLPoint)
            return false;
        TPPLPoint Other = (TPPLPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    /// <summary>
    /// Function <c>Clone</c> implements the ICloneable interface.
    /// </summary>
    /// <returns>A cloned <c>TPPLPoint</c>.</returns>
    public object Clone()
    {
        return new TPPLPoint(X, Y);
    }
    public static bool operator ==(TPPLPoint A, TPPLPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TPPLPoint A, TPPLPoint B)
    {
        return !(A == B);
    }
    public static TPPLPoint operator +(TPPLPoint P1, TPPLPoint P2)
    {
        return new TPPLPoint(P1.X + P2.X, P1.Y + P2.Y);
    }
    public static TPPLPoint operator -(TPPLPoint P1, TPPLPoint P2)
    {
        return new TPPLPoint(P1.X - P2.X, P1.Y - P2.Y);
    }
    public static TPPLPoint operator *(TPPLPoint P1, double F)
    {
        return new TPPLPoint(P1.X * F, P1.Y * F);
    }
    public static TPPLPoint operator /(TPPLPoint P1, double F)
    {
        return new TPPLPoint(P1.X / F, P1.Y / F);
    }
}
/// <summary>
/// Class <c>TPPLPolygon</c> represents a polygon in 2D Euclidean space, but with floating point arithmetic.
/// It also sorts the points in clockwise or counterclockwise order, with the following rule:
/// If the polygon represents a valid polygon: counterclockwise order is used.
/// If the polygon represents a hole: clockwise order is used.
/// </summary>
public class TPPLPolygon : Object, ICloneable
{
    /// <summary>
    /// Variable <c>Points</c> contains the Points of the polygon.
    /// </summary>
    public List<TPPLPoint> Points;
    /// <summary>
    /// Variable <c>FHole</c> is used internally, to represent a flag, that indicates this as a hole inside another polygon.
    /// </summary>
    private bool FHole;
    /// <summary>
    /// Constructor <c>TPPLPolygon</c> constructs a polygon.
    /// </summary>
    public TPPLPolygon() : base()
    {
        Points = new List<TPPLPoint>();
        FHole = false;
    }
    /// <summary>
    /// Constructor <c>TPPLPolygon</c> constructs a triangle with the given points.
    /// The points are sorted in counterclockwise order during construction.
    /// </summary>
    /// <param name="P1"><c>P1</c> is the first point of the triangle.</param>
    /// <param name="P2"><c>P1</c> is the second point of the triangle.</param>
    /// <param name="P3"><c>P1</c> is the third point of the triangle.</param>
    public TPPLPolygon(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
    {
        Points = new List<TPPLPoint>(3)
        {
            P1,
            P2,
            P3
        };
        FHole = false;
    }
    /// <summary>
    /// Function <c>Clone</c> implements the ICloneable interface.
    /// </summary>
    /// <returns>A cloned <c>TPPLPolygon</c>.</returns>
    public object Clone()
    {
        TPPLPolygon Result = new TPPLPolygon();
        foreach (TPPLPoint Point in Points)
            Result.AddPoint(Point);
        Result.Hole = FHole;
        return Result;
    }
    /// <summary>
    /// Function <c>AddPoint</c> adds a point of the polygon.
    /// </summary>
    /// <param name="Point"><c>Point</c> is the point to be added.</param>
    public void AddPoint(TPPLPoint Point)
    {
        Points.Add(Point);
    }
    /// <summary>
    /// Function <c>GetOrientation</c> calculates the points orientation of the polygon.
    /// </summary>
    /// <returns>A <c>TPPLOrientation</c> value of the orientation.</returns>
    public TOrientation GetOrientation()
    {
        int I1, I2;
        double Area = 0;
        for (I1 = 0; I1 < Points.Count; I1++)
        {
            I2 = I1 + 1;
            if (I2 == Points.Count)
                I2 = 0;
            Area += Points[I1].X * Points[I2].Y - Points[I1].Y * Points[I2].X;
        }
        if (Area > 0)
            return TOrientation.CounterClockwise;
        if (Area < 0)
            return TOrientation.Clockwise;
        return TOrientation.Collinear;
    }
    /// <summary>
    /// Function <c>SetOrientation</c> sets the orientation of the points of the polygon.
    /// </summary>
    /// <param name="PPLOrientation"><c>PPLOrientation</c> is the orientation to be applied.</param>
    public void SetOrientation(TOrientation Orientation)
    {
        TOrientation ActuralOrientation = GetOrientation();
        if ((ActuralOrientation != TOrientation.Collinear) && (ActuralOrientation != Orientation))
            Points.Reverse();
    }
    /// <summary>
    /// Function <c>SetHole</c> sets a flag, that specifies this is a hole inside another polygon.
    /// </summary>
    /// <param name="AHole"><c>AHole</c> is a boolean value, that specifies this is a hole inside another polygon.</param>
    /// <remarks>The vertex must be sorted in clockwise order in holes and in counterclockwise order in non-holes.</remarks>
    private void SetHole(bool AHole)
    {
        FHole = AHole;
        if (FHole)
            SetOrientation(TOrientation.Clockwise);
        else
            SetOrientation(TOrientation.CounterClockwise);
    }
    /// <summary>
    /// Property <c>Hole</c> gets or sets the orientation of points of the polygon, according to the needings.
    /// </summary>
    public bool Hole
    {
        get => FHole;
        set => SetHole(value);
    }
}
/// <summary>
/// Class <c>TPartitionVertex</c> is used in the triangulation process.
/// </summary>
internal class TPartitionVertex : Object
{
    internal TPPLPoint Point;
    internal bool IsActive;
    internal bool IsConvex;
    internal bool IsEar;
    internal double Angle;
    internal TPartitionVertex Previous;
    internal TPartitionVertex Next;
    internal TPartitionVertex(TPPLPoint APoint) : base()
    {
        Point = APoint;
        Previous = this;
        Next = this;
    }
}
/// <summary>
/// Class <c>TPPLPartition</c> is a static class, that handles three very important tasks.
/// 1. Hole management.
/// 2. Triangulation by ear clipping.
/// 3. Convex partitioning with the Hertel-Mehlhorn algorithm.
/// </summary>
internal static class TPPLPartition : Object
{
    internal static bool IsConvex(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
    {
        double Val;
        Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
        if (Val > 0)
            return true;
        else
            return false;
    }
    internal static bool IsReflex(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3)
    {
        double Val;
        Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
        if (Val < 0)
            return true;
        else
            return false;
    }
    internal static bool IsInside(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3, TPPLPoint Point)
    {
        if (IsConvex(P1, Point, P2))
            return false;
        if (IsConvex(P2, Point, P3))
            return false;
        if (IsConvex(P3, Point, P1))
            return false;
        return true;
    }
    internal static bool InCone(TPPLPoint P1, TPPLPoint P2, TPPLPoint P3, TPPLPoint Point)
    {
        bool Convex = IsConvex(P1, P2, P3);
        if (Convex)
        {
            if (!IsConvex(P1, P2, Point))
                return false;
            if (!IsConvex(P2, P3, Point))
                return false;
            return true;
        }
        else
        {
            if (IsConvex(P1, P2, Point))
                return true;
            if (IsConvex(P2, P3, Point))
                return true;
            return false;
        }
    }
    internal static bool Intersects(TPPLPoint P11, TPPLPoint P12, TPPLPoint P21, TPPLPoint P22)
    {
        if ((P11.X == P21.X) && (P11.Y == P21.Y))
            return false;
        if ((P11.X == P22.X) && (P11.Y == P22.Y))
            return false;
        if ((P12.X == P21.X) && (P12.Y == P21.Y))
            return false;
        if ((P12.X == P22.X) && (P12.Y == P22.Y))
            return false;
        TPPLPoint V1Ort = new TPPLPoint();
        TPPLPoint V2Ort = new TPPLPoint();
        double Dot11, Dot12, Dot21, Dot22;
        V1Ort.X = P12.Y - P11.Y;
        V1Ort.Y = P11.X - P12.X;
        V2Ort.X = P22.Y - P21.Y;
        V2Ort.Y = P21.X - P22.X;
        TPPLPoint V = P21 - P11;
        Dot21 = V.X * V1Ort.X + V.Y * V1Ort.Y;
        V = P22 - P11;
        Dot22 = V.X * V1Ort.X + V.Y * V1Ort.Y;
        V = P11 - P21;
        Dot11 = V.X * V2Ort.X + V.Y * V2Ort.Y;
        V = P12 - P21;
        Dot12 = V.X * V2Ort.X + V.Y * V2Ort.Y;
        if (Dot11 * Dot12 > 0)
            return false;
        if (Dot21 * Dot22 > 0)
            return false;
        return true;
    }
    internal static TPPLPoint Normalize(TPPLPoint Point)
    {
        TPPLPoint Result;
        double Val = Math.Sqrt(Point.X * Point.X + Point.Y * Point.Y);
        if (Val != 0)
            Result = Point / Val;
        else
            Result = new TPPLPoint
            {
                X = 0,
                Y = 0
            };
        return Result;
    }
    internal static void UpdateVertex(TPartitionVertex Vertex, TPartitionVertex[] Vertices, int NumVertices)
    {
        TPartitionVertex V1 = Vertex.Previous;
        TPartitionVertex V3 = Vertex.Next;
        TPPLPoint Vec1, Vec3;
        Vertex.IsConvex = IsConvex(V1.Point, Vertex.Point, V3.Point);
        Vec1 = Normalize(V1.Point - Vertex.Point);
        Vec3 = Normalize(V3.Point - Vertex.Point);
        Vertex.Angle = Vec1.X * Vec3.X + Vec1.Y * Vec3.Y;
        if (Vertex.IsConvex)
        {
            Vertex.IsEar = true;
            for (int I = 0; I < NumVertices; I++)
            {
                if ((Vertices[I].Point.X == Vertex.Point.X) && (Vertices[I].Point.Y == Vertex.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V1.Point.X) && (Vertices[I].Point.Y == V1.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V3.Point.X) && (Vertices[I].Point.Y == V3.Point.Y))
                    continue;
                if (IsInside(V1.Point, Vertex.Point, V3.Point, Vertices[I].Point))
                {
                    Vertex.IsEar = false;
                    break;
                }
            }
        }
        else
            Vertex.IsEar = false;
    }
    /// <summary>
    /// Function <c>RemoveHoles</c> is a simple heuristic procedure for removing holes from a list of polygons.
    /// It works by creating a diagonal from the right-most hole  to some other visible vertex.
    /// </summary>
    /// <param name="PolygonGroup"><c>PolygonGroup</c> is a closed part of a SECTOR.<br/>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list, with a single polygon, representing the result.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool RemoveHoles(TPolygonGroup PolygonGroup, List<TPPLPolygon> OutputPolygons)
    {
        TPPLPolygon Polygon = new TPPLPolygon();
        foreach (TLine Line in PolygonGroup.Polygon.Lines)
            Polygon.AddPoint(new TPPLPoint(Line.A.X, Line.A.Y));
        Polygon.Hole = false;
        // Check for the trivial case of no holes.
        if (PolygonGroup.Holes.Count == 0)
        {
            OutputPolygons.Add(Polygon);
            return true;
        }
        List<TPPLPolygon> Holes = new List<TPPLPolygon>();
        foreach (TPolygon PolygonHole in PolygonGroup.Holes)
        {
            TPPLPolygon Hole = new TPPLPolygon();
            foreach (TLine Line in PolygonHole.Lines)
                Hole.AddPoint(new TPPLPoint(Line.A.X, Line.A.Y));
            Hole.Hole = true;
            Holes.Add(Hole);
        }
        while (Holes.Count > 0)
        {
            // Find the hole point with the largest X.
            TPPLPolygon SelectedHole = Holes[0];
            int HolePointIndex = 0;
            int PolyPointIndex = 0;
            foreach (TPPLPolygon Hole in Holes)
            {
                for (int I = 0; I < Hole.Points.Count; I++)
                    if (Hole.Points[I].X > SelectedHole.Points[HolePointIndex].X)
                    {
                        SelectedHole = Hole;
                        HolePointIndex = I;
                    }
            }
            TPPLPoint HolePoint = SelectedHole.Points[HolePointIndex];
            bool PointFound = false;
            TPPLPoint BestPolyPoint = Polygon.Points[0];
            for (int I = 0; I < Polygon.Points.Count; I++)
            {
                if (Polygon.Points[I].X <= HolePoint.X)
                    continue;
                if (!InCone(Polygon.Points[(I + Polygon.Points.Count - 1) % (Polygon.Points.Count)], Polygon.Points[I], Polygon.Points[(I + 1) % (Polygon.Points.Count)], HolePoint))
                    continue;
                TPPLPoint PolyPoint = Polygon.Points[I];
                if (PointFound)
                {
                    TPPLPoint V1 = Normalize(PolyPoint - HolePoint);
                    TPPLPoint V2 = Normalize(BestPolyPoint - HolePoint);
                    if (V2.X > V1.X)
                        continue;
                }
                bool PointVisible = true;
                for (int J = 0; J < Polygon.Points.Count; J++)
                {
                    TPPLPoint LineP1 = Polygon.Points[J];
                    TPPLPoint LineP2 = Polygon.Points[(J + 1) % (Polygon.Points.Count)];
                    if (Intersects(HolePoint, PolyPoint, LineP1, LineP2))
                    {
                        PointVisible = false;
                        break;
                    }
                }
                if (PointVisible)
                {
                    PointFound = true;
                    BestPolyPoint = PolyPoint;
                    PolyPointIndex = I;
                }
            }
            if (!PointFound)
                return false;
            for (int I = 0; I <= SelectedHole.Points.Count; I++)
                Polygon.Points.Insert(PolyPointIndex + I + 1, SelectedHole.Points[(I + HolePointIndex) % SelectedHole.Points.Count]);
            Polygon.Points.Insert(PolyPointIndex + SelectedHole.Points.Count + 2, Polygon.Points[PolyPointIndex]);
            Holes.Remove(SelectedHole);
        }
        OutputPolygons.Add(Polygon);
        return true;
    }
    /// <summary>
    /// Function <c>Triangulate_EC</c> triangulates a polygon by ear clipping.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be triangulated.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of triangles.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool Triangulate_EC(TPPLPolygon InputPolygon, List<TPPLPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        if (InputPolygon.Points.Count == 3)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        int NumVertices = InputPolygon.Points.Count;
        TPartitionVertex[] Vertices = new TPartitionVertex[NumVertices];
        TPartitionVertex Ear = Vertices[0];
        for (int I = 0; I < NumVertices; I++)
            Vertices[I] = new TPartitionVertex(InputPolygon.Points[I]);
        for (int I = 0; I < NumVertices; I++)
        {
            Vertices[I].IsActive = true;
            if (I == (NumVertices - 1))
                Vertices[I].Next = Vertices[0];
            else
                Vertices[I].Next = Vertices[I + 1];
            if (I == 0)
                Vertices[I].Previous = Vertices[NumVertices - 1];
            else
                Vertices[I].Previous = Vertices[I - 1];
        }
        for (int I = 0; I < NumVertices; I++)
            UpdateVertex(Vertices[I], Vertices, NumVertices);
        for (int I = 0; I < NumVertices - 3; I++)
        {
            bool EarFound = false;
            // Search the most extruded ear.
            for (int J = 0; J < NumVertices; J++)
            {
                if (!Vertices[J].IsActive)
                    continue;
                if (!Vertices[J].IsEar)
                    continue;
                if (!EarFound)
                {
                    EarFound = true;
                    Ear = Vertices[J];
                }
                else
                {
                    if (Vertices[J].Angle > Ear.Angle)
                        Ear = Vertices[J];
                }
            }
            if (!EarFound)
                return false;
            TPPLPolygon Triangle = new TPPLPolygon(Ear.Previous.Point, Ear.Point, Ear.Next.Point);
            OutputPolygons.Add(Triangle);
            Ear.IsActive = false;
            Ear.Previous.Next = Ear.Next;
            Ear.Next.Previous = Ear.Previous;
            if (I == NumVertices - 4)
                break;
            UpdateVertex(Ear.Previous, Vertices, NumVertices);
            UpdateVertex(Ear.Next, Vertices, NumVertices);
        }
        for (int I = 0; I < NumVertices; I++)
            if (Vertices[I].IsActive)
            {
                TPPLPolygon Triangle = new TPPLPolygon(Vertices[I].Previous.Point, Vertices[I].Point, Vertices[I].Next.Point);
                OutputPolygons.Add(Triangle);
                break;
            }
        return true;
    }
    /// <summary>
    /// Function <c>ConvexPartition_HM</c> partitions a polygon into convex polygons by using the
    /// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm, 
    /// however, in practice it works much better than that and often gives optimal partition.
    /// It uses triangulation obtained by ear clipping as intermediate result.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be partitioned.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of convex polygons.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool ConvexPartition_HM(TPPLPolygon InputPolygon, List<TPPLPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        List<TPPLPolygon> Triangles = new List<TPPLPolygon>();
        int I11, I12, I21 = 0, I22 = 0, I13, I23;
        // Check if the poly is already convex.
        int NumReflex = 0;
        for (I11 = 0; I11 < InputPolygon.Points.Count; I11++)
        {
            if (I11 == 0)
                I12 = InputPolygon.Points.Count - 1;
            else
                I12 = I11 - 1;
            if (I11 == (InputPolygon.Points.Count - 1))
                I13 = 0;
            else
                I13 = I11 + 1;
            if (IsReflex(InputPolygon.Points[I12], InputPolygon.Points[I11], InputPolygon.Points[I13]))
            {
                NumReflex = 1;
                break;
            }
        }
        if (NumReflex == 0)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        if (!Triangulate_EC(InputPolygon, Triangles))
            return false;
        int TriangleIndex1 = 0, TriangleIndex2;
        while (TriangleIndex1 < Triangles.Count)
        {
            TPPLPolygon Polygon1 = Triangles[TriangleIndex1];
            TPPLPolygon? Polygon2 = null;
            for (I11 = 0; I11 < Polygon1.Points.Count; I11++)
            {
                TPPLPoint D1 = Polygon1.Points[I11];
                I12 = (I11 + 1) % (Polygon1.Points.Count);
                TPPLPoint D2 = Polygon1.Points[I12];
                bool IsDiagonal = false;
                TriangleIndex2 = TriangleIndex1;
                while (TriangleIndex2 < Triangles.Count)
                {
                    if (TriangleIndex1 != TriangleIndex2)
                    {
                        Polygon2 = Triangles[TriangleIndex2];
                        for (I21 = 0; I21 < Polygon2.Points.Count; I21++)
                        {
                            if ((D2.X != Polygon2.Points[I21].X) || (D2.Y != Polygon2.Points[I21].Y))
                                continue;
                            I22 = (I21 + 1) % (Polygon2.Points.Count);
                            if ((D1.X != Polygon2.Points[I22].X) || (D1.Y != Polygon2.Points[I22].Y))
                                continue;
                            IsDiagonal = true;
                            break;
                        }
                        if (IsDiagonal)
                            break;
                    }
                    TriangleIndex2++;
                }
                if (!IsDiagonal)
                    continue;
                TPPLPoint P2 = Polygon1.Points[I11];
                if (I11 == 0)
                    I13 = Polygon1.Points.Count - 1;
                else
                    I13 = I11 - 1;
                TPPLPoint P1 = Polygon1.Points[I13];
                if (I22 == (Polygon2!.Points.Count - 1))
                    I23 = 0;
                else
                    I23 = I22 + 1;
                TPPLPoint P3 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                P2 = Polygon1.Points[I12];
                if (I12 == (Polygon1.Points.Count - 1))
                    I13 = 0;
                else
                    I13 = I12 + 1;
                P3 = Polygon1.Points[I13];
                if (I21 == 0)
                    I23 = Polygon2.Points.Count - 1;
                else
                    I23 = I21 - 1;
                P1 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                TPPLPolygon NewPolygon = new TPPLPolygon();
                for (int J = I12; J != I11; J = (J + 1) % (Polygon1.Points.Count))
                    NewPolygon.AddPoint(Polygon1.Points[J]);
                for (int J = I22; J != I21; J = (J + 1) % (Polygon2.Points.Count))
                    NewPolygon.AddPoint(Polygon2.Points[J]);
                Triangles.RemoveAt(TriangleIndex2);
                Triangles[TriangleIndex1] = NewPolygon;
                Polygon1 = NewPolygon;
                I11 = -1;
                continue;
            }
            TriangleIndex1++;
        }
        foreach (TPPLPolygon Polygon in Triangles)
            OutputPolygons.Add(Polygon);
        return true;
    }
}
/// <summary>
/// Class <c>TPolygonGroup</c> represents a polygon in the map, obtained from a SECTOR, with SIDEDEF, LINEDEF and VERTEX data.
/// The SectorGroup is defined by the outer edges of the polygon and optionally the holes.
/// </summary>
internal class TPolygonGroup : Object
{
    /// <summary>
    /// Variable <c>Polygon</c> represents the outer lines of the SectorGroup.
    /// </summary>
    internal TPolygon Polygon;
    /// <summary>
    /// Variable <c>Holes</c> represents the inner "holes", that are polygons themselves.
    /// </summary>
    internal List<TPolygon> Holes;
    /// <summary>
    /// Constructor <c>TPolygonGroup</c> constructs and empty SectorGroup.
    /// </summary>
    internal TPolygonGroup(TPolygon Polygon)
    {
        this.Polygon = Polygon;
        Holes = new List<TPolygon>();
    }
}
/// <summary>
/// Class <c>TMapDoor</c> stores the doors, that will be included of the mesh.
/// </summary>
internal class TMapDoor : Object
{
    internal int DoorHeightCeiling;
    internal TMapSector DoorSector;
    internal TMapLinedef SideLine1;
    internal TMapLinedef SideLine2;
    internal TMapSector SideSector1;
    internal TMapSector SideSector2;
    internal TMapDoor(TMapSector DoorSector, TMapLinedef SideLine1, TMapLinedef SideLine2, TMapSector SideSector1, TMapSector SideSector2) : base()
    {
        this.DoorSector = DoorSector;
        this.SideLine1 = SideLine1;
        this.SideLine2 = SideLine2;
        this.SideSector1 = SideSector1;
        this.SideSector2 = SideSector2;
        this.DoorHeightCeiling = Math.Min(SideSector1.HeightCeiling, SideSector2.HeightCeiling) - 8;
    }
}
/// <summary>
/// Class <c>TMapSector3D</c> stores the 3D sectors, that will be included of the mesh.
/// </summary>
internal class TMapSector3D : Object
{
    internal int SectorTag;
    internal bool Swimmable;
    internal TMapLinedef ControlLinedef;
    internal TMapSector ControlSector;
    internal TMapSector3D(TMapLinedef ControlLinedef, TMapSector ControlSector) : base()
    {
        this.ControlLinedef = ControlLinedef;
        this.ControlSector = ControlSector;
        this.SectorTag = ControlLinedef.Arg0;
        this.Swimmable = (ControlLinedef.Arg1 & 0x0003) == 0x0001 ? false : true;
    }
}
/// <summary>
/// Class <c>TMapTeleporter</c> stores the teleporters, that will be included of the mesh.
/// </summary>
internal class TMapTeleporter : Object
{
    internal int SectorTag;
    internal TMapLinedef MapLinedef;
    internal TMapThing? DestinationThing;
    internal TMapTeleporter(TMapLinedef MapLinedef, TMapThing? DestinationThing, int SectorTag)
    {
        this.MapLinedef = MapLinedef;
        this.DestinationThing = DestinationThing;
        this.SectorTag = SectorTag;
    }
}
/// <summary>
/// Class <c>TNavMeshSettings</c> is used to configure the navigation mesh generation.
/// </summary>
public class TNavMeshSettings : Object
{
    /// <summary>
    /// Variable <c>ActorHeight</c> specifies the height of the Actor, that uses the NavMesh.
    /// </summary>
    public int ActorHeight;
    /// <summary>
    /// Variable <c>ActorRadius</c> specifies the radius of the Actor, that uses the NavMesh.
    /// </summary>
    public int ActorRadius;
    public TNavMeshSettings(int ActorHeight, int ActorRadius) : base()
    {
        this.ActorHeight = ActorHeight;
        this.ActorRadius = ActorRadius;
    }
}
/// <summary>
/// Class <c>TNavMesh</c> represents the navigation mesh of the processing map.
/// </summary>
public class TNavMesh : Object
{
    /// <summary>
    /// Constant <c>GridOffset</c> is the offset added to VERTEX coordinates in the map grid.
    /// </summary>
    internal const int GridOffset = 32768;
    /// <summary>
    /// Variable <c>Lines</c> stores the lines of the navigation mesh.
    /// </summary>
    internal List<TLine> FLines;
    /// <summary>
    /// Variable <c>FPolygons</c> stores the polygons of the navigation mesh.
    /// </summary>
    internal List<TPolygon> FPolygons;
    /// <summary>
    /// Variable <c>FCells</c> stores the cells partitioning system of the navigation mesh.
    /// </summary>
    internal List<Int32>[,]? FCells;
    /// <summary>
    /// Variable <c>FOffsetCellX</c> stores the first cell's X coordinate.
    /// </summary>
    internal int FOffsetCellX;
    /// <summary>
    /// Variable <c>FOffsetCellY</c> stores the first cell's Y coordinate.
    /// </summary>
    internal int FOffsetCellY;
    /// <summary>
    /// Variable <c>FNumCellX</c> stores the number of cells in the X axis.
    /// </summary>
    internal int FNumCellX;
    /// <summary>
    /// Variable <c>FNumCellY</c> stores the number of cells in the Y axis.
    /// </summary>
    internal int FNumCellY;
    /// <summary>
    /// Variable <c>MapDoors</c> stors the list of doors.
    /// </summary>
    internal List<TMapDoor> MapDoors;
    /// <summary>
    /// Variable <c>MapTeleporters</c> stores the list of teleporters.
    /// </summary>
    internal List<TMapTeleporter> MapTeleporters;
    /// <summary>
    /// Variable <c>MapSectors3D</c> stores the list of 3D sectors.
    /// </summary>
    internal List<TMapSector3D> MapSectors3D;
    /// <summary>
    /// Property <c>Lines</c> returns the lines of the navigation mesh.
    /// </summary>
    public List<TLine> Lines { get => FLines; }
    /// <summary>
    /// Property <c>Polygons</c> returns the polygons of the navigation mesh.
    /// </summary>
    public List<TPolygon> Polygons { get => FPolygons; }
    /// <summary>
    /// Property <c>Cells</c> returns the cells partitioning system of the navigation mesh.
    /// </summary>
    public List<Int32>[,]? Cells { get => FCells; }
    public int OffsetCellX { get => FOffsetCellX; }
    public int OffsetCellY { get => FOffsetCellY; }
    public int NumCellX { get => FNumCellX; }
    public int NumCellY { get => FNumCellY; }
    /// <summary>
    /// propertz <c>Messages</c> stores the messages of the processing.
    /// </summary>
    public List<String> Messages { get; private set; }
    /// <summary>
    /// Constructor <c>TNavMesh</c> constructs the navigation mesh.
    /// </summary>
    public TNavMesh() : base()
    {
        FLines = new List<TLine>();
        FPolygons = new List<TPolygon>();
        MapDoors = new List<TMapDoor>();
        MapSectors3D = new List<TMapSector3D>();
        MapTeleporters = new List<TMapTeleporter>();
        Messages = new List<String>();
    }
    internal static TOrientation CalcDirection(TPoint A, TPoint B, TPoint C)
    {
        ArgumentNullException.ThrowIfNull(A);
        ArgumentNullException.ThrowIfNull(B);
        ArgumentNullException.ThrowIfNull(C);
        int CrossProduct = (B.Y - A.Y) * (C.X - B.X) - (B.X - A.X) * (C.Y - B.Y);
        if (CrossProduct == 0)
            return TOrientation.Collinear;
        else
            if (CrossProduct < 0)
            return TOrientation.CounterClockwise;
        else
            return TOrientation.Clockwise;
    }
    internal static bool PointOnLine(TLine Line, TPoint Point)
    {
        ArgumentNullException.ThrowIfNull(Point);
        if ((Point.X <= Math.Max(Line.A.X, Line.B.X)) && (Point.X >= Math.Min(Line.A.X, Line.B.X)) && (Point.Y <= Math.Max(Line.A.Y, Line.B.Y)) && (Point.Y >= Math.Min(Line.A.Y, Line.B.Y)))
            return true;
        else
            return false;
    }
    internal static bool LineIntersectLine(TLine Line1, TLine Line2)
    {
        ArgumentNullException.ThrowIfNull(Line1);
        ArgumentNullException.ThrowIfNull(Line2);
        TOrientation Direction1 = CalcDirection(Line1.A, Line1.B, Line2.A);
        TOrientation Direction2 = CalcDirection(Line1.A, Line1.B, Line2.B);
        TOrientation Direction3 = CalcDirection(Line2.A, Line2.B, Line1.A);
        TOrientation Direction4 = CalcDirection(Line2.A, Line2.B, Line1.B);
        if ((Direction1 != Direction2) && (Direction3 != Direction4))
            return true;
        if ((Direction1 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.A)))
            return true;
        if ((Direction2 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.B)))
            return true;
        if ((Direction3 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.A)))
            return true;
        if ((Direction4 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.B)))
            return true;
        return false;
    }
    internal static bool PointInsidePolygon(TPolygon Polygon, TPoint Point)
    {
        if (Polygon.Lines.Count < 3)
            return false;
        bool Result = false;
        TPoint P1 = Polygon.Lines[0].A;
        foreach (TLine Line in Polygon.Lines)
        {
            TPoint P2 = Line.B;
            if (Point.Y > Math.Min(P1.Y, P2.Y))
                if (Point.Y <= Math.Max(P1.Y, P2.Y))
                    if (Point.X <= Math.Max(P1.X, P2.X))
                    {
                        double IntersectionX = (Point.Y - P1.Y) * (P2.X - P1.X) / (P2.Y - P1.Y) + P1.X;
                        if ((P1.X == P2.X) || (Point.X <= IntersectionX))
                            Result = !Result;
                    }
            P1 = P2;
        }
        return Result;
    }
    internal static bool PolygonInsidePolygon(TPolygon OuterPolygon, TPolygon TestPoligon)
    {
        if ((OuterPolygon.Lines.Count < 3) || (TestPoligon.Lines.Count < 3))
            return false;
        else
            return (PointInsidePolygon(OuterPolygon, TestPoligon.Lines[0].A)) && (PointInsidePolygon(OuterPolygon, TestPoligon.Lines[0].B));
    }
    /// <summary>
    /// Function <c>CheckLinedefCrushing</c> checks if a linedef has crushing damage effects.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    internal bool CheckLinedefCrushing(TMapDefinition MapDefinition, TMapLinedef MapLinedef)
    {
        bool Result = false;
        if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
            switch (MapDefinition.MapNamespace)
            {
                case TMapNamespace.MapNamespaceDoom:
                    if ((MapLinedef.Special == 6)
                        || (MapLinedef.Special == 25)
                        || (MapLinedef.Special == 49)
                        || (MapLinedef.Special == 55)
                        || (MapLinedef.Special == 56)
                        || (MapLinedef.Special == 57)
                        || (MapLinedef.Special == 65)
                        || (MapLinedef.Special == 73)
                        || (MapLinedef.Special == 74)
                        || (MapLinedef.Special == 77)
                        || (MapLinedef.Special == 94)
                        || (MapLinedef.Special == 141)
                        || (MapLinedef.Special == 150)
                        || (MapLinedef.Special == 164)
                        || (MapLinedef.Special == 165)
                        || (MapLinedef.Special == 168)
                        || (MapLinedef.Special == 183)
                        || (MapLinedef.Special == 184)
                        || (MapLinedef.Special == 185)
                        || (MapLinedef.Special == 188)
                        || ((MapLinedef.Special >= 0x2F80) && (MapLinedef.Special <= 0x2FFF))
                        || ((MapLinedef.Special >= 0x4000) && (MapLinedef.Special <= 0x5FFF))
                        || ((MapLinedef.Special >= 0x6000) && (MapLinedef.Special <= 0x7FFF)))
                        Result = true;
                    break;
                case TMapNamespace.MapNamespaceZDoom:
                    if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial)
                        && ((MapLinedef.Special == 28)
                        || (MapLinedef.Special == 42)
                        || (MapLinedef.Special == 43)
                        || (MapLinedef.Special == 45)
                        || (MapLinedef.Special == 97)
                        || (MapLinedef.Special == 99)
                        || (MapLinedef.Special == 104)
                        || (MapLinedef.Special == 168)
                        || (MapLinedef.Special == 169)
                        || (MapLinedef.Special == 195)
                        || (MapLinedef.Special == 196)
                        || (MapLinedef.Special == 197)
                        || (MapLinedef.Special == 205)
                        || (MapLinedef.Special == 284)))
                        Result = true;
                    break;
            }
        return Result;
    }
    /// <summary>
    /// Function <c>CheckLinedefDoor</c> checks if a linedef has door special.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
    internal bool CheckLinedefDoor(TMapDefinition MapDefinition, TMapLinedef MapLinedef)
    {
        bool Result = false;
        if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
            switch (MapDefinition.MapNamespace)
            {
                case TMapNamespace.MapNamespaceDoom:
                    if ((MapLinedef.Special == 1) || (MapLinedef.Special == 32) || (MapLinedef.Special == 33) || (MapLinedef.Special == 34))
                        Result = true;
                    break;
                case TMapNamespace.MapNamespaceZDoom:
                    if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial))
                        if ((MapLinedef.Special == 11) || (MapLinedef.Special == 12))
                            Result = true;
                    break;
            }
        if (Result)
        {
            // Check if the LINEDEF is connected to the back SIDEDEF's SECTOR tag ID.
            if (MapLinedef.Arg0 != 0)
            {
                int BackSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                if (MapDefinition.MapSector[BackSector].ID != MapLinedef.Arg0)
                    Result = false;
            }
        }
        return Result;
    }
    /// <summary>
    /// Function <c>CheckLinedefTeleporter</c> checks if a linedef has teleporter special.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    internal bool CheckLinedefTeleporter(TMapDefinition MapDefinition, TMapLinedef MapLinedef)
    {
        bool Result = false;
        if ((!MapLinedef.Blocking) && (MapLinedef.SideFront >= 0) && (MapLinedef.SideBack >= 0))
            switch (MapDefinition.MapNamespace)
            {
                case TMapNamespace.MapNamespaceDoom:
                    if ((MapLinedef.Special == 97) || (MapLinedef.Special == 126))
                        Result = true;
                    break;
                default:
                    if ((MapLinedef.MonsterUse) && (MapLinedef.RepeatableSpecial))
                        if ((MapLinedef.Special == 70) || (MapLinedef.Special == 71))
                            Result = true;
                    break;
            }
        return Result;
    }
    /// <summary>
    /// Function <c>CheckLinedef3D</c> checks if a linedef has 3D special.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the line to check.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    internal bool CheckLinedef3D(TMapDefinition MapDefinition, TMapLinedef MapLinedef)
    {
        bool Result = false;
        if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom)
            if ((MapLinedef.Special == 160) && ((((MapLinedef.Arg1 & 0x0003) == 0x0001) || ((MapLinedef.Arg1 & 0x0003) == 0x0002))))
                Result = true;
        return Result;
    }
    /// <summary>
    /// Function <c>PreProcessMapData</c> ignores lines and sectors according to some criteria.
    /// </summary>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    internal void PreProcessMapData(TMapDefinition MapDefinition)
    {
        // Ignore the doors that close after 30 seconds after level start.
        foreach (TMapSector MapSector in MapDefinition.MapSector)
            if (MapSector.Special == 10)
                MapSector.Ignored = true;
        foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
        {
            // Ignore the crushing ceilings and other dangerous sectors.
            if (CheckLinedefCrushing(MapDefinition, MapLinedef))
            {
                if (MapLinedef.Arg0 == 0)
                {
                    if (MapLinedef.SideBack >= 0)
                    {
                        int SectorIndex = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                        MapDefinition.MapSector[SectorIndex].Ignored = true;
                    }
                }
                else
                    foreach (TMapSector MapSector in MapDefinition.MapSector)
                        if (MapSector.ID == MapLinedef.Arg0)
                            MapSector.Ignored = true;
            }
            // Process the doors: adds the necessary data into the MapDoors list.
            if (CheckLinedefDoor(MapDefinition, MapLinedef))
            {
                int DoorSide1Sector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                int DoorSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                int OtherLinedef = -1;
                foreach (TMapSidedef SearchSidedef in MapDefinition.MapSidedef.FindAll((Sidedef) => (Sidedef.Sector == DoorSector) && (Sidedef.Index != MapLinedef.SideBack)))
                    foreach (TMapLinedef SearchLinedef in MapDefinition.MapLinedef)
                        if ((SearchLinedef.SideBack == SearchSidedef.Index) && (CheckLinedefDoor(MapDefinition, SearchLinedef)))
                        {
                            OtherLinedef = SearchLinedef.Index;
                            break;
                        }
                if (OtherLinedef >= 0)
                {
                    int DoorSide2Sector = MapDefinition.MapSidedef[MapDefinition.MapLinedef[OtherLinedef].SideFront].Sector;
                    TMapDoor MapDoor = new TMapDoor(MapDefinition.MapSector[DoorSector], MapLinedef, MapDefinition.MapLinedef[OtherLinedef], MapDefinition.MapSector[DoorSide1Sector], MapDefinition.MapSector[DoorSide2Sector]);
                    MapDoors.Add(MapDoor);
                }
            }
            // Process the teleporters: adds the necessary data into the MapDoors list.
            if (CheckLinedefTeleporter(MapDefinition, MapLinedef))
            {
                TMapTeleporter MapTeleporter;
                switch (MapDefinition.MapNamespace)
                {
                    case TMapNamespace.MapNamespaceDoom:
                        MapTeleporter = new TMapTeleporter(MapLinedef, null, MapLinedef.Arg0);
                        MapTeleporters.Add(MapTeleporter);
                        break;
                    case TMapNamespace.MapNamespaceHexen:
                        int DestinationCount = 0;
                        int ThingIndex = 0;
                        foreach (TMapThing MapThing in MapDefinition.MapThing)
                            if ((MapThing.ThingType == 14) && (MapThing.ID == MapLinedef.Arg0))
                            {
                                ThingIndex = MapThing.Index;
                                DestinationCount++;
                                if (DestinationCount > 1)
                                    break;
                            }
                        if (DestinationCount == 1)
                        {
                            MapTeleporter = new TMapTeleporter(MapLinedef, MapDefinition.MapThing[ThingIndex], MapLinedef.Arg1);
                            MapTeleporters.Add(MapTeleporter);
                        }
                        break;
                    case TMapNamespace.MapNamespaceZDoom:
                        DestinationCount = 0;
                        ThingIndex = 0;
                        foreach (TMapThing MapThing in MapDefinition.MapThing)
                            if (((MapThing.ThingType == 14) || (MapThing.ThingType == 9044)) && (MapThing.ID == MapLinedef.Arg0))
                            {
                                ThingIndex = MapThing.Index;
                                DestinationCount++;
                                if (DestinationCount > 1)
                                    break;
                            }
                        if (DestinationCount == 1)
                        {
                            MapTeleporter = new TMapTeleporter(MapLinedef, MapDefinition.MapThing[ThingIndex], MapLinedef.Arg1);
                            MapTeleporters.Add(MapTeleporter);
                        }
                        break;
                }
            }
            // Process the 3D sectors.
            if (CheckLinedef3D(MapDefinition, MapLinedef))
            {
                int ControlSector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                TMapSector3D MapSector3D = new TMapSector3D(MapLinedef, MapDefinition.MapSector[ControlSector]);
                MapSectors3D.Add(MapSector3D);
            }
        }
    }
    /// <summary>
    /// Function <c>GetPolygonGroups</c> creates the list of SectorGroup from a SECTOR.
    /// </summary>
    /// <param name="Sector"><c>Sector</c> is the map's SECTOR to split into a list of SectorGroup.</param>
    /// <returns>A list of <c>TPolygonGroup</c>, each one represents a closed region, that can contain holes.</returns>
    internal List<TPolygonGroup>? GetPolygonGroups(TMapDefinition MapDefinition, List<TLine> Lines)
    {
        // If the SECTOR has less than 3 LINEDEF, then it's scrapped.
        if (Lines.Count < 3)
            return null;
        List<TPolygonGroup> PolygonGroups = new List<TPolygonGroup>();
        // Split the closed regions of the SECTOR.
        List<TPolygon> Polygons = new List<TPolygon>();
        List<Boolean> CheckedLine = new List<Boolean>(Lines.Count);
        for (int I = 0; I < Lines.Count; I++)
            CheckedLine.Add(false);
        do
        {
            int FirstLine = CheckedLine.FindIndex((Line) => Line == false);
            if (FirstLine >= 0)
            {
                TPolygon Polygon = new TPolygon();
                Polygon.AddLine(Lines[FirstLine]);
                CheckedLine[FirstLine] = true;
                int CurrentLine = FirstLine;
                int NextLine;
                do
                {
                    NextLine = Lines.FindIndex((Line) => Line.A == Lines[CurrentLine].B);
                    if ((NextLine >= 0) && (CheckedLine[NextLine]))
                        break;
                    if ((NextLine >= 0) && (NextLine != FirstLine))
                    {
                        Polygon.AddLine(Lines[NextLine]);
                        CheckedLine[NextLine] = true;
                        CurrentLine = NextLine;
                    }
                } while ((NextLine >= 0) && (NextLine != FirstLine));
                if (Polygon.IsClosed())
                {
                    Polygon.SortLines();
                    Polygons.Add(Polygon);
                }
            }
        } while (!CheckedLine.All((Line) => Line == true));
        if (Polygons.Count == 0)
            return null;
        if (Polygons.Count == 1)
        {
            // Only one closed region.
            TPolygonGroup PolygonGroup = new TPolygonGroup(Polygons[0]);
            PolygonGroups.Add(PolygonGroup);
        }
        else
        {
            // Multiple closed regions.
            // Check the holes and nested regions / holes.
            int[] PolygonDepthLevel = new int[Polygons.Count];
            for (int I = 0; I < Polygons.Count; I++)
                PolygonDepthLevel[I] = 0;
            for (int I = 0; I < Polygons.Count; I++)
                for (int J = 0; J < Polygons.Count; J++)
                    if (I != J)
                        if (PolygonInsidePolygon(Polygons[I], Polygons[J]))
                            PolygonDepthLevel[J]++;
            int MaxDepthLevel = PolygonDepthLevel.Max();
            for (int DepthLevel = 0; DepthLevel <= MaxDepthLevel; DepthLevel += 2)
                for (int I = 0; I < Polygons.Count; I++)
                    if (PolygonDepthLevel[I] == DepthLevel)
                    {
                        TPolygonGroup PolygonGroup = new TPolygonGroup(Polygons[I]);
                        for (int J = 0; J < Polygons.Count; J++)
                            if ((I != J) && (PolygonInsidePolygon(Polygons[I], Polygons[J])))
                                PolygonGroup.Holes.Add(Polygons[J]);
                        PolygonGroups.Add(PolygonGroup);
                    }
        }
        return PolygonGroups;
    }
    /// <summary>
    /// Function <c>ProcessPolygonMesh</c> adds a mesh to the navigation mesh.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    /// <param name="Polygon"><c>Polygon</c> is the mesh to be added.</param>
    /// <param name="MapSector"><c>MapSector</c> is the index of the map SECTOR being processed.</param>
    internal void ProcessPolygonMesh(TNavMeshSettings NavMeshSettings, TMapDefinition MapDefinition, TPolygon Polygon, int MapSector)
    {
        // Check if there is enough vertical space.
        int MapDoorIndex = MapDoors.FindIndex((MapDoor) => MapDoor.DoorSector.Index == MapSector);
        if (MapDoorIndex >= 0)
            Polygon.HeightCeiling = MapDoors[MapDoorIndex].DoorHeightCeiling;
        if ((Polygon.HeightCeiling - Polygon.HeightFloor) < NavMeshSettings.ActorHeight)
            return;
        // Search for portals.
        foreach (TLine Line in Polygon.Lines)
        {
            int MapLinedefIndex = MapDefinition.MapLinedef.FindIndex((Linedef) =>
                {
                    TMapVertex V1 = MapDefinition.MapVertex[Linedef.V1];
                    TMapVertex V2 = MapDefinition.MapVertex[Linedef.V2];
                    return ((Line.A.X == V1.X) && (Line.A.Y == V1.Y) && (Line.B.X == V2.X) && (Line.B.Y == V2.Y))
                        || ((Line.A.X == V2.X) && (Line.A.Y == V2.Y) && (Line.B.X == V1.X) && (Line.B.Y == V1.Y));
                }
            );
            Line.MapLinedef = MapLinedefIndex;
            // Check for portals.
            int CurrentPolygonIndex = 0;
            int CurrentPolygonLine = 0;
            for (int I = 0; I < FLines.Count; I++)
            {
                if (((Line.A == FLines[I].A) && (Line.B == FLines[I].B)) || ((Line.A == FLines[I].B) && (Line.B == FLines[I].A)))
                {
                    bool LineIsPortal = true;
                    // If the line is generated from the splitting of the SECTOR, then check for 3D floors, else check further.
                    if (MapLinedefIndex >= 0)
                    {
                        // Check if the LINEDEF blocks monsters.
                        TMapLinedef MapLinedef = MapDefinition.MapLinedef[MapLinedefIndex];
                        if ((MapLinedef.Blocking) || (MapLinedef.SideFront < 0) || (MapLinedef.SideBack < 0) || (MapLinedef.Ignored))
                            LineIsPortal = false;
                        // Check if the two floor heights are too different.
                        int HeightFloorDifference = Math.Abs(Polygon.HeightFloor - FPolygons[CurrentPolygonIndex].HeightFloor);
                        if (HeightFloorDifference > 24)
                            LineIsPortal = false;
                        // Check if there is enough vertical space between the two connecting sectors.
                        int VerticalSpace = Math.Min(Polygon.HeightCeiling, FPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, FPolygons[CurrentPolygonIndex].HeightFloor);
                        if (VerticalSpace < NavMeshSettings.ActorHeight)
                            LineIsPortal = false;
                    }
                    else
                    {
                        // Check if the two floor heights are too different.
                        int HeightFloorDifference = Math.Abs(Polygon.HeightFloor - FPolygons[CurrentPolygonIndex].HeightFloor);
                        if (HeightFloorDifference > 24)
                            LineIsPortal = false;
                        // Check if there is enough vertical space between the two connecting sectors.
                        int VerticalSpace = Math.Min(Polygon.HeightCeiling, FPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, FPolygons[CurrentPolygonIndex].HeightFloor);
                        if (VerticalSpace < NavMeshSettings.ActorHeight)
                            LineIsPortal = false;
                    }
                    if (LineIsPortal)
                    {
                        Line.Portal = CurrentPolygonIndex;
                        FLines[I].Portal = FPolygons.Count;
                    }
                }
                CurrentPolygonLine++;
                if (CurrentPolygonLine == FPolygons[CurrentPolygonIndex].LineCount)
                {
                    CurrentPolygonLine = 0;
                    CurrentPolygonIndex++;
                }
            }
        }
        // Add the polygon.
        Polygon.LineFirst = FLines.Count;
        Polygon.LineCount = Polygon.Lines.Count;
        FPolygons.Add(Polygon);
        // Add the lines.
        foreach (TLine Line in Polygon.Lines)
            FLines.Add(Line);
    }
    /// <summary>
    /// Function <c>ProcessTeleporters</c> sets the portals between teleporters.
    /// </summary>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    internal void ProcessTeleporters(TMapDefinition MapDefinition)
    {
        TPoint V1 = new TPoint(0, 0);
        TPoint V2 = new TPoint(0, 0);
        TPoint TeleporterDestinationCenter = new TPoint(0, 0);
        foreach (TLine Line in FLines)
        {
            V1.X = Line.A.X;
            V1.Y = Line.A.Y;
            V2.X = Line.B.X;
            V2.Y = Line.B.Y;
            foreach (TMapTeleporter MapTeleporter in MapTeleporters)
            {
                if (!(MapTeleporter.DestinationThing is null))
                {
                    if (((Line.A == V1) && (Line.B == V2)) || ((Line.A == V2) && (Line.B == V1)))
                    {
                        // Get the polygon, that contains the teleporter destination.
                        TeleporterDestinationCenter.X = MapTeleporter.DestinationThing.X;
                        TeleporterDestinationCenter.Y = MapTeleporter.DestinationThing.Y;
                        int PolygonIndex = 0;
                        bool NotFound = true;
                        while ((NotFound) && (PolygonIndex < FPolygons.Count))
                            if (PointInsidePolygon(FPolygons[PolygonIndex], TeleporterDestinationCenter))
                                if ((MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom) && (MapTeleporter.DestinationThing.ThingType == 9044))
                                    if ((MapTeleporter.DestinationThing.Z >= FPolygons[PolygonIndex].HeightFloor) && (MapTeleporter.DestinationThing.Z <= FPolygons[PolygonIndex].HeightCeiling))
                                        NotFound = false;
                                    else
                                        PolygonIndex++;
                                else
                                    PolygonIndex++;
                        if (!NotFound)
                            Line.Portal = PolygonIndex;
                    }
                }
            }
        }
    }
    /// <summary>
    /// Function <c>ProcessCells</c> builds the cell space partitioning system of the navigation mesh.
    /// </summary>
    internal void ProcessCells()
    {
        int MaxX = Int32.MinValue;
        int MaxY = Int32.MinValue;
        int MinX = Int32.MaxValue;
        int MinY = Int32.MaxValue;
        foreach (TLine Line in FLines)
        {
            if (Line.A.X > MaxX)
                MaxX = Line.A.X;
            if (Line.A.Y > MaxY)
                MaxY = Line.A.Y;
            if (Line.B.X > MaxX)
                MaxX = Line.B.X;
            if (Line.B.Y > MaxY)
                MaxY = Line.B.Y;
            if (Line.A.X < MinX)
                MinX = Line.A.X;
            if (Line.A.Y < MinY)
                MinY = Line.A.Y;
            if (Line.B.X < MinX)
                MinX = Line.B.X;
            if (Line.B.Y < MinY)
                MinY = Line.B.Y;
        }
        FOffsetCellX = (MinX + GridOffset) >> 8;
        FOffsetCellY = (MinY + GridOffset) >> 8;
        int LastCellX = (MaxX + GridOffset) >> 8;
        int LastCellY = (MaxY + GridOffset) >> 8;
        FNumCellX = LastCellX - FOffsetCellX + 1;
        FNumCellY = LastCellY - FOffsetCellY + 1;
        FCells = new List<Int32>[FNumCellY, FNumCellX];
        for (int Y = 0; Y < FNumCellY; Y++)
            for (int X = 0; X < FNumCellX; X++)
                FCells[Y, X] = new List<Int32>();
        for (int PolygonIndex = 0; PolygonIndex < FPolygons.Count; PolygonIndex++)
        {
            MaxX = Int32.MinValue;
            MaxY = Int32.MinValue;
            MinX = Int32.MaxValue;
            MinY = Int32.MaxValue;
            foreach (TLine Line in FPolygons[PolygonIndex].Lines)
            {
                if (Line.A.X > MaxX)
                    MaxX = Line.A.X;
                if (Line.A.Y > MaxY)
                    MaxY = Line.A.Y;
                if (Line.B.X > MaxX)
                    MaxX = Line.B.X;
                if (Line.B.Y > MaxY)
                    MaxY = Line.B.Y;
                if (Line.A.X < MinX)
                    MinX = Line.A.X;
                if (Line.A.Y < MinY)
                    MinY = Line.A.Y;
                if (Line.B.X < MinX)
                    MinX = Line.B.X;
                if (Line.B.Y < MinY)
                    MinY = Line.B.Y;
            }
            MinX = (MinX + GridOffset) >> 8;
            MinY = (MinY + GridOffset) >> 8;
            MaxX = (MaxX + GridOffset) >> 8;
            MaxY = (MaxY + GridOffset) >> 8;
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    FCells[Y - FOffsetCellY, X - FOffsetCellX].Add(PolygonIndex);
        }
    }
    /// <summary>
    /// Function <c>ProcessPolygons</c> receives the polygons from the a group of polygons from a map SECTORS and processes them.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map definition, which we are processing.</param>
    /// <param name="Polygons"><c>Polygons</c> contains the list of PolygonGroup from the map SECTOR.</param>
    /// <param name="HeightCeiling"><c>HeightCeiling</c> is the height of the ceiling of the map SECTOR or 3D sector.</param>
    /// <param name="HeightFloor"><c>HeightFloor</c> is the height of the floor of the map SECTOR or 3D sector.</param>
    /// <param name="MapSector"><c>MapSector</c> is the index of the map SECTOR.</param>
    /// <param name="Flags"><c>Flags</c> contains additional information for the NavMesh.</param>
    internal void ProcessPolygons(TNavMeshSettings NavMeshSettings, TMapDefinition MapDefinition, List<TPPLPolygon> Polygons, int HeightFloor, int HeightCeiling, int MapSector, int Flags = 0)
    {
        foreach (TPPLPolygon Polygon in Polygons)
        {
            // Generate the mesh polygon.
            TPolygon Mesh = new TPolygon();
            Mesh.HeightFloor = HeightFloor;
            Mesh.HeightCeiling = HeightCeiling;
            Mesh.MapSector = MapSector;
            Mesh.Flags = Flags;
            for (int I = 0; I < Polygon.Points.Count; I++)
            {
                int J = (I + 1) % Polygon.Points.Count;
                Mesh.Lines.Add(
                    new TLine(
                        new TPoint(Convert.ToInt32(Polygon.Points[I].X), Convert.ToInt32(Polygon.Points[I].Y)),
                        new TPoint(Convert.ToInt32(Polygon.Points[J].X), Convert.ToInt32(Polygon.Points[J].Y))
                    )
                );
            }
            // Append the mesh polygon to the navigation mesh.
            Polygon.SetOrientation(TOrientation.CounterClockwise);
            ProcessPolygonMesh(NavMeshSettings, MapDefinition, Mesh, MapSector);
        }
    }
    /// <summary>
    /// Function <c>ProcessMapData</c> processes the map lines and sectors into convex polygons.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    internal void ProcessMapData(TNavMeshSettings NavMeshSettings, TMapDefinition MapDefinition)
    {
        List<TPolygonGroup>? PolygonGroups;
        List<TPPLPolygon> InputPolygons = new List<TPPLPolygon>();
        List<TPPLPolygon> OutputPolygons = new List<TPPLPolygon>();
        List<TLine> Lines = new List<TLine>();
        foreach (TMapSector MapSector in MapDefinition.MapSector)
            if (!MapSector.Ignored)
            {
                Lines.Clear();
                foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
                    if ((MapLinedef.SideFront >= 0) && (MapDefinition.MapSidedef[MapLinedef.SideFront].Sector == MapSector.Index))
                    {
                        TLine Line = new TLine(
                            new TPoint(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y),
                            new TPoint(MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y)
                        );
                        Line.MapLinedef = MapLinedef.Index;
                        Lines.Add(Line);
                    }
                foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
                    if ((MapLinedef.SideBack >= 0) && (MapDefinition.MapSidedef[MapLinedef.SideBack].Sector == MapSector.Index))
                    {
                        TLine Line = new TLine(
                            new TPoint(MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y),
                            new TPoint(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y)
                        );
                        Line.MapLinedef = MapLinedef.Index;
                        Lines.Add(Line);
                    }
                // Split the map sectors into a list of TPolygonGroup.
                PolygonGroups = GetPolygonGroups(MapDefinition, Lines);
                if (PolygonGroups is not null)
                {
                    foreach (TPolygonGroup PolygonGroup in PolygonGroups)
                    {
                        // Search for teleporter destinations.
                        if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceDoom)
                        {
                            foreach (TMapTeleporter MapTeleporter in MapTeleporters)
                            {
                                if (MapTeleporter.SectorTag == MapSector.ID)
                                {
                                    TPoint TeleporterDestinationCenter = new TPoint(0, 0);
                                    int ThingIndex = 0;
                                    bool NotFound = true;
                                    while ((!NotFound) && (ThingIndex < MapDefinition.MapThing.Count))
                                    {
                                        if (MapDefinition.MapThing[ThingIndex].ThingType == 14)
                                        {
                                            bool DestinationInSector = false;
                                            bool DestinationInHoles = false;
                                            TeleporterDestinationCenter.X = MapDefinition.MapThing[ThingIndex].X;
                                            TeleporterDestinationCenter.Y = MapDefinition.MapThing[ThingIndex].Y;
                                            if (PointInsidePolygon(PolygonGroup.Polygon, TeleporterDestinationCenter))
                                            {
                                                DestinationInSector = true;
                                                foreach (TPolygon HolePolygon in PolygonGroup.Holes)
                                                    if (PointInsidePolygon(HolePolygon, TeleporterDestinationCenter))
                                                    {
                                                        DestinationInHoles = true;
                                                        break;
                                                    }
                                            }
                                            if ((DestinationInSector) && (!DestinationInHoles))
                                                NotFound = false;
                                            else
                                                ThingIndex++;
                                        }
                                        else
                                            ThingIndex++;
                                    }
                                    if (NotFound)
                                        // Remove the teleporter.
                                        MapTeleporter.DestinationThing = null;
                                    else
                                        MapTeleporter.DestinationThing = MapDefinition.MapThing[ThingIndex];
                                }
                            }
                        }
                        // Perform the polygon partitioning into convex subpolygons.
                        InputPolygons.Clear();
                        OutputPolygons.Clear();
                        if (TPPLPartition.RemoveHoles(PolygonGroup, InputPolygons))
                        {
                            foreach (TPPLPolygon Polygon1 in InputPolygons)
                                if (!TPPLPartition.ConvexPartition_HM(Polygon1, OutputPolygons))
                                    Messages.Add($"Map SECTOR # {MapSector.Index} could be processed incompletely.");
                        }
                        else
                            Messages.Add($"Map SECTOR # {MapSector.Index} could not be processed.");
                        if (OutputPolygons.Count > 0)
                        {
                            // Search for 3D sectors.
                            int Sector3D = MapSectors3D.FindIndex((MapSector3D) => MapSector3D.SectorTag == MapSector.ID);
                            if (Sector3D >= 0)
                            {
                                int MiddleFloor = MapSectors3D[Sector3D].ControlSector.HeightFloor;
                                int MiddleCeiling = MapSectors3D[Sector3D].ControlSector.HeightCeiling;
                                if (MiddleFloor > MapSector.HeightFloor)
                                    ProcessPolygons(NavMeshSettings, MapDefinition, OutputPolygons, MapSector.HeightFloor, MiddleFloor, MapSector.Index, 0);
                                if (MiddleCeiling < MapSector.HeightCeiling)
                                    ProcessPolygons(NavMeshSettings, MapDefinition, OutputPolygons, MiddleCeiling, MapSector.HeightCeiling, MapSector.Index, MapSectors3D[Sector3D].Swimmable ? 0x0003 : 0x0001);
                            }
                            else
                                ProcessPolygons(NavMeshSettings, MapDefinition, OutputPolygons, MapSector.HeightFloor, MapSector.HeightCeiling, MapSector.Index);
                        }
                    }
                }
            }
    }
    /// <summary>
    /// Function <c>Build</c> produces a NavMesh with the specified map and settings.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map being processed.</param>
    public void Build(TNavMeshSettings NavMeshSettings, TMapDefinition MapDefinition)
    {
        ArgumentNullException.ThrowIfNull(NavMeshSettings);
        ArgumentNullException.ThrowIfNull(MapDefinition);
        // Performs some filtering.
        PreProcessMapData(MapDefinition);
        // Process the map data.
        ProcessMapData(NavMeshSettings, MapDefinition);
        // Final processing.
        if (FPolygons.Count > 0)
        {
            ProcessTeleporters(MapDefinition);
            ProcessCells();
        }
    }
    /// <summary>
    /// Function <c>ToString</c> returns the NavMesh in plain text format.
    /// </summary>
    /// <returns>A string that contains the NavMesh in plain text format.</returns>
    public override string ToString()
    {
        StringBuilder SB = new StringBuilder();
        SB.AppendLine("# ZDOOMNAVMESH");
        SB.AppendLine();
        SB.AppendLine("# lines");
        for (int I = 0; I < Lines.Count; I++)
            SB.AppendFormat("l {0} {1} {2} {3} {4} {5} {6}", Lines[I].A.X, Lines[I].A.Y, Lines[I].B.X, Lines[I].B.Y, Lines[I].Portal, Lines[I].MapLinedef, Lines[I].Flags).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# polygons");
        for (int I = 0; I < Polygons.Count; I++)
            SB.AppendFormat("p {0} {1} {2} {3} {4} {5}", Polygons[I].HeightFloor, Polygons[I].HeightCeiling, Polygons[I].LineFirst, Polygons[I].LineCount, Polygons[I].MapSector, Polygons[I].Flags).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# cells space partitioning");
        SB.AppendFormat("o {0} {1} {2} {3}", OffsetCellX, OffsetCellY, NumCellX, NumCellY).AppendLine();
        for (int Y = 0; Y < NumCellY; Y++)
            for (int X = 0; X < NumCellX; X++)
                if (Cells![Y, X].Count > 0)
                {
                    SB.AppendFormat("c {0}", Y * NumCellX + X);
                    foreach (Int32 PolygonIndex in Cells[Y, X])
                        SB.AppendFormat(" {0}", PolygonIndex);
                    SB.AppendLine();
                }
        return SB.ToString();
    }
}
