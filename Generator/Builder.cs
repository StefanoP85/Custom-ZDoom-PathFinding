/*
 * Author: Pollazzon Stefano
 * Project: ZDoom Navmesh builder
 * This module contains the navmesh generation algorythms
 */
using System;
using System.Collections.Generic;
using System.Text;

namespace NavmeshBuilder;

/// <summary>
/// Enum <c>TOrientation</c> represents the possible ways of aligning 3 points in the 2D Euclidean space.
/// </summary>
internal enum TOrientation
{
    Clockwise = -1,
    Collinear = 0,
    CounterClockwise = 1
}
/// <summary>
/// Class <c>TNavMeshPoint</c> represents a simple point in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's very similar to the TMapVertex definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TNavMeshPoint : Object
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public int X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public int Y;
    /// <summary>
    /// Constructor <c>TNavMeshPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TNavMeshPoint(int X, int Y) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TNavMeshPoint)
            return false;
        TNavMeshPoint Other = (TNavMeshPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TNavMeshPoint A, TNavMeshPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TNavMeshPoint A, TNavMeshPoint B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TNavMeshLine</c> represents a simple line in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's similar to the TMapLinedef definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TNavMeshLine : Object
{
    /// <summary>
    /// Variable <c>A</c> represents the first point of the segment.
    /// </summary>
    public TNavMeshPoint A;
    /// <summary>
    /// Variable <c>TNavMeshLine</c> represents the second point of the segment.
    /// </summary>
    public TNavMeshPoint B;
    /// <summary>
    /// Variable <c>Portal</c> is the index of the connected polygon if this line is a portal, or is -1 if this line is not a portal.
    /// </summary>
    public int Portal;
    /// <summary>
    /// Variable <c>MapLinedef</c> contains the map LINEDEF index that generated this line, or -1 if it was generated by the polygon splitting.
    /// </summary>
    public int MapLinedef;
    /// <summary>
    /// Constructor <c>TNavMeshLine</c> constructs a line with the given points.
    /// </summary>
    public TNavMeshLine(TNavMeshPoint A, TNavMeshPoint B) : base()
    {
        this.A = A;
        this.B = B;
        Portal = -1;
        MapLinedef = -1;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TNavMeshLine)
            return false;
        TNavMeshLine Other = (TNavMeshLine)Obj;
        return (A == Other.A) && (B == Other.B);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TNavMeshLine A, TNavMeshLine B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TNavMeshLine A, TNavMeshLine B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TNavMeshPolygon</c> represents a simple polygon without holes in 2D Euclidean space.
/// </summary>
public class TNavMeshPolygon : Object
{
    /// <summary>
    /// Variable <c>Lines</c> is the list of lines, that are the edges of this polygon.
    /// </summary>
    public List<TNavMeshLine> Lines;
    /// <summary>
    /// Variable <c>HeightFloor</c> is the height of the floor in the current polygon.
    /// </summary>
    public int HeightFloor;
    /// <summary>
    /// Variable <c>HeightCeiling</c> is the height of the ceiling in the current polygon.
    /// </summary>
    public int HeightCeiling;
    /// <summary>
    /// Variable <c>LineFirst</c> contains the first line of the polygon.
    /// </summary>
    public int LineFirst;
    /// <summary>
    /// Variable <c>LineCount</c> contains the number of lines.
    /// </summary>
    public int LineCount;
    /// <summary>
    /// Variable <c>MapSector</c> contains the map SECTOR index that generated this polygon.
    /// </summary>
    public int MapSector;
    /// <summary>
    /// Constructor <c>TNavMeshPolygon</c> is the index of the map SECTOR.
    /// </summary>
    public TNavMeshPolygon() : base()
    {
        Lines = new List<TNavMeshLine>();
        LineFirst = 0;
        LineCount = 0;
        MapSector = -1;
    }
}
/// <summary>
/// Class <c>TPoint</c> represents a point in 2D Euclidean space, but with floating point arithmetic.
/// </summary>
public class TPoint : Object
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public int X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public int Y;
    /// <summary>
    /// Constructor <c>TPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TPoint(int X = 0, int Y = 0) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TPoint)
            return false;
        TPoint Other = (TPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TPoint A, TPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TPoint A, TPoint B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TPolygon</c> represents a polygon in 2D Euclidean space, but with floating point arithmetic.
/// It also sorts the points in clockwise or counterclockwise order, with the following rule:
/// if the polygon represents a valid polygon: counterclockwise order is used;
/// if the polygon represents a hole: clockwise order is used.
/// </summary>
public class TPolygon : Object
{
    /// <summary>
    /// Variable <c>Points</c> contains the Points of the polygon.
    /// </summary>
    public List<TPoint> Points;
    /// <summary>
    /// Variable <c>FHole</c> is used internally, to represent a flag, that indicates this as a hole inside another polygon.
    /// </summary>
    private bool FHole;
    /// <summary>
    /// Constructor <c>TPolygon</c> constructs a polygon.
    /// </summary>
    public TPolygon() : base()
    {
        Points = new List<TPoint>();
        FHole = false;
    }
    /// <summary>
    /// Constructor <c>TPolygon</c> constructs a triangle with the given points.
    /// The points are sorted in counterclockwise order during construction.
    /// </summary>
    /// <param name="P1"><c>P1</c> is the first point of the triangle.</param>
    /// <param name="P2"><c>P1</c> is the second point of the triangle.</param>
    /// <param name="P3"><c>P1</c> is the third point of the triangle.</param>
    public TPolygon(TPoint P1, TPoint P2, TPoint P3)
    {
        Points = new List<TPoint>(3)
        {
            P1,
            P2,
            P3
        };
        FHole = false;
    }
    /// <summary>
    /// Function <c>GetOrientation</c> calculates the points orientation of the polygon.
    /// </summary>
    /// <returns>A <c>TOrientation</c> value of the orientation.</returns>
    internal TOrientation GetOrientation()
    {
        int I1, I2;
        double Area = 0;
        for (I1 = 0; I1 < Points.Count; I1++)
        {
            I2 = I1 + 1;
            if (I2 == Points.Count)
                I2 = 0;
            Area += Points[I1].X * Points[I2].Y - Points[I1].Y * Points[I2].X;
        }
        if (Area > 0)
            return TOrientation.CounterClockwise;
        if (Area < 0)
            return TOrientation.Clockwise;
        return TOrientation.Collinear;
    }
    /// <summary>
    /// Function <c>SetOrientation</c> sets the orientation of the points of the polygon.
    /// </summary>
    /// <param name="Orientation"><c>Orientation</c> is the orientation to be applied.</param>
    internal void SetOrientation(TOrientation Orientation)
    {
        TOrientation ActuralOrientation = GetOrientation();
        if ((ActuralOrientation != TOrientation.Collinear) && (ActuralOrientation != Orientation))
            Points.Reverse();
    }
    /// <summary>
    /// Function <c>SetHole</c> sets a flag, that specifies this is a hole inside another polygon.
    /// </summary>
    /// <param name="AHole"><c>AHole</c> is a boolean value, that specifies this is a hole inside another polygon.</param>
    /// <remarks>The vertex must be sorted in clockwise order in holes and in counterclockwise order in non-holes.</remarks>
    internal void SetHole(bool AHole)
    {
        FHole = AHole;
        if (FHole)
            SetOrientation(TOrientation.Clockwise);
        else
            SetOrientation(TOrientation.CounterClockwise);
    }
    /// <summary>
    /// Property <c>Hole</c> gets or sets the orientation of points of the polygon, according to the needings.
    /// </summary>
    internal bool Hole
    {
        get => FHole;
        set => SetHole(value);
    }
}
/// <summary>
/// Class <c>TPartitionVertex</c> is used in the triangulation process.
/// </summary>
internal class TPartitionVertex : Object
{
    internal TPoint Point;
    internal bool IsActive;
    internal bool IsConvex;
    internal bool IsEar;
    internal double Angle;
    internal TPartitionVertex Previous;
    internal TPartitionVertex Next;
    internal TPartitionVertex(TPoint APoint) : base()
    {
        Point = APoint;
        Previous = this;
        Next = this;
    }
}
/// <summary>
/// Class <c>TPartition</c> is a static class, that handles three very important tasks.
/// 1. Hole management.
/// 2. Triangulation by ear clipping.
/// 3. Convex partitioning with the Hertel-Mehlhorn algorithm.
/// </summary>
internal static class TPartition : Object
{
    internal static bool IsConvex(int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y)
    {
        return (P3Y - P1Y) * (P2X - P1X) - (P3X - P1X) * (P2Y - P1Y) > 0;
    }
    internal static bool IsConvex(TPoint P1, TPoint P2, TPoint P3)
    {
        return (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y) > 0;
    }
    internal static bool IsReflex(TPoint P1, TPoint P2, TPoint P3)
    {
        return (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y) < 0;
    }
    internal static bool IsInside(TPoint P1, TPoint P2, TPoint P3, TPoint Point)
    {
        if (IsConvex(P1, Point, P2))
            return false;
        if (IsConvex(P2, Point, P3))
            return false;
        if (IsConvex(P3, Point, P1))
            return false;
        return true;
    }
    internal static bool InCone(int P1X, int P1Y, int P2X, int P2Y, int P3X, int P3Y, int PointX, int PointY) 
    {
        if (IsConvex(P1X, P1Y, P2X, P2Y, P3X, P3Y))
        {
            if (!IsConvex(P1X, P1Y, P2X, P2Y, PointX, PointY))
                return false;
            if (!IsConvex(P2X, P2Y, P3X, P3Y, PointX, PointY))
                return false;
            return true;
        }
        else
        {
            if (IsConvex(P1X, P1Y, P2X, P2Y, PointX, PointY))
                return true;
            if (IsConvex(P2X, P2Y, P3X, P3Y, PointX, PointY))
                return true;
            return false;
        }
    }
    internal static bool InCone(TPoint P1, TPoint P2, TPoint P3, TPoint Point)
    {
        if (IsConvex(P1, P2, P3))
        {
            if (!IsConvex(P1, P2, Point))
                return false;
            if (!IsConvex(P2, P3, Point))
                return false;
            return true;
        }
        else
        {
            if (IsConvex(P1, P2, Point))
                return true;
            if (IsConvex(P2, P3, Point))
                return true;
            return false;
        }
    }
    internal static bool Intersects(TPoint P11, TPoint P12, TPoint P21, TPoint P22)
    {
        if ((P11.X == P21.X) && (P11.Y == P21.Y))
            return false;
        if ((P11.X == P22.X) && (P11.Y == P22.Y))
            return false;
        if ((P12.X == P21.X) && (P12.Y == P21.Y))
            return false;
        if ((P12.X == P22.X) && (P12.Y == P22.Y))
            return false;
        double V1OrtX = P12.Y - P11.Y;
        double V1OrtY = P11.X - P12.X;
        double V2OrtX = P22.Y - P21.Y;
        double V2OrtY = P21.X - P22.X;
        double Dot21 = (P21.X - P11.X) * V1OrtX + (P21.Y - P11.Y) * V1OrtY;
        double Dot22 = (P22.X - P11.X) * V1OrtX + (P22.Y - P11.Y) * V1OrtY;
        double Dot11 = (P11.X - P21.X) * V2OrtX + (P11.Y - P21.Y) * V2OrtY;
        double Dot12 = (P12.X - P21.X) * V2OrtX + (P12.Y - P21.Y) * V2OrtY;
        if (Dot11 * Dot12 > 0)
            return false;
        if (Dot21 * Dot22 > 0)
            return false;
        return true;
    }
    internal static void GetUnitVector(int X, int Y, out double UnitX, out double UnitY)
    {
        double Length = Math.Sqrt(X * X + Y * Y);
        UnitX = X / Length;
        UnitY = Y / Length;
    }
    internal static double GetAngle(TPoint V1, TPoint V2, TPoint V3)
    {
        GetUnitVector(V1.X - V2.X, V1.Y - V2.Y, out double Vector1X, out double Vector1Y);
        GetUnitVector(V3.X - V2.X, V3.Y - V2.Y, out double Vector3X, out double Vector3Y);
        return Vector1X * Vector3X + Vector1Y * Vector3Y;
    }
    internal static void UpdateVertex(TPartitionVertex Vertex, TPartitionVertex[] Vertices, int NumVertices)
    {
        TPartitionVertex V1 = Vertex.Previous;
        TPartitionVertex V3 = Vertex.Next;
        Vertex.IsConvex = IsConvex(V1.Point, Vertex.Point, V3.Point);
        Vertex.Angle = GetAngle(V1.Point, Vertex.Point, V3.Point);
        if (Vertex.IsConvex)
        {
            Vertex.IsEar = true;
            for (int I = 0; I < NumVertices; I++)
            {
                if ((Vertices[I].Point.X == Vertex.Point.X) && (Vertices[I].Point.Y == Vertex.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V1.Point.X) && (Vertices[I].Point.Y == V1.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V3.Point.X) && (Vertices[I].Point.Y == V3.Point.Y))
                    continue;
                if (IsInside(V1.Point, Vertex.Point, V3.Point, Vertices[I].Point))
                {
                    Vertex.IsEar = false;
                    break;
                }
            }
        }
        else
            Vertex.IsEar = false;
    }
    /// <summary>
    /// Function <c>RemoveHoles</c> is a simple heuristic procedure for removing holes from a list of polygons.
    /// It works by creating a diagonal from the right-most hole  to some other visible vertex.
    /// </summary>
    /// <param name="Polygon"><c>Polygon</c> is a closed part of a SECTOR.<br/>
    /// <param name="Holes"><c>Holes</c> is the list of the internal holes.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool RemoveHoles(TPolygon Polygon, List<TPolygon> Holes)
    {
        // Check for the trivial case of no holes.
        if (Holes.Count == 0)
        {
            return true;
        }
        while (Holes.Count > 0)
        {
            // Find the hole point with the largest X.
            TPolygon SelectedHole = Holes[0];
            int HolePointIndex = 0;
            int PolyPointIndex = 0;
            foreach (TPolygon Hole in Holes)
            {
                for (int I = 0; I < Hole.Points.Count; I++)
                    if (Hole.Points[I].X > SelectedHole.Points[HolePointIndex].X)
                    {
                        SelectedHole = Hole;
                        HolePointIndex = I;
                    }
            }
            TPoint HolePoint = SelectedHole.Points[HolePointIndex];
            bool PointFound = false;
            TPoint BestPolyPoint = Polygon.Points[0];
            for (int I = 0; I < Polygon.Points.Count; I++)
            {
                if (Polygon.Points[I].X <= HolePoint.X)
                    continue;
                if (!InCone(
                    Polygon.Points[(I + Polygon.Points.Count - 1) % (Polygon.Points.Count)],
                    Polygon.Points[I],
                    Polygon.Points[(I + 1) % (Polygon.Points.Count)], 
                    HolePoint))
                    continue;
                TPoint PolyPoint = Polygon.Points[I];
                if (PointFound)
                {
                    GetUnitVector(PolyPoint.X - HolePoint.X, PolyPoint.Y - HolePoint.Y, out double UnitX, out double UnitY);
                    GetUnitVector(BestPolyPoint.X - HolePoint.X, BestPolyPoint.Y - HolePoint.Y, out double BestX, out double BestY);
                    if (BestX > UnitX)
                        continue;
                }
                bool PointVisible = true;
                for (int J = 0; J < Polygon.Points.Count; J++)
                {
                    TPoint LineP1 = Polygon.Points[J];
                    TPoint LineP2 = Polygon.Points[(J + 1) % (Polygon.Points.Count)];
                    if (Intersects(HolePoint, PolyPoint, LineP1, LineP2))
                    {
                        PointVisible = false;
                        break;
                    }
                }
                if (PointVisible)
                {
                    PointFound = true;
                    BestPolyPoint = PolyPoint;
                    PolyPointIndex = I;
                }
            }
            if (!PointFound)
                return false;
            for (int I = 0; I <= SelectedHole.Points.Count; I++)
                Polygon.Points.Insert(PolyPointIndex + I + 1, SelectedHole.Points[(I + HolePointIndex) % SelectedHole.Points.Count]);
            Polygon.Points.Insert(PolyPointIndex + SelectedHole.Points.Count + 2, Polygon.Points[PolyPointIndex]);
            Holes.Remove(SelectedHole);
        }
        return true;
    }
    /// <summary>
    /// Function <c>Triangulate_EC</c> triangulates a polygon by ear clipping.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be triangulated.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of triangles.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool Triangulate_EC(TPolygon InputPolygon, List<TPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        if (InputPolygon.Points.Count == 3)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        int NumVertices = InputPolygon.Points.Count;
        TPartitionVertex[] Vertices = new TPartitionVertex[NumVertices];
        TPartitionVertex Ear = Vertices[0];
        for (int I = 0; I < NumVertices; I++)
            Vertices[I] = new TPartitionVertex(InputPolygon.Points[I]);
        for (int I = 0; I < NumVertices; I++)
        {
            Vertices[I].IsActive = true;
            if (I == (NumVertices - 1))
                Vertices[I].Next = Vertices[0];
            else
                Vertices[I].Next = Vertices[I + 1];
            if (I == 0)
                Vertices[I].Previous = Vertices[NumVertices - 1];
            else
                Vertices[I].Previous = Vertices[I - 1];
        }
        for (int I = 0; I < NumVertices; I++)
            UpdateVertex(Vertices[I], Vertices, NumVertices);
        for (int I = 0; I < NumVertices - 3; I++)
        {
            bool EarFound = false;
            // Search the most extruded ear.
            for (int J = 0; J < NumVertices; J++)
            {
                if (!Vertices[J].IsActive)
                    continue;
                if (!Vertices[J].IsEar)
                    continue;
                if (!EarFound)
                {
                    EarFound = true;
                    Ear = Vertices[J];
                }
                else
                {
                    if (Vertices[J].Angle > Ear.Angle)
                        Ear = Vertices[J];
                }
            }
            if (!EarFound)
                return false;
            TPolygon Triangle = new TPolygon(Ear.Previous.Point, Ear.Point, Ear.Next.Point);
            OutputPolygons.Add(Triangle);
            Ear.IsActive = false;
            Ear.Previous.Next = Ear.Next;
            Ear.Next.Previous = Ear.Previous;
            if (I == NumVertices - 4)
                break;
            UpdateVertex(Ear.Previous, Vertices, NumVertices);
            UpdateVertex(Ear.Next, Vertices, NumVertices);
        }
        for (int I = 0; I < NumVertices; I++)
            if (Vertices[I].IsActive)
            {
                TPolygon Triangle = new TPolygon(Vertices[I].Previous.Point, Vertices[I].Point, Vertices[I].Next.Point);
                OutputPolygons.Add(Triangle);
                break;
            }
        return true;
    }
    /// <summary>
    /// Function <c>ConvexPartition_HM</c> partitions a polygon into convex polygons by using the
    /// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm, 
    /// however, in practice it works much better than that and often gives optimal partition.
    /// It uses triangulation obtained by ear clipping as intermediate result.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be partitioned.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of convex polygons.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool ConvexPartition_HM(TPolygon InputPolygon, List<TPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        List<TPolygon> Triangles = new List<TPolygon>();
        int I11, I12, I21 = 0, I22 = 0, I13, I23;
        // Check if the poly is already convex.
        int NumReflex = 0;
        for (I11 = 0; I11 < InputPolygon.Points.Count; I11++)
        {
            if (I11 == 0)
                I12 = InputPolygon.Points.Count - 1;
            else
                I12 = I11 - 1;
            if (I11 == (InputPolygon.Points.Count - 1))
                I13 = 0;
            else
                I13 = I11 + 1;
            if (IsReflex(InputPolygon.Points[I12], InputPolygon.Points[I11], InputPolygon.Points[I13]))
            {
                NumReflex = 1;
                break;
            }
        }
        if (NumReflex == 0)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        if (!Triangulate_EC(InputPolygon, Triangles))
            return false;
        int TriangleIndex1 = 0, TriangleIndex2;
        while (TriangleIndex1 < Triangles.Count)
        {
            TPolygon Polygon1 = Triangles[TriangleIndex1];
            TPolygon? Polygon2 = null;
            for (I11 = 0; I11 < Polygon1.Points.Count; I11++)
            {
                TPoint D1 = Polygon1.Points[I11];
                I12 = (I11 + 1) % (Polygon1.Points.Count);
                TPoint D2 = Polygon1.Points[I12];
                bool IsDiagonal = false;
                TriangleIndex2 = TriangleIndex1;
                while (TriangleIndex2 < Triangles.Count)
                {
                    if (TriangleIndex1 != TriangleIndex2)
                    {
                        Polygon2 = Triangles[TriangleIndex2];
                        for (I21 = 0; I21 < Polygon2.Points.Count; I21++)
                        {
                            if ((D2.X != Polygon2.Points[I21].X) || (D2.Y != Polygon2.Points[I21].Y))
                                continue;
                            I22 = (I21 + 1) % (Polygon2.Points.Count);
                            if ((D1.X != Polygon2.Points[I22].X) || (D1.Y != Polygon2.Points[I22].Y))
                                continue;
                            IsDiagonal = true;
                            break;
                        }
                        if (IsDiagonal)
                            break;
                    }
                    TriangleIndex2++;
                }
                if (!IsDiagonal)
                    continue;
                TPoint P2 = Polygon1.Points[I11];
                if (I11 == 0)
                    I13 = Polygon1.Points.Count - 1;
                else
                    I13 = I11 - 1;
                TPoint P1 = Polygon1.Points[I13];
                if (I22 == (Polygon2!.Points.Count - 1))
                    I23 = 0;
                else
                    I23 = I22 + 1;
                TPoint P3 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                P2 = Polygon1.Points[I12];
                if (I12 == (Polygon1.Points.Count - 1))
                    I13 = 0;
                else
                    I13 = I12 + 1;
                P3 = Polygon1.Points[I13];
                if (I21 == 0)
                    I23 = Polygon2.Points.Count - 1;
                else
                    I23 = I21 - 1;
                P1 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                TPolygon NewPolygon = new TPolygon();
                for (int J = I12; J != I11; J = (J + 1) % (Polygon1.Points.Count))
                    NewPolygon.Points.Add(Polygon1.Points[J]);
                for (int J = I22; J != I21; J = (J + 1) % (Polygon2.Points.Count))
                    NewPolygon.Points.Add(Polygon2.Points[J]);
                Triangles.RemoveAt(TriangleIndex2);
                Triangles[TriangleIndex1] = NewPolygon;
                Polygon1 = NewPolygon;
                I11 = -1;
                continue;
            }
            TriangleIndex1++;
        }
        foreach (TPolygon Polygon in Triangles)
            OutputPolygons.Add(Polygon);
        return true;
    }
}
/// <summary>
/// Class <c>TMapSector3D</c> stores the 3D sectors, that will be included of the mesh.
/// </summary>
internal class TMapSector3D : Object
{
    internal int SectorTag;
    internal TMapLinedef ControlLinedef;
    internal TMapSector ControlSector;
    internal TMapSector3D(TMapLinedef ControlLinedef, TMapSector ControlSector) : base()
    {
        this.ControlLinedef = ControlLinedef;
        this.ControlSector = ControlSector;
        SectorTag = ControlLinedef.Arg0;
    }
}
internal class TGridList : Object 
{
    internal class TGridPage : Object 
    {
        internal int[] Values;
        internal int[] Chains;
        internal TGridPage() : base()
        {
            Values = new int[1024];
            Chains = new int[1024];
        }
    }
    internal TGridPage[] GridPages;
    internal int[] GridChains;
    internal int GridCount;
    internal TGridList() : base()
    {
        GridPages = new TGridPage[1024];
        GridChains = new int[65536];
        Clear();
    }
    internal void Clear()
    {
        GridCount = 0;
        for (int I = 0; I < 65536; I++)
            GridChains[I] = -1;
    }
    internal void Add(int GridX, int GridY, int Value)
    {
        // Add the entry in the grid chains.
        int PageNumber = GridCount >> 10;
        int PageIndex = GridCount & 1023;
        if (PageIndex == 0)
            GridPages[PageNumber] = new TGridPage();
        GridPages[PageNumber].Values[PageIndex] = Value;
        GridPages[PageNumber].Chains[PageIndex] = -1;
        // Link the value to the previous last chain.
        int ChainNumber = (GridY << 8) + GridX;
        int LastChain = GridChains[ChainNumber];
        if (GridChains[ChainNumber] >= 0)
        {
            do
            {
                PageNumber = LastChain >> 10;
                PageIndex = LastChain & 1023;
                LastChain = GridPages[PageNumber].Chains[PageIndex];
            } while (LastChain >= 0);
            GridPages[PageNumber].Chains[PageIndex] = GridCount;
        }
        else
            GridChains[ChainNumber] = GridCount;
        GridCount++;
    }
    internal void FillOneCell(int GridX, int GridY, SortedList<int, int> Result)
    {
        int ChainNumber = (GridY << 8) + GridX;
        int LastChain = GridChains[ChainNumber];
        while (LastChain >= 0)
        {
            int PageNumber = LastChain >> 10;
            int PageIndex = LastChain & 1023;
            int Value = GridPages[PageNumber].Values[PageIndex];
            if (!Result.ContainsKey(Value))
                Result.Add(Value, Value);
            LastChain = GridPages[PageNumber].Chains[PageIndex];
        }
    }
    internal void Fill(int MinX, int MaxX, int MinY, int MaxY, SortedList<int, int> Result)
    {
        for (int Y = MinY; Y <= MaxY; Y++)
            for (int X = MinX; X <= MaxX; X++)
                FillOneCell(X, Y, Result);
    }
}
/// <summary>
/// Class <c>TNavMesh</c> represents the navigation mesh of the processing map.
/// </summary>
public class TNavMesh : Object
{
    /// <summary>
    /// Constant <c>GridOffset</c> is the offset added to VERTEX coordinates in the map grid.
    /// </summary>
    internal const int GridOffset = 32768;
    /// <summary>
    /// Variable <c>MapDefinition</c> references the current map, that's being processed.
    /// </summary>
    internal TMapDefinition MapDefinition;
    /// <summary>
    /// Variable <c>ActorHeight</c> specifies the height of the Actor, that uses the NavMesh.
    /// </summary>
    internal int ActorHeight;
    /// <summary>
    /// Variable <c>ActorRadius</c> specifies the radius of the Actor, that uses the NavMesh.
    /// </summary>
    internal int ActorRadius;
    /// <summary>
    /// Variable <c>MapSectors3D</c> stores the list of 3D sectors.
    /// </summary>
    internal List<TMapSector3D> MapSectors3D;
    /// <summary>
    /// Variable <c>SectorLines</c> caches the LINEDEFs associated to each SECTOR.
    /// </summary>
    internal SortedList<Int32, List<Int32>> SectorLines;
    /// <summary>
    /// Variable <c>GridLinedef</c> caches the LINEDEFs into 256 x 256 blocks.
    /// </summary>
    internal TGridList GridLinedef;
    /// <summary>
    /// Variable <c>GridNavMeshLine</c> caches the built navigation mesh lines into 256 x 256 blocks.
    /// </summary>
    internal TGridList GridNavMeshLine;
    /// <summary>
    /// Variable <c>Lines</c> stores the lines of the navigation mesh.
    /// </summary>
    public List<TNavMeshLine> NavMeshLines { get; private set; }
    /// <summary>
    /// Variable <c>FPolygons</c> stores the polygons of the navigation mesh.
    /// </summary>
    public List<TNavMeshPolygon> NavMeshPolygons { get; private set; }
    /// <summary>
    /// Variable <c>FCells</c> stores the cells partitioning system of the navigation mesh.
    /// </summary>
    public List<Int32>[,] Cells { get; private set; }
    /// <summary>
    /// Variable <c>FOffsetCellX</c> stores the first cell's X coordinate.
    /// </summary>
    public int OffsetCellX { get; private set; }
    /// <summary>
    /// Variable <c>FOffsetCellY</c> stores the first cell's Y coordinate.
    /// </summary>
    public int OffsetCellY { get; private set; }
    /// <summary>
    /// Variable <c>FNumCellX</c> stores the number of cells in the X axis.
    /// </summary>
    public int NumCellX { get; private set; }
    /// <summary>
    /// Variable <c>FNumCellY</c> stores the number of cells in the Y axis.
    /// </summary>
    public int NumCellY { get; private set; }
    /// <summary>
    /// property <c>Messages</c> stores the messages of the processing.
    /// </summary>
    public List<String> Messages { get; private set; }
    /// <summary>
    /// Constructor <c>TNavMesh</c> constructs the navigation mesh.
    /// </summary>
    public TNavMesh(TMapDefinition MapDefinition) : base()
    {
        this.MapDefinition = MapDefinition;
        MapSectors3D = new List<TMapSector3D>();
        GridLinedef = new TGridList();
        GridNavMeshLine = new TGridList();
        SectorLines = new SortedList<Int32, List<Int32>>();
        NavMeshLines = new List<TNavMeshLine>();
        NavMeshPolygons = new List<TNavMeshPolygon>();
        Messages = new List<String>();
        Cells = new List<Int32>[1, 1];
    }
    /// <summary>
    /// Function <c>PointInsidePolygon</c> checks if a point is contained in another polygon.
    /// </summary>
    /// <param name="Polygon"><c>Polygon</c> is the external polygon, that could contain the point.</param>
    /// <param name="Point"><c>Point</c> is the point, to be tested, if it's contained in the polygon.</param>
    /// <returns><c>True</c> if <c>Point</c> is contained in <c>Polygon</c>, <c>False</c> otherwise.</returns>
    internal static bool PointInsidePolygon(TPolygon Polygon, TPoint Point)
    {
        if (Polygon.Points.Count < 3)
            return false;
        bool Result = false;
        TPoint P1 = Polygon.Points[0];
        for (int I = 0; I < Polygon.Points.Count; I++)
        {
            TPoint P2 = Polygon.Points[(I + 1) % Polygon.Points.Count];
            if (Point.Y > Math.Min(P1.Y, P2.Y))
                if (Point.Y <= Math.Max(P1.Y, P2.Y))
                    if (Point.X <= Math.Max(P1.X, P2.X))
                    {
                        double IntersectionX = (Point.Y - P1.Y) * (P2.X - P1.X) / (P2.Y - P1.Y) + P1.X;
                        if ((P1.X == P2.X) || (Point.X <= IntersectionX))
                            Result = !Result;
                    }
            P1 = P2;
        }
        return Result;
    }
    /// <summary>
    /// Function <c>PolygonInsidePolygon</c> checks if a polygon is contained in another polygon.
    /// </summary>
    /// <param name="OuterPolygon"><c>OuterPolygon</c> is the external polygon, that could contain the other.</param>
    /// <param name="TestPoligon"><c>TestPolygon</c> is the polygon, to be tested, if it's contained in the other.</param>
    /// <returns><c>True</c> if <c>TestPolygon</c> is contained in <c>OuterPolygon</c>, <c>False</c> otherwise.</returns>
    /// <remarks>This function tests the first two points of the inner polygon.</remarks>
    internal static bool PolygonInsidePolygon(TPolygon OuterPolygon, TPolygon TestPoligon)
    {
        if ((OuterPolygon.Points.Count < 3) || (TestPoligon.Points.Count < 3))
            return false;
        else
            return (PointInsidePolygon(OuterPolygon, TestPoligon.Points[0])) && (PointInsidePolygon(OuterPolygon, TestPoligon.Points[1]));
    }
    /// <summary>
    /// Function <c>CheckLinedef3D</c> checks if a linedef has 3D special.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the LINEDEF to be checked for 3D sector control.</param>
    internal bool CheckLinedef3D(TMapLinedef MapLinedef)
    {
        bool Result = false;
        if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom)
            if ((MapLinedef.Special == 160) && ((((MapLinedef.Arg1 & 0x0003) == 0x0001) || ((MapLinedef.Arg1 & 0x0003) == 0x0002))))
                Result = true;
        return Result;
    }
    /// <summary>
    /// Function <c>GetGridExtent</c> gets the limiting grid coordinates of the specified line (X1, Y1) - (X2, Y2).
    /// </summary>
    internal static void GetGridExtent(int X1, int Y1, int X2, int Y2, out int MinX, out int MaxX, out int MinY, out int MaxY)
    {
        if (X1 > X2)
        {
            MaxX = X1;
            MinX = X2;
        }
        else
        {
            MaxX = X2;
            MinX = X1;
        }
        if (Y2 > Y1)
        {
            MaxY = Y2;
            MinY = Y1;
        }
        else
        {
            MaxY = Y1;
            MinY = Y2;
        }
        MinX = (MinX + GridOffset) >> 8;
        MaxX = (MaxX + GridOffset) >> 8;
        MinY = (MinY + GridOffset) >> 8;
        MaxY = (MaxY + GridOffset) >> 8;
    }
    /// <summary>
    /// Function <c>PreProcessMapData</c> caches some structures of the MapDefinition and stores 3D floors information.
    /// </summary>
    internal void PreProcessMapData()
    {
        SectorLines.Clear();
        GridLinedef.Clear();
        GridNavMeshLine.Clear();
        MapSectors3D.Clear();
        foreach (TMapSector MapSector in MapDefinition.MapSector)
        {
            // Ignore the doors that close after 30 seconds after level start.
            if (MapSector.Special == 10)
                MapSector.Ignored = true;
            if (MapSector.Ignored)
                continue;
            SectorLines.Add(MapSector.Index, new List<Int32>());
        }
        foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
        {
            if (MapLinedef.SideFront >= 0)
            {
                int SideSector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                if (SectorLines.TryGetValue(SideSector, out List<Int32>? Value))
                    Value.Add(MapLinedef.Index);
                // Process the 3D sectors.
                if (CheckLinedef3D(MapLinedef))
                    MapSectors3D.Add(new TMapSector3D(MapLinedef, MapDefinition.MapSector[SideSector]));
            }
            if (MapLinedef.SideBack >= 0)
            {
                int SideSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                if (SectorLines.TryGetValue(SideSector, out List<Int32>? Value))
                    Value.Add(MapLinedef.Index);
            }
            GetGridExtent(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y, MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y, out int MinX, out int MaxX, out int MinY, out int MaxY);
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    GridLinedef.Add(X, Y, MapLinedef.Index);
        }
    }
    /// <summary>
    /// Function <c>ProcessPolygonMesh</c> adds a mesh to the navigation mesh.
    /// </summary>
    /// <param name="Polygon"><c>Polygon</c> is the mesh to be added.</param>
    internal void ProcessPolygonMesh(TNavMeshPolygon Polygon)
    {
        // Check for portals.
        SortedList<int, int> Lines = new SortedList<int, int>();
        foreach (TNavMeshLine Line in Polygon.Lines)
        {
            // Search for the map LINEDEF, using the cached grid.
            Lines.Clear();
            GetGridExtent(Line.A.X, Line.A.Y, Line.B.X, Line.B.Y, out int MinX, out int MaxX, out int MinY, out int MaxY);
            GridLinedef.Fill(MinX, MaxX, MinY, MaxY, Lines);
            bool NotFound = true;
            int MapLinedefIndex = 0;
            while ((NotFound) && (MapLinedefIndex < Lines.Count))
            {
                TMapVertex V1 = MapDefinition.MapVertex[MapDefinition.MapLinedef[Lines.Keys[MapLinedefIndex]].V1];
                TMapVertex V2 = MapDefinition.MapVertex[MapDefinition.MapLinedef[Lines.Keys[MapLinedefIndex]].V2];
                if (((Line.A.X == V1.X) && (Line.A.Y == V1.Y) && (Line.B.X == V2.X) && (Line.B.Y == V2.Y))
                || ((Line.A.X == V2.X) && (Line.A.Y == V2.Y) && (Line.B.X == V1.X) && (Line.B.Y == V1.Y)))
                    NotFound = false;
                else
                    MapLinedefIndex++;
            }
            if (!NotFound)
                Line.MapLinedef = Lines.Keys[MapLinedefIndex];
            // Check for portals.
            Lines.Clear();
            GridNavMeshLine.Fill(MinX, MaxX, MinY, MaxY, Lines);
            for (int Index = 0; Index < Lines.Count; Index++)
            {
                int I = Lines.Keys[Index];
                int CurrentPolygonIndex = 0;
                int CurrentPolygonStartLine = 0;
                bool PolygonNotFound = true;
                do
                {
                    int NextPolygonStart = CurrentPolygonStartLine + NavMeshPolygons[CurrentPolygonIndex].LineCount;
                    if (NextPolygonStart > I)
                        PolygonNotFound = false;
                    else
                    {
                        CurrentPolygonStartLine = NextPolygonStart;
                        CurrentPolygonIndex++;
                    }
                } while ((PolygonNotFound) && (CurrentPolygonIndex < NavMeshPolygons.Count));
                if (((Line.A == NavMeshLines[I].A) && (Line.B == NavMeshLines[I].B)) || ((Line.A == NavMeshLines[I].B) && (Line.B == NavMeshLines[I].A)))
                {
                    bool LineIsPortal = true;
                    // Check if the two floor heights are too different.
                    if (Math.Abs(Polygon.HeightFloor - NavMeshPolygons[CurrentPolygonIndex].HeightFloor) > 24)
                        LineIsPortal = false;
                    // Check if there is enough vertical space between the two connecting sectors.
                    if (Math.Min(Polygon.HeightCeiling, NavMeshPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, NavMeshPolygons[CurrentPolygonIndex].HeightFloor) < ActorHeight)
                        LineIsPortal = false;
                    if (Line.MapLinedef >= 0)
                    {
                        // Check if the LINEDEF blocks monsters.
                        TMapLinedef MapLinedef = MapDefinition.MapLinedef[Line.MapLinedef];
                        if ((MapLinedef.Blocking) || (MapLinedef.SideFront < 0) || (MapLinedef.SideBack < 0) || (MapLinedef.Ignored))
                            LineIsPortal = false;
                    }
                    if (LineIsPortal)
                    {
                        Line.Portal = CurrentPolygonIndex;
                        NavMeshLines[I].Portal = NavMeshPolygons.Count;
                    }
                }
            }
        }
        // Add the polygon.
        Polygon.LineFirst = NavMeshLines.Count;
        Polygon.LineCount = Polygon.Lines.Count;
        NavMeshPolygons.Add(Polygon);
        // Add the lines.
        foreach (TNavMeshLine Line in Polygon.Lines)
        {
            GetGridExtent(Line.A.X, Line.A.Y, Line.B.X, Line.B.Y, out int MinX, out int MaxX, out int MinY, out int MaxY);
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    GridNavMeshLine.Add(X, Y, NavMeshLines.Count);
            NavMeshLines.Add(Line);
        }
    }
    /// <summary>
    /// Function <c>ProcessPolygons</c> processes a closed region of a SECTOR.
    /// </summary>
    /// <param name="MapSector"><c>MapSector</c> references the SECTOR.</param>
    /// <param name="Polygon"><c>Polygon</c> is the outer perimeter of the polygon.</param>
    /// <param name="Holes"><c>Holes</c> is the list of the internal holes.</param>
    /// <param name="PolyhedronCeilings"><c>PolyhedronCeilings</c> contains the list of polyhedron ceilings.</param>
    /// <param name="PolyhedronFloors"><c>PolyhedronFloors</c> contains the list of polyhedron ceilings.</param>
    internal void ProcessPolygons(TMapSector MapSector, TPolygon Polygon, List<TPolygon> Holes, List<int> PolyhedronCeilings, List<int> PolyhedronFloors)
    {
        List<TPolygon> Polygons = new List<TPolygon>();
        if (TPartition.RemoveHoles(Polygon, Holes))
        {
            if (TPartition.ConvexPartition_HM(Polygon, Polygons))
            {
                foreach (TPolygon SplitPolygon in Polygons)
                {
                    for (int PolyhedronIndex = 0; PolyhedronIndex < PolyhedronCeilings.Count; PolyhedronIndex++)
                    {
                        TNavMeshPolygon NavMeshPolygon = new TNavMeshPolygon();
                        NavMeshPolygon.HeightFloor = PolyhedronFloors[PolyhedronIndex];
                        NavMeshPolygon.HeightCeiling = PolyhedronCeilings[PolyhedronIndex];
                        NavMeshPolygon.MapSector = MapSector.Index;
                        for (int I = 0; I < SplitPolygon.Points.Count; I++)
                        {
                            int J = (I + 1) % SplitPolygon.Points.Count;
                            NavMeshPolygon.Lines.Add(
                                new TNavMeshLine(
                                    new TNavMeshPoint(SplitPolygon.Points[I].X, SplitPolygon.Points[I].Y),
                                    new TNavMeshPoint(SplitPolygon.Points[J].X, SplitPolygon.Points[J].Y)
                                )
                            );
                        }
                        ProcessPolygonMesh(NavMeshPolygon);
                    }
                }
            }
            else
                Messages.Add($"Map SECTOR # {MapSector.Index} could not be processed.");
        }
        else
            Messages.Add($"Map SECTOR # {MapSector.Index} has holes, that could not be processed.");
    }
    /// <summary>
    /// Function <c>ProcessSector</c> process an entire SECTOR.
    /// </summary>
    /// <param name="MapSector"><c>MapSector</c> references the SECTOR.</param>
    /// <param name="VertexBegin"><c>VertexBegin</c> containes the beginning VERTEX of the LINEDEFs of the SECTOR.</param>
    /// <param name="VertexEnd"><c>VertexBegin</c> containes the ending VERTEX of the LINEDEFs of the SECTOR.</param>
    /// <param name="PolyhedronCeilings"><c>PolyhedronCeilings</c> contains the list of polyhedron ceilings.</param>
    /// <param name="PolyhedronFloors"><c>PolyhedronFloors</c> contains the list of polyhedron ceilings.</param>
    /// <returns><c>True</c> if the process is completed successfully.</returns>
    internal bool ProcessSector(TMapSector MapSector, List<int> VertexBegin, List<int> VertexEnd, List<int> PolyhedronCeilings, List<int> PolyhedronFloors)
    {
        // If the SECTOR has less than 3 LINEDEF, then it's scrapped.
        if (VertexBegin.Count < 3)
            return false;
        List<TPolygon> Polygons = new List<TPolygon>();
        const short MaxStack = 128;
        short I, J;
        bool NotFound, HasMoreIterations, AllPointsVisited;
        short PointCount;
        int[] Points = new int[VertexBegin.Count * 2];
        short LineCount;
        short[] LinesA = new short[VertexBegin.Count];
        short[] LinesB = new short[VertexBegin.Count];
        // Build the Points and Lines array.
        PointCount = 0;
        LineCount = 0;
        for (I = 0; I < VertexBegin.Count; I++)
        {
            NotFound = true;
            J = 0;
            while ((NotFound) && (J < PointCount))
                if (Points[J] == VertexBegin[I])
                    NotFound = false;
                else
                    J++;
            if (NotFound)
            {
                Points[PointCount] = VertexBegin[I];
                LinesA[LineCount] = PointCount;
                PointCount++;
            }
            else
                LinesA[LineCount] = J;
            NotFound = true;
            J = 0;
            while ((NotFound) && (J < PointCount))
                if (Points[J] == VertexEnd[I])
                    NotFound = false;
                else
                    J++;
            if (NotFound)
            {
                Points[PointCount] = VertexEnd[I];
                LinesB[LineCount] = PointCount;
                PointCount++;
            }
            else
                LinesB[LineCount] = J;
            LineCount++;
        }
        // Array of point cardinality.
        short[] PointCardinality = new short[PointCount * 2];
        // Arrays of open points and lines.
        bool[] OpenPoints = new bool[PointCount];
        bool[] OpenLines = new bool[LineCount];
        // Queue of points.
        short[] PointQueue = new short[PointCount];
        short PointQueueHead;
        short PointQueueTail;
        // Stack of meshes.
        short[,] MeshStackPoints = new short[MaxStack, PointCount * 4];
        short[] MeshStackCount = new short[MaxStack];
        short MeshStackTOS;
        // General purpose point index variables.
        short CurrentPoint, FirstPoint, NextPoint, OtherPoint, PreviousPoint, TestPoint;
        // General purpose line index variables.
        short NextLine = 0, InfiniteLoopLine = -1;
        // General purpose distance variables.
        int NextDifference, TestDifference;
        // General purpose angle variables.
        double NextAngle, PreviousAngle, TestAngle;
        // Outer perimeter variables.
        short[] OuterPerimeterPoints = new short[PointCount];
        short OuterPerimeterPointCount, OuterPerimeterPointStart;
        // Chord variables.
        short[] InnerChordPoints = new short[PointCount];
        short InnerChordPointCount, InnerChordPointLoop;
        short[] OuterChordPoints = new short[PointCount];
        short OuterChordPointCount, ChordBegin, ChordEnd;
        // Initialization.
        for (I = 0; I < PointCount; I++)
            OpenPoints[I] = true;
        for (I = 0; I < LineCount; I++)
            OpenLines[I] = true;
        Func<int, int> GetX = (int VertexIndex) => MapDefinition.MapVertex[VertexIndex].X;
        Func<int, int> GetY = (int VertexIndex) => MapDefinition.MapVertex[VertexIndex].Y;
        // Polygon splitting loop.
        do
        {
            // Find the left-most and bottom-most open point.
            FirstPoint = -1;
            for (I = 0; I < PointCount; I++)
            {
                if (OpenPoints[I])
                {
                    if (FirstPoint < 0)
                        FirstPoint = I;
                    else
                        if ((GetX(Points[I]) < GetX(Points[FirstPoint])) || ((GetX(Points[I]) == GetX(Points[FirstPoint])) && (GetY(Points[I]) < GetY(Points[FirstPoint]))))
                            FirstPoint = I;
                }
            }
            PointQueue[0] = FirstPoint;
            PointQueueHead = 0;
            PointQueueTail = 1;
            // Walk through all lines from the first point.
            while (PointQueueTail > PointQueueHead)
            {
                CurrentPoint = PointQueue[PointQueueTail - 1];
                if (PointQueueTail == 1)
                {
                    // Search the second point.
                    NextDifference = 0;
                    NextPoint = -1;
                    for (I = 0; I < LineCount; I++)
                    {
                        if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
                        {
                            if (LinesA[I] == CurrentPoint)
                                TestPoint = LinesB[I];
                            else
                                TestPoint = LinesA[I];
                            TestDifference = GetY(Points[TestPoint]) - GetY(Points[CurrentPoint]);
                            if (NextPoint < 0)
                            {
                                NextPoint = TestPoint;
                                NextDifference = TestDifference;
                                NextLine = I;
                            }
                            else
                            {
                                if (TestDifference < NextDifference)
                                {
                                    NextPoint = TestPoint;
                                    NextDifference = TestDifference;
                                    NextLine = I;
                                }
                            }
                        }
                    }
                }
                else
                {
                    PreviousPoint = PointQueue[PointQueueTail - 2];
                    PreviousAngle = Math.Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
                    // Search the next points.
                    NextPoint = -1;
                    NextAngle = 0;
                    for (I = 0; I < LineCount; I++)
                    {
                        if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint))) 
                        {
                            if (LinesA[I] == CurrentPoint)
                                TestPoint = LinesB[I];
                            else
                                TestPoint = LinesA[I];
                            if (TestPoint != PreviousPoint) 
                            {
                                TestAngle = Math.Atan2(GetY(Points[TestPoint]) - GetY(Points[CurrentPoint]), GetX(Points[TestPoint]) - GetX(Points[CurrentPoint])) - PreviousAngle;
                                if (TestAngle < -Math.PI)
                                    TestAngle += Math.PI * 2;
                                if (NextPoint < 0)
                                {
                                    NextPoint = TestPoint;
                                    NextAngle = TestAngle;
                                    NextLine = I;
                                }
                                else
                                {
                                    if (TestAngle < NextAngle)
                                    {
                                        NextPoint = TestPoint;
                                        NextAngle = TestAngle;
                                        NextLine = I;
                                    }
                                }
                            }
                        }
                    }
                }
                if (NextPoint >= 0)
                {
                    NotFound = true;
                    OuterPerimeterPointStart = PointQueueHead;
                    while ((NotFound) && (OuterPerimeterPointStart < PointQueueTail))
                        if (PointQueue[OuterPerimeterPointStart] == NextPoint)
                            NotFound = false;
                        else
                            OuterPerimeterPointStart++;
                    if (NotFound)
                    {
                        PointQueue[PointQueueTail] = NextPoint;
                        PointQueueTail++;
                    }
                    else
                    {
                        OuterPerimeterPointCount = 0;
                        for (I = OuterPerimeterPointStart; I < PointQueueTail; I++)
                        {
                            OuterPerimeterPoints[OuterPerimeterPointCount] = PointQueue[I];
                            OuterPerimeterPointCount++;
                        }
                        // Push the outer perimeter on the stack.
                        MeshStackTOS = 0;
                        MeshStackCount[MeshStackTOS] = OuterPerimeterPointCount;
                        for (I = 0; I < OuterPerimeterPointCount; I++)
                            MeshStackPoints[MeshStackTOS, I] = OuterPerimeterPoints[I];
                        while (MeshStackTOS >= 0)
                        {
                            // Calculate the point cardinality.
                            for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
                                PointCardinality[I] = 2; // The default previous and next lines attached to each point.
                            for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
                            {
                                CurrentPoint = MeshStackPoints[MeshStackTOS, I];
                                NextPoint = MeshStackPoints[MeshStackTOS, (I + 1) % MeshStackCount[MeshStackTOS]];
                                PreviousPoint = MeshStackPoints[MeshStackTOS, (I + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
                                for (J = 0; J < LineCount; J++)
                                {
                                    if (((LinesA[J] == CurrentPoint) && (LinesB[J] != NextPoint) && (LinesB[J] != PreviousPoint)) || ((LinesB[J] == CurrentPoint) && (LinesA[J] != NextPoint) && (LinesA[J] != PreviousPoint)))
                                    {
                                        if (LinesA[J] == CurrentPoint)
                                            TestPoint = LinesB[J];
                                        else
                                            TestPoint = LinesA[J];
                                        if (TPartition.InCone(GetX(Points[PreviousPoint]), GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]), GetY(Points[CurrentPoint]), GetX(Points[NextPoint]), GetY(Points[NextPoint]), GetX(Points[TestPoint]), GetY(Points[TestPoint])))
                                            PointCardinality[I]++;
                                    }
                                }
                            }
                            // Search the left-most and bottom-most point of cardinality greather than 2, if exists.
                            InnerChordPointLoop = -1;
                            FirstPoint = -1;
                            for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
                            {
                                if (PointCardinality[I] > 2)
                                {
                                    TestPoint = MeshStackPoints[MeshStackTOS, I];
                                    if (FirstPoint < 0)
                                    {
                                        FirstPoint = TestPoint;
                                    }
                                    else
                                    {
                                        if ((GetX(Points[TestPoint]) < GetX(Points[FirstPoint])) || ((GetX(Points[TestPoint]) == GetX(Points[FirstPoint])) && (GetY(Points[TestPoint]) < GetY(Points[FirstPoint]))))
                                            FirstPoint = TestPoint;
                                    }
                                }
                            }
                            if (FirstPoint >= 0)
                            {
                                InnerChordPoints[0] = FirstPoint;
                                InnerChordPointCount = 1;
                                HasMoreIterations = true;
                                while (HasMoreIterations)
                                {
                                    CurrentPoint = InnerChordPoints[InnerChordPointCount - 1];
                                    if (InnerChordPointCount == 1)
                                    {
                                        NotFound = true;
                                        I = 0;
                                        while ((NotFound) && (I < MeshStackCount[MeshStackTOS]))
                                            if (MeshStackPoints[MeshStackTOS, I] == FirstPoint)
                                                NotFound = false;
                                            else
                                                I++;
                                        OtherPoint = MeshStackPoints[MeshStackTOS, (I + 1) % MeshStackCount[MeshStackTOS]];
                                        PreviousPoint = MeshStackPoints[MeshStackTOS, (I + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
                                        PreviousAngle = Math.Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
                                        NextAngle = Math.Atan2(GetY(Points[OtherPoint]) - GetY(Points[CurrentPoint]), GetX(Points[OtherPoint]) - GetX(Points[CurrentPoint]));
                                        NextPoint = -1;
                                        for (I = 0; I < LineCount; I++)
                                        {
                                            if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
                                            {
                                                if (LinesA[I] == CurrentPoint)
                                                    TestPoint = LinesB[I];
                                                else
                                                    TestPoint = LinesA[I];
                                                if ((TestPoint != PreviousPoint) && (TestPoint != OtherPoint) && (TPartition.InCone(GetX(Points[PreviousPoint]), GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]), GetY(Points[CurrentPoint]), GetX(Points[OtherPoint]), GetY(Points[OtherPoint]), GetX(Points[TestPoint]), GetY(Points[TestPoint]))))
                                                {
                                                    TestAngle = Math.Atan2(GetY(Points[TestPoint]) - GetY(Points[FirstPoint]), GetX(Points[TestPoint]) - GetX(Points[FirstPoint])) - PreviousAngle;
                                                    if (TestAngle < -Math.PI)
                                                        TestAngle += Math.PI * 2;
                                                    if (NextPoint < 0)
                                                    {
                                                        NextPoint = TestPoint;
                                                        NextAngle = TestAngle;
                                                        NextLine = I;
                                                    }
                                                    else
                                                    {
                                                        if (TestAngle < NextAngle)
                                                        {
                                                            NextPoint = TestPoint;
                                                            NextAngle = TestAngle;
                                                            NextLine = I;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        PreviousPoint = InnerChordPoints[InnerChordPointCount - 2];
                                        PreviousAngle = Math.Atan2(GetY(Points[CurrentPoint]) - GetY(Points[PreviousPoint]), GetX(Points[CurrentPoint]) - GetX(Points[PreviousPoint]));
                                        NextPoint = -1;
                                        NextAngle = 0;
                                        for (I = 0; I < LineCount; I++)
                                        {
                                            if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
                                            {
                                                if (LinesA[I] == CurrentPoint)
                                                    TestPoint = LinesB[I];
                                                else
                                                    TestPoint = LinesA[I];
                                                if (TestPoint != PreviousPoint)
                                                {
                                                    TestAngle = Math.Atan2(GetY(Points[TestPoint]) - GetY(Points[FirstPoint]), GetX(Points[TestPoint]) - GetX(Points[FirstPoint])) - PreviousAngle;
                                                    if (TestAngle < -Math.PI)
                                                        TestAngle += Math.PI * 2;
                                                    if (NextPoint < 0)
                                                    {
                                                        NextPoint = TestPoint;
                                                        NextAngle = TestAngle;
                                                        NextLine = I;
                                                    }
                                                    else
                                                    {
                                                        if (TestAngle < NextAngle)
                                                        {
                                                            NextPoint = TestPoint;
                                                            NextAngle = TestAngle;
                                                            NextLine = I;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    if (NextPoint >= 0)
                                    {
                                        OpenLines[NextLine] = false;
                                        InnerChordPoints[InnerChordPointCount] = NextPoint;
                                        InnerChordPointCount++;
                                        NotFound = true;
                                        I = 0;
                                        while ((NotFound) && (I < MeshStackCount[MeshStackTOS]))
                                            if (MeshStackPoints[MeshStackTOS, I] == NextPoint)
                                                NotFound = false;
                                            else
                                                I++;
                                        if (NotFound)
                                        {
                                            NotFound = true;
                                            I = 1;
                                            while ((NotFound) && (I < InnerChordPointCount - 1))
                                                if (InnerChordPoints[I] == NextPoint)
                                                    NotFound = false;
                                                else
                                                    I++;
                                            if (NotFound)
                                                OpenPoints[NextPoint] = false;
                                            else
                                            {
                                                InnerChordPointLoop = I;
                                                HasMoreIterations = false;
                                            }
                                        }
                                        else
                                        {
                                            HasMoreIterations = false;
                                        }
                                    }
                                    else
                                    {
                                        if (NextLine == InfiniteLoopLine)
                                            return false; // Bad SECTOR lines.
                                        OpenLines[NextLine] = false;
                                        InfiniteLoopLine = NextLine;
                                        AllPointsVisited = true;
                                        for (I = 0; I < LineCount; I++)
                                            if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
                                                AllPointsVisited = false;
                                        if (AllPointsVisited)
                                        {
                                            OpenPoints[CurrentPoint] = false;
                                            InnerChordPointCount++;
                                        }
                                        if (InnerChordPointCount == 0)
                                            HasMoreIterations = false;
                                    }
                                }
                                if (InnerChordPointCount > 0) 
                                {
                                    if (InnerChordPointLoop > 0)
                                    {
                                        return false; // I need more study and work to finish this part.
                                    }
                                    else
                                    {
                                        ChordBegin = 0;
                                        while (MeshStackPoints[MeshStackTOS, ChordBegin] != InnerChordPoints[0])
                                            ChordBegin++;
                                        PreviousPoint = MeshStackPoints[MeshStackTOS, (ChordBegin + MeshStackCount[MeshStackTOS] - 1) % MeshStackCount[MeshStackTOS]];
                                        ChordEnd = (short)(MeshStackCount[MeshStackTOS] - 1);
                                        while (MeshStackPoints[MeshStackTOS, ChordEnd] != InnerChordPoints[InnerChordPointCount - 1])
                                            ChordEnd--;
                                        NextPoint = MeshStackPoints[MeshStackTOS, (ChordEnd + 1) % MeshStackCount[MeshStackTOS]];
                                        OuterChordPointCount = (short)(ChordEnd - ChordBegin + 1);
                                        if (OuterChordPointCount < 0)
                                        {
                                            OuterChordPointCount = (short)(OuterChordPointCount + MeshStackCount[MeshStackTOS]);
                                            for (I = ChordBegin; I <= ChordEnd + MeshStackCount[MeshStackTOS]; I++)
                                                OuterChordPoints[I - ChordBegin] = MeshStackPoints[MeshStackTOS, I % MeshStackCount[MeshStackTOS]];
                                        }
                                        else
                                        {
                                            for (I = ChordBegin; I <= ChordEnd; I++)
                                                OuterChordPoints[I - ChordBegin] = MeshStackPoints[MeshStackTOS, I];
                                        }
                                        if (InnerChordPointCount > OuterChordPointCount)
                                        {
                                            MeshStackCount[MeshStackTOS] = (short)(MeshStackCount[MeshStackTOS] - OuterChordPointCount + InnerChordPointCount);
                                            for (I = (short)(MeshStackCount[MeshStackTOS] - 1); I >= ChordEnd; I--)
                                                MeshStackPoints[MeshStackTOS, I + InnerChordPointCount - OuterChordPointCount] = MeshStackPoints[MeshStackTOS, I];
                                        }
                                        else if (InnerChordPointCount < OuterChordPointCount)
                                        {
                                            MeshStackCount[MeshStackTOS] = (short)(MeshStackCount[MeshStackTOS] - OuterChordPointCount + InnerChordPointCount);
                                            if (ChordBegin > ChordEnd)
                                                for (I = ChordEnd; I <= ChordBegin; I++)
                                                    MeshStackPoints[MeshStackTOS, I - ChordEnd] = MeshStackPoints[MeshStackTOS, I];
                                            else
                                                for (I = (short)(ChordBegin + 1); I < MeshStackCount[MeshStackTOS]; I++)
                                                    MeshStackPoints[MeshStackTOS, I] = MeshStackPoints[MeshStackTOS, I + OuterChordPointCount - InnerChordPointCount];
                                        }
                                        for (I = 1; I < InnerChordPointCount - 1; I++)
                                            MeshStackPoints[MeshStackTOS, (ChordBegin + I - 1) % MeshStackCount[MeshStackTOS]] = InnerChordPoints[I];
                                        MeshStackTOS++;
                                        MeshStackCount[MeshStackTOS] = (short)(InnerChordPointCount + OuterChordPointCount - 2);
                                        TestAngle = Math.Atan2(GetY(Points[NextPoint]) - GetY(Points[InnerChordPoints[InnerChordPointCount - 1]]), GetX(Points[NextPoint]) - GetX(Points[InnerChordPoints[InnerChordPointCount - 1]]));
                                        if (TestAngle < 0)
                                        {
                                            for (I = 0; I < OuterChordPointCount; I++)
                                                MeshStackPoints[MeshStackTOS, I] = OuterChordPoints[I];
                                            for (I = 1; I < InnerChordPointCount - 1; I++)
                                                MeshStackPoints[MeshStackTOS, OuterChordPointCount + I - 1] = InnerChordPoints[InnerChordPointCount - I - 1];
                                        }
                                        else
                                        {
                                            for (I = 0; I < InnerChordPointCount; I++)
                                                MeshStackPoints[MeshStackTOS, I] = InnerChordPoints[InnerChordPointCount - I - 1];
                                            for (I = 1; I < OuterChordPointCount - 1; I++)
                                                MeshStackPoints[MeshStackTOS, InnerChordPointCount + I - 1] = OuterChordPoints[I];
                                        }
                                    }
                                }
                                else 
                                {
                                    return false; // I need more study and work to finish this part.
                                }
                            }
                            else 
                            {
                                TPolygon Polygon = new TPolygon();
                                for (I = 0; I < MeshStackCount[MeshStackTOS]; I++)
                                    Polygon.Points.Add(new TPoint(GetX(Points[MeshStackPoints[MeshStackTOS, I]]), GetY(Points[MeshStackPoints[MeshStackTOS, I]])));
                                Polygons.Add(Polygon);
                                MeshStackTOS--;
                            }
                        }
                        for (J = OuterPerimeterPointStart; J <= PointQueueTail; J++)
                            for (I = 0; I < LineCount; I++)
                                if (((LinesA[I] == OuterPerimeterPoints[(J + OuterPerimeterPointCount - 1) % OuterPerimeterPointCount]) && (LinesB[I] == OuterPerimeterPoints[J % OuterPerimeterPointCount])) || ((LinesA[I] == OuterPerimeterPoints[J % OuterPerimeterPointCount]) && (LinesB[I] == OuterPerimeterPoints[(J + OuterPerimeterPointCount - 1) % OuterPerimeterPointCount])))
                                    OpenLines[I] = false;
                        for (J = 0; J < OuterPerimeterPointCount; J++)
                        {
                            AllPointsVisited = true;
                            for (I = 0; I < LineCount; I++)
                                if ((OpenLines[I]) && ((LinesA[I] == OuterPerimeterPoints[J]) || (LinesB[I] == OuterPerimeterPoints[J])))
                                    AllPointsVisited = false;
                            if (AllPointsVisited)
                                OpenPoints[OuterPerimeterPoints[J]] = false;
                        }
                        PointQueueTail = OuterPerimeterPointStart;
                    }
                }
                else
                {
                    if (NextLine == InfiniteLoopLine)
                        return false; // Bad SECTOR lines.
                    OpenLines[NextLine] = false;
                    InfiniteLoopLine = NextLine;
                    AllPointsVisited = true;
                    for (I = 0; I < LineCount; I++)
                        if ((OpenLines[I]) && ((LinesA[I] == CurrentPoint) || (LinesB[I] == CurrentPoint)))
                        {
                            AllPointsVisited = false;
                            break;
                        }
                    if (AllPointsVisited)
                    {
                        OpenPoints[CurrentPoint] = false;
                        PointQueueTail--;
                    } 
                }
            }
            // Check if all points are closed.
            AllPointsVisited = true;
            for (I = 0; I < PointCount; I++)
                if (OpenPoints[I])
                {
                    AllPointsVisited = false;
                    break;
                }
        } while (!AllPointsVisited);
        if (Polygons.Count == 0)
            return false;
        List<TPolygon> Holes = new List<TPolygon>();
        if (Polygons.Count == 1)
        {
            // Only one closed region.
            Polygons[0].Hole = false;
            ProcessPolygons(MapSector, Polygons[0], Holes, PolyhedronCeilings, PolyhedronFloors);
        }
        else
        {
            // Multiple closed regions: check the holes and nested regions.
            int[] PolygonDepthLevel = new int[Polygons.Count];
            int MaxDepthLevel = 0;
            for (I = 0; I < Polygons.Count; I++)
                PolygonDepthLevel[I] = 0;
            for (I = 0; I < Polygons.Count; I++)
                for (J = 0; J < Polygons.Count; J++)
                    if (I != J)
                        if (PolygonInsidePolygon(Polygons[I], Polygons[J]))
                        {
                            PolygonDepthLevel[J]++;
                            if (PolygonDepthLevel[J] > MaxDepthLevel)
                                MaxDepthLevel = PolygonDepthLevel[J];
                        }
            for (int DepthLevel = 0; DepthLevel <= MaxDepthLevel; DepthLevel += 2)
                for (I = 0; I < Polygons.Count; I++)
                    if (PolygonDepthLevel[I] == DepthLevel)
                    {
                        Holes.Clear();
                        for (J = 0; J < Polygons.Count; J++)
                            if ((PolygonDepthLevel[J] == (PolygonDepthLevel[I] + 1)) && (PolygonInsidePolygon(Polygons[I], Polygons[J])))
                            {
                                Polygons[J].Hole = true;
                                Holes.Add(Polygons[J]);
                            }
                        Polygons[I].Hole = false;
                        ProcessPolygons(MapSector, Polygons[I], Holes, PolyhedronCeilings, PolyhedronFloors);
                    }
        }
        return true;
    }
    /// <summary>
    /// Function <c>ProcessMapData</c> processes the map lines and sectors into convex polygons.
    /// </summary>
    internal void ProcessMapData()
    {
        List<int> PlaneCeilings = new List<int>();
        List<int> PlaneFloors = new List<int>();
        List<int> PolyhedronCeilings = new List<int>();
        List<int> PolyhedronFloors = new List<int>();
        List<int> VertexBegin = new List<int>();
        List<int> VertexEnd = new List<int>();
        foreach (TMapSector MapSector in MapDefinition.MapSector)
        {
            if (MapSector.Ignored)
                continue;
            if ((MapSector.HeightCeiling - MapSector.HeightFloor) < ActorHeight)
                continue;
            // Get the 3D sectors.
            PlaneCeilings.Clear();
            PlaneFloors.Clear();
            foreach (TMapSector3D MapSector3D in MapSectors3D)
            {
                if (MapSector.ID == MapSector3D.SectorTag)
                {
                    PlaneCeilings.Add(MapSector3D.ControlSector.HeightCeiling);
                    PlaneFloors.Add(MapSector3D.ControlSector.HeightFloor);
                }
            }
            // Sort the 3D sectors.
            for (int I = 0; I < PlaneCeilings.Count - 1; I++) 
                for (int J = I + 1; J < PlaneCeilings.Count; J++)
                    if (PlaneCeilings[I] > PlaneCeilings[J])
                    {
                        (PlaneCeilings[J], PlaneCeilings[I]) = (PlaneCeilings[I], PlaneCeilings[J]);
                        (PlaneFloors[J], PlaneFloors[I]) = (PlaneFloors[I], PlaneFloors[J]);
                    }
            PolyhedronCeilings.Clear();
            PolyhedronFloors.Clear();
            if (PlaneCeilings.Count > 0)
            {
                int StartFloor = MapSector.HeightFloor;
                for (int I = 0; I < PlaneFloors.Count; I++)
                {
                    if ((PlaneFloors[I] - StartFloor) > ActorHeight)
                    {
                        PolyhedronCeilings.Add(PlaneFloors[I]);
                        PolyhedronFloors.Add(StartFloor);
                    }
                    StartFloor = PlaneCeilings[I];
                }
                if ((MapSector.HeightCeiling - StartFloor) > ActorHeight)
                {
                    PolyhedronCeilings.Add(MapSector.HeightCeiling);
                    PolyhedronFloors.Add(StartFloor);
                }
            }
            else
            {
                PolyhedronCeilings.Add(MapSector.HeightCeiling);
                PolyhedronFloors.Add(MapSector.HeightFloor);
            }
            VertexBegin.Clear();
            VertexEnd.Clear();
            // Get the LINEDEFs using the cache.
            if (SectorLines.TryGetValue(MapSector.Index, out List<Int32>? CachedLines))
            {
                foreach (Int32 MapLinedefIndex in CachedLines)
                {
                    int FrontSector = -1;
                    if (MapDefinition.MapLinedef[MapLinedefIndex].SideFront >= 0)
                        FrontSector = MapDefinition.MapSidedef[MapDefinition.MapLinedef[MapLinedefIndex].SideFront].Sector;
                    int BackSector = -2;
                    if (MapDefinition.MapLinedef[MapLinedefIndex].SideBack >= 0)
                        BackSector = MapDefinition.MapSidedef[MapDefinition.MapLinedef[MapLinedefIndex].SideBack].Sector;
                    if (FrontSector == BackSector)
                        continue;
                    if (FrontSector == MapSector.Index)
                    {
                        VertexBegin.Add(MapDefinition.MapLinedef[MapLinedefIndex].V1);
                        VertexEnd.Add(MapDefinition.MapLinedef[MapLinedefIndex].V2);
                    }
                    else
                    {
                        VertexBegin.Add(MapDefinition.MapLinedef[MapLinedefIndex].V2);
                        VertexEnd.Add(MapDefinition.MapLinedef[MapLinedefIndex].V1);
                    }
                }
            }
            else
                continue;
            if (VertexBegin.Count < 3)
            {
                Messages.Add($"Map SECTOR # {MapSector.Index} has less than 3 LINEDEFs.");
                continue;
            }
            if (!ProcessSector(MapSector, VertexBegin, VertexEnd, PolyhedronCeilings, PolyhedronFloors))
                Messages.Add($"Map SECTOR # {MapSector.Index} could not be split into regions.");
        }
    }
    /// <summary>
    /// Function <c>ProcessCells</c> builds the cell space partitioning system of the navigation mesh.
    /// </summary>
    internal void ProcessCells()
    {
        int MaxX = Int32.MinValue;
        int MaxY = Int32.MinValue;
        int MinX = Int32.MaxValue;
        int MinY = Int32.MaxValue;
        foreach (TNavMeshLine Line in NavMeshLines)
        {
            if (Line.A.X > MaxX)
                MaxX = Line.A.X;
            if (Line.A.Y > MaxY)
                MaxY = Line.A.Y;
            if (Line.B.X > MaxX)
                MaxX = Line.B.X;
            if (Line.B.Y > MaxY)
                MaxY = Line.B.Y;
            if (Line.A.X < MinX)
                MinX = Line.A.X;
            if (Line.A.Y < MinY)
                MinY = Line.A.Y;
            if (Line.B.X < MinX)
                MinX = Line.B.X;
            if (Line.B.Y < MinY)
                MinY = Line.B.Y;
        }
        OffsetCellX = (MinX + GridOffset) >> 8;
        OffsetCellY = (MinY + GridOffset) >> 8;
        int LastCellX = (MaxX + GridOffset) >> 8;
        int LastCellY = (MaxY + GridOffset) >> 8;
        NumCellX = LastCellX - OffsetCellX + 1;
        NumCellY = LastCellY - OffsetCellY + 1;
        Cells = new List<Int32>[NumCellY, NumCellX];
        for (int Y = 0; Y < NumCellY; Y++)
            for (int X = 0; X < NumCellX; X++)
                Cells[Y, X] = new List<Int32>();
        for (int PolygonIndex = 0; PolygonIndex < NavMeshPolygons.Count; PolygonIndex++)
        {
            MaxX = Int32.MinValue;
            MaxY = Int32.MinValue;
            MinX = Int32.MaxValue;
            MinY = Int32.MaxValue;
            foreach (TNavMeshLine Line in NavMeshPolygons[PolygonIndex].Lines)
            {
                if (Line.A.X > MaxX)
                    MaxX = Line.A.X;
                if (Line.A.Y > MaxY)
                    MaxY = Line.A.Y;
                if (Line.B.X > MaxX)
                    MaxX = Line.B.X;
                if (Line.B.Y > MaxY)
                    MaxY = Line.B.Y;
                if (Line.A.X < MinX)
                    MinX = Line.A.X;
                if (Line.A.Y < MinY)
                    MinY = Line.A.Y;
                if (Line.B.X < MinX)
                    MinX = Line.B.X;
                if (Line.B.Y < MinY)
                    MinY = Line.B.Y;
            }
            MinX = (MinX + GridOffset) >> 8;
            MinY = (MinY + GridOffset) >> 8;
            MaxX = (MaxX + GridOffset) >> 8;
            MaxY = (MaxY + GridOffset) >> 8;
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    Cells[Y - OffsetCellY, X - OffsetCellX].Add(PolygonIndex);
        }
    }
    /// <summary>
    /// Function <c>Build</c> produces a NavMesh with the specified map and settings.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map being processed.</param>
    public void Build(int ActorHeight, int ActorRadius)
    {
        this.ActorHeight = ActorHeight;
        this.ActorRadius = ActorRadius;
        // Performs some filtering.
        PreProcessMapData();
        // Process the map data.
        ProcessMapData();
        // Final processing.
        ProcessCells();
    }
    /// <summary>
    /// Function <c>ToString</c> returns the NavMesh in plain text format.
    /// </summary>
    /// <returns>A string that contains the NavMesh in plain text format.</returns>
    public override string ToString()
    {
        StringBuilder SB = new StringBuilder();
        SB.AppendLine("# ZDOOMNAVMESH");
        SB.AppendLine();
        SB.AppendLine("# lines");
        for (int I = 0; I < NavMeshLines.Count; I++)
            SB.AppendFormat("l {0} {1} {2} {3} {4} {5}", NavMeshLines[I].A.X, NavMeshLines[I].A.Y, NavMeshLines[I].B.X, NavMeshLines[I].B.Y, NavMeshLines[I].Portal, NavMeshLines[I].MapLinedef).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# polygons");
        for (int I = 0; I < NavMeshPolygons.Count; I++)
            SB.AppendFormat("p {0} {1} {2} {3} {4}", NavMeshPolygons[I].HeightFloor, NavMeshPolygons[I].HeightCeiling, NavMeshPolygons[I].LineFirst, NavMeshPolygons[I].LineCount, NavMeshPolygons[I].MapSector).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# cells space partitioning");
        SB.AppendFormat("o {0} {1} {2} {3}", OffsetCellX, OffsetCellY, NumCellX, NumCellY).AppendLine();
        for (int Y = 0; Y < NumCellY; Y++)
            for (int X = 0; X < NumCellX; X++)
                if (Cells![Y, X].Count > 0)
                {
                    SB.AppendFormat("c {0}", Y * NumCellX + X);
                    foreach (Int32 PolygonIndex in Cells[Y, X])
                        SB.AppendFormat(" {0}", PolygonIndex);
                    SB.AppendLine();
                }
        return SB.ToString();
    }
}
