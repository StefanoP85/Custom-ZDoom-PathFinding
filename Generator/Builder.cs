/*
 * Author: Pollazzon Stefano
 * Project: ZDoom Navmesh builder
 * This module contains the navmesh generation algorythms
 */
using System;
using System.Collections.Generic;
using System.Text;

namespace NavmeshBuilder;

/// <summary>
/// Enum <c>TOrientation</c> represents the possible ways of aligning 3 points in the 2D Euclidean space.
/// </summary>
internal enum TOrientation
{
    Clockwise = -1,
    Collinear = 0,
    CounterClockwise = 1
}
/// <summary>
/// Class <c>TNavMeshPoint</c> represents a simple point in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's very similar to the TMapVertex definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TNavMeshPoint : Object
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public int X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public int Y;
    /// <summary>
    /// Constructor <c>TNavMeshPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TNavMeshPoint(int X, int Y) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TNavMeshPoint)
            return false;
        TNavMeshPoint Other = (TNavMeshPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TNavMeshPoint A, TNavMeshPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TNavMeshPoint A, TNavMeshPoint B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TNavMeshLine</c> represents a simple line in 2D Euclidean space.
/// </summary>
/// <remarks>
/// It's similar to the TMapLinedef definition, but I needed some more specific behavior, including the equality operators.
/// </remarks>
public class TNavMeshLine : Object
{
    /// <summary>
    /// Variable <c>A</c> represents the first point of the segment.
    /// </summary>
    public TNavMeshPoint A;
    /// <summary>
    /// Variable <c>TNavMeshLine</c> represents the second point of the segment.
    /// </summary>
    public TNavMeshPoint B;
    /// <summary>
    /// Variable <c>Portal</c> is the index of the connected polygon if this line is a portal, or is -1 if this line is not a portal.
    /// </summary>
    public int Portal;
    /// <summary>
    /// Variable <c>MapLinedef</c> contains the map LINEDEF index that generated this line, or -1 if it was generated by the polygon splitting.
    /// </summary>
    public int MapLinedef;
    /// <summary>
    /// Variable <c>Flags</c> contains the flags of the line.
    /// </summary>
    public int Flags;
    /// <summary>
    /// Constructor <c>TNavMeshLine</c> constructs a line with the given points.
    /// </summary>
    public TNavMeshLine(TNavMeshPoint A, TNavMeshPoint B) : base()
    {
        this.A = A;
        this.B = B;
        Portal = -1;
        MapLinedef = -1;
        Flags = 0;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TNavMeshLine)
            return false;
        TNavMeshLine Other = (TNavMeshLine)Obj;
        return (A == Other.A) && (B == Other.B);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    public static bool operator ==(TNavMeshLine A, TNavMeshLine B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TNavMeshLine A, TNavMeshLine B)
    {
        return !(A == B);
    }
}
/// <summary>
/// Class <c>TNavMeshPolygon</c> represents a simple polygon without holes in 2D Euclidean space.
/// </summary>
public class TNavMeshPolygon : Object
{
    /// <summary>
    /// Variable <c>Lines</c> is the list of lines, that are the edges of this polygon.
    /// </summary>
    public List<TNavMeshLine> Lines;
    /// <summary>
    /// Variable <c>HeightFloor</c> is the height of the floor in the current polygon.
    /// </summary>
    public int HeightFloor;
    /// <summary>
    /// Variable <c>HeightCeiling</c> is the height of the ceiling in the current polygon.
    /// </summary>
    public int HeightCeiling;
    /// <summary>
    /// Variable <c>LineFirst</c> contains the first line of the polygon.
    /// </summary>
    public int LineFirst;
    /// <summary>
    /// Variable <c>LineCount</c> contains the number of lines.
    /// </summary>
    public int LineCount;
    /// <summary>
    /// Variable <c>MapSector</c> contains the map SECTOR index that generated this polygon.
    /// </summary>
    public int MapSector;
    /// <summary>
    /// Variable <c>Flags</c> contains the flags of the line.
    /// </summary>
    public int Flags;
    /// <summary>
    /// Constructor <c>TNavMeshPolygon</c> is the index of the map SECTOR.
    /// </summary>
    public TNavMeshPolygon() : base()
    {
        Lines = new List<TNavMeshLine>();
        LineFirst = 0;
        LineCount = 0;
        MapSector = -1;
        Flags = 0;
    }
}
/// <summary>
/// Class <c>TPoint</c> represents a point in 2D Euclidean space, but with floating point arithmetic.
/// </summary>
public class TPoint : Object, ICloneable
{
    /// <summary>
    /// Variable <c>X</c> represents the X coordinate.
    /// </summary>
    public double X;
    /// <summary>
    /// Variable <c>Y</c> represents the Y coordinate.
    /// </summary>
    public double Y;
    /// <summary>
    /// Constructor <c>TPoint</c> constructs a point with the given coordinates.
    /// </summary>
    public TPoint(double X = 0, double Y = 0) : base()
    {
        this.X = X;
        this.Y = Y;
    }
    public override bool Equals(object? Obj)
    {
        if (Obj is null)
            return false;
        if (ReferenceEquals(this, Obj))
            return true;
        if (Obj is not TPoint)
            return false;
        TPoint Other = (TPoint)Obj;
        return (X == Other.X) && (Y == Other.Y);
    }
    public override int GetHashCode()
    {
        return base.GetHashCode();
    }
    /// <summary>
    /// Function <c>Clone</c> implements the ICloneable interface.
    /// </summary>
    /// <returns>A cloned <c>TPoint</c>.</returns>
    public object Clone()
    {
        return new TPoint(X, Y);
    }
    public static bool operator ==(TPoint A, TPoint B)
    {
        if ((A is null) || (B is null))
            return false;
        return A.Equals(B);
    }
    public static bool operator !=(TPoint A, TPoint B)
    {
        return !(A == B);
    }
    public static TPoint operator +(TPoint P1, TPoint P2)
    {
        return new TPoint(P1.X + P2.X, P1.Y + P2.Y);
    }
    public static TPoint operator -(TPoint P1, TPoint P2)
    {
        return new TPoint(P1.X - P2.X, P1.Y - P2.Y);
    }
    public static TPoint operator *(TPoint P1, double F)
    {
        return new TPoint(P1.X * F, P1.Y * F);
    }
    public static TPoint operator /(TPoint P1, double F)
    {
        return new TPoint(P1.X / F, P1.Y / F);
    }
}
/// <summary>
/// Class <c>TPolygon</c> represents a polygon in 2D Euclidean space, but with floating point arithmetic.
/// It also sorts the points in clockwise or counterclockwise order, with the following rule:
/// if the polygon represents a valid polygon: counterclockwise order is used;
/// if the polygon represents a hole: clockwise order is used.
/// </summary>
public class TPolygon : Object, ICloneable
{
    /// <summary>
    /// Variable <c>Points</c> contains the Points of the polygon.
    /// </summary>
    public List<TPoint> Points;
    /// <summary>
    /// Variable <c>FHole</c> is used internally, to represent a flag, that indicates this as a hole inside another polygon.
    /// </summary>
    private bool FHole;
    /// <summary>
    /// Constructor <c>TPolygon</c> constructs a polygon.
    /// </summary>
    public TPolygon() : base()
    {
        Points = new List<TPoint>();
        FHole = false;
    }
    /// <summary>
    /// Constructor <c>TPolygon</c> constructs a triangle with the given points.
    /// The points are sorted in counterclockwise order during construction.
    /// </summary>
    /// <param name="P1"><c>P1</c> is the first point of the triangle.</param>
    /// <param name="P2"><c>P1</c> is the second point of the triangle.</param>
    /// <param name="P3"><c>P1</c> is the third point of the triangle.</param>
    public TPolygon(TPoint P1, TPoint P2, TPoint P3)
    {
        Points = new List<TPoint>(3)
        {
            P1,
            P2,
            P3
        };
        FHole = false;
    }
    /// <summary>
    /// Function <c>Clone</c> implements the ICloneable interface.
    /// </summary>
    /// <returns>A cloned <c>TPolygon</c>.</returns>
    public object Clone()
    {
        TPolygon Result = new TPolygon();
        foreach (TPoint Point in Points)
            Result.Points.Add((TPoint)Point.Clone());
        Result.Hole = FHole;
        return Result;
    }
    /// <summary>
    /// Function <c>GetOrientation</c> calculates the points orientation of the polygon.
    /// </summary>
    /// <returns>A <c>TOrientation</c> value of the orientation.</returns>
    internal TOrientation GetOrientation()
    {
        int I1, I2;
        double Area = 0;
        for (I1 = 0; I1 < Points.Count; I1++)
        {
            I2 = I1 + 1;
            if (I2 == Points.Count)
                I2 = 0;
            Area += Points[I1].X * Points[I2].Y - Points[I1].Y * Points[I2].X;
        }
        if (Area > 0)
            return TOrientation.CounterClockwise;
        if (Area < 0)
            return TOrientation.Clockwise;
        return TOrientation.Collinear;
    }
    /// <summary>
    /// Function <c>SetOrientation</c> sets the orientation of the points of the polygon.
    /// </summary>
    /// <param name="Orientation"><c>Orientation</c> is the orientation to be applied.</param>
    internal void SetOrientation(TOrientation Orientation)
    {
        TOrientation ActuralOrientation = GetOrientation();
        if ((ActuralOrientation != TOrientation.Collinear) && (ActuralOrientation != Orientation))
            Points.Reverse();
    }
    /// <summary>
    /// Function <c>SetHole</c> sets a flag, that specifies this is a hole inside another polygon.
    /// </summary>
    /// <param name="AHole"><c>AHole</c> is a boolean value, that specifies this is a hole inside another polygon.</param>
    /// <remarks>The vertex must be sorted in clockwise order in holes and in counterclockwise order in non-holes.</remarks>
    internal void SetHole(bool AHole)
    {
        FHole = AHole;
        if (FHole)
            SetOrientation(TOrientation.Clockwise);
        else
            SetOrientation(TOrientation.CounterClockwise);
    }
    /// <summary>
    /// Property <c>Hole</c> gets or sets the orientation of points of the polygon, according to the needings.
    /// </summary>
    internal bool Hole
    {
        get => FHole;
        set => SetHole(value);
    }
}
/// <summary>
/// Class <c>TPolygonGroup</c> represents a polygon in the map, obtained from a SECTOR, with SIDEDEF, LINEDEF and VERTEX data.
/// The SectorGroup is defined by the outer edges of the polygon and optionally the holes.
/// </summary>
internal class TPolygonGroup : Object
{
    /// <summary>
    /// Variable <c>Polygon</c> represents the outer lines of the SectorGroup.
    /// </summary>
    internal TPolygon Polygon;
    /// <summary>
    /// Variable <c>Holes</c> represents the inner "holes", that are polygons themselves.
    /// </summary>
    internal List<TPolygon> Holes;
    /// <summary>
    /// Constructor <c>TPolygonGroup</c> constructs and empty SectorGroup.
    /// </summary>
    internal TPolygonGroup(TPolygon Polygon)
    {
        this.Polygon = Polygon;
        Holes = new List<TPolygon>();
    }
}
/// <summary>
/// Class <c>TPartitionVertex</c> is used in the triangulation process.
/// </summary>
internal class TPartitionVertex : Object
{
    internal TPoint Point;
    internal bool IsActive;
    internal bool IsConvex;
    internal bool IsEar;
    internal double Angle;
    internal TPartitionVertex Previous;
    internal TPartitionVertex Next;
    internal TPartitionVertex(TPoint APoint) : base()
    {
        Point = APoint;
        Previous = this;
        Next = this;
    }
}
/// <summary>
/// Class <c>TPartition</c> is a static class, that handles three very important tasks.
/// 1. Hole management.
/// 2. Triangulation by ear clipping.
/// 3. Convex partitioning with the Hertel-Mehlhorn algorithm.
/// </summary>
internal static class TPartition : Object
{
    internal static bool IsConvex(TPoint P1, TPoint P2, TPoint P3)
    {
        double Val;
        Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
        if (Val > 0)
            return true;
        else
            return false;
    }
    internal static bool IsReflex(TPoint P1, TPoint P2, TPoint P3)
    {
        double Val;
        Val = (P3.Y - P1.Y) * (P2.X - P1.X) - (P3.X - P1.X) * (P2.Y - P1.Y);
        if (Val < 0)
            return true;
        else
            return false;
    }
    internal static bool IsInside(TPoint P1, TPoint P2, TPoint P3, TPoint Point)
    {
        if (IsConvex(P1, Point, P2))
            return false;
        if (IsConvex(P2, Point, P3))
            return false;
        if (IsConvex(P3, Point, P1))
            return false;
        return true;
    }
    internal static bool InCone(TPoint P1, TPoint P2, TPoint P3, TPoint Point)
    {
        bool Convex = IsConvex(P1, P2, P3);
        if (Convex)
        {
            if (!IsConvex(P1, P2, Point))
                return false;
            if (!IsConvex(P2, P3, Point))
                return false;
            return true;
        }
        else
        {
            if (IsConvex(P1, P2, Point))
                return true;
            if (IsConvex(P2, P3, Point))
                return true;
            return false;
        }
    }
    internal static bool Intersects(TPoint P11, TPoint P12, TPoint P21, TPoint P22)
    {
        if ((P11.X == P21.X) && (P11.Y == P21.Y))
            return false;
        if ((P11.X == P22.X) && (P11.Y == P22.Y))
            return false;
        if ((P12.X == P21.X) && (P12.Y == P21.Y))
            return false;
        if ((P12.X == P22.X) && (P12.Y == P22.Y))
            return false;
        double V1OrtX = P12.Y - P11.Y;
        double V1OrtY = P11.X - P12.X;
        double V2OrtX = P22.Y - P21.Y;
        double V2OrtY = P21.X - P22.X;
        double Dot21 = (P21.X - P11.X) * V1OrtX + (P21.Y - P11.Y) * V1OrtY;
        double Dot22 = (P22.X - P11.X) * V1OrtX + (P22.Y - P11.Y) * V1OrtY;
        double Dot11 = (P11.X - P21.X) * V2OrtX + (P11.Y - P21.Y) * V2OrtY;
        double Dot12 = (P12.X - P21.X) * V2OrtX + (P12.Y - P21.Y) * V2OrtY;
        if (Dot11 * Dot12 > 0)
            return false;
        if (Dot21 * Dot22 > 0)
            return false;
        return true;
    }
    internal static TPoint Normalize(TPoint Point)
    {
        TPoint Result;
        double Val = Math.Sqrt(Point.X * Point.X + Point.Y * Point.Y);
        if (Val != 0)
            Result = Point / Val;
        else
            Result = new TPoint
            {
                X = 0,
                Y = 0
            };
        return Result;
    }
    internal static void UpdateVertex(TPartitionVertex Vertex, TPartitionVertex[] Vertices, int NumVertices)
    {
        TPartitionVertex V1 = Vertex.Previous;
        TPartitionVertex V3 = Vertex.Next;
        TPoint Vec1, Vec3;
        Vertex.IsConvex = IsConvex(V1.Point, Vertex.Point, V3.Point);
        Vec1 = Normalize(V1.Point - Vertex.Point);
        Vec3 = Normalize(V3.Point - Vertex.Point);
        Vertex.Angle = Vec1.X * Vec3.X + Vec1.Y * Vec3.Y;
        if (Vertex.IsConvex)
        {
            Vertex.IsEar = true;
            for (int I = 0; I < NumVertices; I++)
            {
                if ((Vertices[I].Point.X == Vertex.Point.X) && (Vertices[I].Point.Y == Vertex.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V1.Point.X) && (Vertices[I].Point.Y == V1.Point.Y))
                    continue;
                if ((Vertices[I].Point.X == V3.Point.X) && (Vertices[I].Point.Y == V3.Point.Y))
                    continue;
                if (IsInside(V1.Point, Vertex.Point, V3.Point, Vertices[I].Point))
                {
                    Vertex.IsEar = false;
                    break;
                }
            }
        }
        else
            Vertex.IsEar = false;
    }
    /// <summary>
    /// Function <c>RemoveHoles</c> is a simple heuristic procedure for removing holes from a list of polygons.
    /// It works by creating a diagonal from the right-most hole  to some other visible vertex.
    /// </summary>
    /// <param name="PolygonGroup"><c>PolygonGroup</c> is a closed part of a SECTOR.<br/>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list, with a single polygon, representing the result.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool RemoveHoles(TPolygonGroup PolygonGroup, List<TPolygon> OutputPolygons)
    {
        // Check for the trivial case of no holes.
        if (PolygonGroup.Holes.Count == 0)
        {
            OutputPolygons.Add(PolygonGroup.Polygon);
            return true;
        }
        while (PolygonGroup.Holes.Count > 0)
        {
            // Find the hole point with the largest X.
            TPolygon SelectedHole = PolygonGroup.Holes[0];
            int HolePointIndex = 0;
            int PolyPointIndex = 0;
            foreach (TPolygon Hole in PolygonGroup.Holes)
            {
                for (int I = 0; I < Hole.Points.Count; I++)
                    if (Hole.Points[I].X > SelectedHole.Points[HolePointIndex].X)
                    {
                        SelectedHole = Hole;
                        HolePointIndex = I;
                    }
            }
            TPoint HolePoint = SelectedHole.Points[HolePointIndex];
            bool PointFound = false;
            TPoint BestPolyPoint = PolygonGroup.Polygon.Points[0];
            for (int I = 0; I < PolygonGroup.Polygon.Points.Count; I++)
            {
                if (PolygonGroup.Polygon.Points[I].X <= HolePoint.X)
                    continue;
                if (!InCone(
                    PolygonGroup.Polygon.Points[(I + PolygonGroup.Polygon.Points.Count - 1) % (PolygonGroup.Polygon.Points.Count)],
                    PolygonGroup.Polygon.Points[I],
                    PolygonGroup.Polygon.Points[(I + 1) % (PolygonGroup.Polygon.Points.Count)], 
                    HolePoint))
                    continue;
                TPoint PolyPoint = PolygonGroup.Polygon.Points[I];
                if (PointFound)
                {
                    TPoint V1 = Normalize(PolyPoint - HolePoint);
                    TPoint V2 = Normalize(BestPolyPoint - HolePoint);
                    if (V2.X > V1.X)
                        continue;
                }
                bool PointVisible = true;
                for (int J = 0; J < PolygonGroup.Polygon.Points.Count; J++)
                {
                    TPoint LineP1 = PolygonGroup.Polygon.Points[J];
                    TPoint LineP2 = PolygonGroup.Polygon.Points[(J + 1) % (PolygonGroup.Polygon.Points.Count)];
                    if (Intersects(HolePoint, PolyPoint, LineP1, LineP2))
                    {
                        PointVisible = false;
                        break;
                    }
                }
                if (PointVisible)
                {
                    PointFound = true;
                    BestPolyPoint = PolyPoint;
                    PolyPointIndex = I;
                }
            }
            if (!PointFound)
                return false;
            for (int I = 0; I <= SelectedHole.Points.Count; I++)
                PolygonGroup.Polygon.Points.Insert(PolyPointIndex + I + 1, SelectedHole.Points[(I + HolePointIndex) % SelectedHole.Points.Count]);
            PolygonGroup.Polygon.Points.Insert(PolyPointIndex + SelectedHole.Points.Count + 2, PolygonGroup.Polygon.Points[PolyPointIndex]);
            PolygonGroup.Holes.Remove(SelectedHole);
        }
        OutputPolygons.Add(PolygonGroup.Polygon);
        return true;
    }
    /// <summary>
    /// Function <c>Triangulate_EC</c> triangulates a polygon by ear clipping.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be triangulated.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of triangles.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool Triangulate_EC(TPolygon InputPolygon, List<TPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        if (InputPolygon.Points.Count == 3)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        int NumVertices = InputPolygon.Points.Count;
        TPartitionVertex[] Vertices = new TPartitionVertex[NumVertices];
        TPartitionVertex Ear = Vertices[0];
        for (int I = 0; I < NumVertices; I++)
            Vertices[I] = new TPartitionVertex(InputPolygon.Points[I]);
        for (int I = 0; I < NumVertices; I++)
        {
            Vertices[I].IsActive = true;
            if (I == (NumVertices - 1))
                Vertices[I].Next = Vertices[0];
            else
                Vertices[I].Next = Vertices[I + 1];
            if (I == 0)
                Vertices[I].Previous = Vertices[NumVertices - 1];
            else
                Vertices[I].Previous = Vertices[I - 1];
        }
        for (int I = 0; I < NumVertices; I++)
            UpdateVertex(Vertices[I], Vertices, NumVertices);
        for (int I = 0; I < NumVertices - 3; I++)
        {
            bool EarFound = false;
            // Search the most extruded ear.
            for (int J = 0; J < NumVertices; J++)
            {
                if (!Vertices[J].IsActive)
                    continue;
                if (!Vertices[J].IsEar)
                    continue;
                if (!EarFound)
                {
                    EarFound = true;
                    Ear = Vertices[J];
                }
                else
                {
                    if (Vertices[J].Angle > Ear.Angle)
                        Ear = Vertices[J];
                }
            }
            if (!EarFound)
                return false;
            TPolygon Triangle = new TPolygon(Ear.Previous.Point, Ear.Point, Ear.Next.Point);
            OutputPolygons.Add(Triangle);
            Ear.IsActive = false;
            Ear.Previous.Next = Ear.Next;
            Ear.Next.Previous = Ear.Previous;
            if (I == NumVertices - 4)
                break;
            UpdateVertex(Ear.Previous, Vertices, NumVertices);
            UpdateVertex(Ear.Next, Vertices, NumVertices);
        }
        for (int I = 0; I < NumVertices; I++)
            if (Vertices[I].IsActive)
            {
                TPolygon Triangle = new TPolygon(Vertices[I].Previous.Point, Vertices[I].Point, Vertices[I].Next.Point);
                OutputPolygons.Add(Triangle);
                break;
            }
        return true;
    }
    /// <summary>
    /// Function <c>ConvexPartition_HM</c> partitions a polygon into convex polygons by using the
    /// Hertel-Mehlhorn algorithm. The algorithm gives at most four times the number of parts as the optimal algorithm, 
    /// however, in practice it works much better than that and often gives optimal partition.
    /// It uses triangulation obtained by ear clipping as intermediate result.
    /// </summary>
    /// <param name="InputPolygon"><c>InputPolygon</c> is an input polygon to be partitioned.<br />
    /// Vertices have to be in counter-clockwise order.</param>
    /// <param name="OutputPolygons"><c>OutputPolygons</c> is a list of convex polygons.</param>
    /// <returns>True if the process is successful.</returns>
    internal static bool ConvexPartition_HM(TPolygon InputPolygon, List<TPolygon> OutputPolygons)
    {
        if (InputPolygon.Points.Count < 3)
            return false;
        List<TPolygon> Triangles = new List<TPolygon>();
        int I11, I12, I21 = 0, I22 = 0, I13, I23;
        // Check if the poly is already convex.
        int NumReflex = 0;
        for (I11 = 0; I11 < InputPolygon.Points.Count; I11++)
        {
            if (I11 == 0)
                I12 = InputPolygon.Points.Count - 1;
            else
                I12 = I11 - 1;
            if (I11 == (InputPolygon.Points.Count - 1))
                I13 = 0;
            else
                I13 = I11 + 1;
            if (IsReflex(InputPolygon.Points[I12], InputPolygon.Points[I11], InputPolygon.Points[I13]))
            {
                NumReflex = 1;
                break;
            }
        }
        if (NumReflex == 0)
        {
            OutputPolygons.Add(InputPolygon);
            return true;
        }
        if (!Triangulate_EC(InputPolygon, Triangles))
            return false;
        int TriangleIndex1 = 0, TriangleIndex2;
        while (TriangleIndex1 < Triangles.Count)
        {
            TPolygon Polygon1 = Triangles[TriangleIndex1];
            TPolygon? Polygon2 = null;
            for (I11 = 0; I11 < Polygon1.Points.Count; I11++)
            {
                TPoint D1 = Polygon1.Points[I11];
                I12 = (I11 + 1) % (Polygon1.Points.Count);
                TPoint D2 = Polygon1.Points[I12];
                bool IsDiagonal = false;
                TriangleIndex2 = TriangleIndex1;
                while (TriangleIndex2 < Triangles.Count)
                {
                    if (TriangleIndex1 != TriangleIndex2)
                    {
                        Polygon2 = Triangles[TriangleIndex2];
                        for (I21 = 0; I21 < Polygon2.Points.Count; I21++)
                        {
                            if ((D2.X != Polygon2.Points[I21].X) || (D2.Y != Polygon2.Points[I21].Y))
                                continue;
                            I22 = (I21 + 1) % (Polygon2.Points.Count);
                            if ((D1.X != Polygon2.Points[I22].X) || (D1.Y != Polygon2.Points[I22].Y))
                                continue;
                            IsDiagonal = true;
                            break;
                        }
                        if (IsDiagonal)
                            break;
                    }
                    TriangleIndex2++;
                }
                if (!IsDiagonal)
                    continue;
                TPoint P2 = Polygon1.Points[I11];
                if (I11 == 0)
                    I13 = Polygon1.Points.Count - 1;
                else
                    I13 = I11 - 1;
                TPoint P1 = Polygon1.Points[I13];
                if (I22 == (Polygon2!.Points.Count - 1))
                    I23 = 0;
                else
                    I23 = I22 + 1;
                TPoint P3 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                P2 = Polygon1.Points[I12];
                if (I12 == (Polygon1.Points.Count - 1))
                    I13 = 0;
                else
                    I13 = I12 + 1;
                P3 = Polygon1.Points[I13];
                if (I21 == 0)
                    I23 = Polygon2.Points.Count - 1;
                else
                    I23 = I21 - 1;
                P1 = Polygon2.Points[I23];
                if (!IsConvex(P1, P2, P3))
                    continue;
                TPolygon NewPolygon = new TPolygon();
                for (int J = I12; J != I11; J = (J + 1) % (Polygon1.Points.Count))
                    NewPolygon.Points.Add(Polygon1.Points[J]);
                for (int J = I22; J != I21; J = (J + 1) % (Polygon2.Points.Count))
                    NewPolygon.Points.Add(Polygon2.Points[J]);
                Triangles.RemoveAt(TriangleIndex2);
                Triangles[TriangleIndex1] = NewPolygon;
                Polygon1 = NewPolygon;
                I11 = -1;
                continue;
            }
            TriangleIndex1++;
        }
        foreach (TPolygon Polygon in Triangles)
            OutputPolygons.Add(Polygon);
        return true;
    }
}
/// <summary>
/// Class <c>TMapSector3D</c> stores the 3D sectors, that will be included of the mesh.
/// </summary>
internal class TMapSector3D : Object
{
    internal int SectorTag;
    internal bool Swimmable;
    internal TMapLinedef ControlLinedef;
    internal TMapSector ControlSector;
    internal TMapSector3D(TMapLinedef ControlLinedef, TMapSector ControlSector) : base()
    {
        this.ControlLinedef = ControlLinedef;
        this.ControlSector = ControlSector;
        SectorTag = ControlLinedef.Arg0;
        Swimmable = (ControlLinedef.Arg1 & 0x0003) == 0x0001 ? false : true;
    }
}
internal class TGridList : Object 
{
    internal class TGridPage : Object 
    {
        internal int[] Values;
        internal int[] Chains;
        internal TGridPage() : base()
        {
            Values = new int[1024];
            Chains = new int[1024];
        }
    }
    internal TGridPage[] GridPages;
    internal int[] GridChains;
    internal int GridCount;
    internal TGridList() : base()
    {
        GridPages = new TGridPage[1024];
        GridChains = new int[65536];
        Clear();
    }
    internal void Clear()
    {
        GridCount = 0;
        for (int I = 0; I < 65536; I++)
            GridChains[I] = -1;
    }
    internal void Add(int GridX, int GridY, int Value)
    {
        // Add the entry in the grid chains.
        int PageNumber = GridCount >> 10;
        int PageIndex = GridCount & 1023;
        if (PageIndex == 0)
            GridPages[PageNumber] = new TGridPage();
        GridPages[PageNumber].Values[PageIndex] = Value;
        GridPages[PageNumber].Chains[PageIndex] = -1;
        // Link the value to the previous last chain.
        int ChainNumber = (GridY << 8) + GridX;
        int LastChain = GridChains[ChainNumber];
        if (GridChains[ChainNumber] >= 0)
        {
            do
            {
                PageNumber = LastChain >> 10;
                PageIndex = LastChain & 1023;
                LastChain = GridPages[PageNumber].Chains[PageIndex];
            } while (LastChain >= 0);
            GridPages[PageNumber].Chains[PageIndex] = GridCount;
        }
        else
            GridChains[ChainNumber] = GridCount;
        GridCount++;
    }
    internal void FillOneCell(int GridX, int GridY, SortedList<int, int> Result)
    {
        int ChainNumber = (GridY << 8) + GridX;
        int LastChain = GridChains[ChainNumber];
        while (LastChain >= 0)
        {
            int PageNumber = LastChain >> 10;
            int PageIndex = LastChain & 1023;
            int Value = GridPages[PageNumber].Values[PageIndex];
            if (!Result.ContainsKey(Value))
                Result.Add(Value, Value);
            LastChain = GridPages[PageNumber].Chains[PageIndex];
        }
    }
    internal void Fill(int MinX, int MaxX, int MinY, int MaxY, SortedList<int, int> Result)
    {
        for (int Y = MinY; Y <= MaxY; Y++)
            for (int X = MinX; X <= MaxX; X++)
                FillOneCell(X, Y, Result);
    }
}
/// <summary>
/// Class <c>TNavMesh</c> represents the navigation mesh of the processing map.
/// </summary>
public class TNavMesh : Object
{
    /// <summary>
    /// Constant <c>GridOffset</c> is the offset added to VERTEX coordinates in the map grid.
    /// </summary>
    internal const int GridOffset = 32768;
    /// <summary>
    /// Variable <c>MapDefinition</c> references the current map, that's being processed.
    /// </summary>
    internal TMapDefinition MapDefinition;
    /// <summary>
    /// Variable <c>ActorHeight</c> specifies the height of the Actor, that uses the NavMesh.
    /// </summary>
    internal int ActorHeight;
    /// <summary>
    /// Variable <c>ActorRadius</c> specifies the radius of the Actor, that uses the NavMesh.
    /// </summary>
    internal int ActorRadius;
    /// <summary>
    /// Variable <c>MapSectors3D</c> stores the list of 3D sectors.
    /// </summary>
    internal List<TMapSector3D> MapSectors3D;
    /// <summary>
    /// Variable <c>SectorLines</c> caches the LINEDEFs associated to each SECTOR.
    /// </summary>
    internal SortedList<Int32, List<Int32>> SectorLines;
    /// <summary>
    /// Variable <c>GridLinedef</c> caches the LINEDEFs into 256 x 256 blocks.
    /// </summary>
    internal TGridList GridLinedef;
    /// <summary>
    /// Variable <c>GridNavMeshLine</c> caches the built navigation mesh lines into 256 x 256 blocks.
    /// </summary>
    internal TGridList GridNavMeshLine;
    /// <summary>
    /// Variable <c>Lines</c> stores the lines of the navigation mesh.
    /// </summary>
    public List<TNavMeshLine> NavMeshLines { get; private set; }
    /// <summary>
    /// Variable <c>FPolygons</c> stores the polygons of the navigation mesh.
    /// </summary>
    public List<TNavMeshPolygon> NavMeshPolygons { get; private set; }
    /// <summary>
    /// Variable <c>FCells</c> stores the cells partitioning system of the navigation mesh.
    /// </summary>
    public List<Int32>[,] Cells { get; private set; }
    /// <summary>
    /// Variable <c>FOffsetCellX</c> stores the first cell's X coordinate.
    /// </summary>
    public int OffsetCellX { get; private set; }
    /// <summary>
    /// Variable <c>FOffsetCellY</c> stores the first cell's Y coordinate.
    /// </summary>
    public int OffsetCellY { get; private set; }
    /// <summary>
    /// Variable <c>FNumCellX</c> stores the number of cells in the X axis.
    /// </summary>
    public int NumCellX { get; private set; }
    /// <summary>
    /// Variable <c>FNumCellY</c> stores the number of cells in the Y axis.
    /// </summary>
    public int NumCellY { get; private set; }
    /// <summary>
    /// property <c>Messages</c> stores the messages of the processing.
    /// </summary>
    public List<String> Messages { get; private set; }
    /// <summary>
    /// Constructor <c>TNavMesh</c> constructs the navigation mesh.
    /// </summary>
    public TNavMesh(TMapDefinition MapDefinition) : base()
    {
        this.MapDefinition = MapDefinition;
        MapSectors3D = new List<TMapSector3D>();
        GridLinedef = new TGridList();
        GridNavMeshLine = new TGridList();
        SectorLines = new SortedList<Int32, List<Int32>>();
        NavMeshLines = new List<TNavMeshLine>();
        NavMeshPolygons = new List<TNavMeshPolygon>();
        Messages = new List<String>();
        Cells = new List<Int32>[1, 1];
    }
    internal static bool LineIntersecTNavMeshLine(TNavMeshLine Line1, TNavMeshLine Line2)
    {
        TOrientation CalcDirection(TNavMeshPoint A, TNavMeshPoint B, TNavMeshPoint C)
        {
            int CrossProduct = (B.Y - A.Y) * (C.X - B.X) - (B.X - A.X) * (C.Y - B.Y);
            if (CrossProduct == 0)
                return TOrientation.Collinear;
            else
                if (CrossProduct < 0)
                return TOrientation.CounterClockwise;
            else
                return TOrientation.Clockwise;
        }
        bool PointOnLine(TNavMeshLine Line, TNavMeshPoint Point)
        {
            if ((Point.X <= Math.Max(Line.A.X, Line.B.X)) && (Point.X >= Math.Min(Line.A.X, Line.B.X)) && (Point.Y <= Math.Max(Line.A.Y, Line.B.Y)) && (Point.Y >= Math.Min(Line.A.Y, Line.B.Y)))
                return true;
            else
                return false;
        }
        TOrientation Direction1 = CalcDirection(Line1.A, Line1.B, Line2.A);
        TOrientation Direction2 = CalcDirection(Line1.A, Line1.B, Line2.B);
        TOrientation Direction3 = CalcDirection(Line2.A, Line2.B, Line1.A);
        TOrientation Direction4 = CalcDirection(Line2.A, Line2.B, Line1.B);
        if ((Direction1 != Direction2) && (Direction3 != Direction4))
            return true;
        if ((Direction1 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.A)))
            return true;
        if ((Direction2 == TOrientation.Collinear) && (PointOnLine(Line1, Line2.B)))
            return true;
        if ((Direction3 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.A)))
            return true;
        if ((Direction4 == TOrientation.Collinear) && (PointOnLine(Line2, Line1.B)))
            return true;
        return false;
    }
    /// <summary>
    /// Function <c>PointInsidePolygon</c> checks if a point is contained in another polygon.
    /// </summary>
    /// <param name="Polygon"><c>Polygon</c> is the external polygon, that could contain the point.</param>
    /// <param name="Point"><c>Point</c> is the point, to be tested, if it's contained in the polygon.</param>
    /// <returns><c>True</c> if <c>Point</c> is contained in <c>Polygon</c>, <c>False</c> otherwise.</returns>
    internal static bool PointInsidePolygon(TPolygon Polygon, TPoint Point)
    {
        if (Polygon.Points.Count < 3)
            return false;
        bool Result = false;
        TPoint P1 = Polygon.Points[0];
        for (int I = 0; I < Polygon.Points.Count; I++)
        {
            TPoint P2 = Polygon.Points[(I + 1) % Polygon.Points.Count];
            if (Point.Y > Math.Min(P1.Y, P2.Y))
                if (Point.Y <= Math.Max(P1.Y, P2.Y))
                    if (Point.X <= Math.Max(P1.X, P2.X))
                    {
                        double IntersectionX = (Point.Y - P1.Y) * (P2.X - P1.X) / (P2.Y - P1.Y) + P1.X;
                        if ((P1.X == P2.X) || (Point.X <= IntersectionX))
                            Result = !Result;
                    }
            P1 = P2;
        }
        return Result;
    }
    /// <summary>
    /// Function <c>PolygonInsidePolygon</c> checks if a polygon is contained in another polygon.
    /// </summary>
    /// <param name="OuterPolygon"><c>OuterPolygon</c> is the external polygon, that could contain the other.</param>
    /// <param name="TestPoligon"><c>TestPolygon</c> is the polygon, to be tested, if it's contained in the other.</param>
    /// <returns><c>True</c> if <c>TestPolygon</c> is contained in <c>OuterPolygon</c>, <c>False</c> otherwise.</returns>
    /// <remarks>This function tests the first two points of the inner polygon.</remarks>
    internal static bool PolygonInsidePolygon(TPolygon OuterPolygon, TPolygon TestPoligon)
    {
        if ((OuterPolygon.Points.Count < 3) || (TestPoligon.Points.Count < 3))
            return false;
        else
            return (PointInsidePolygon(OuterPolygon, TestPoligon.Points[0])) && (PointInsidePolygon(OuterPolygon, TestPoligon.Points[1]));
    }
    /// <summary>
    /// Function <c>CheckLinedef3D</c> checks if a linedef has 3D special.
    /// </summary>
    /// <param name="MapLinedef"><c>MapLinedef</c> is the LINEDEF to be checked for 3D sector control.</param>
    internal bool CheckLinedef3D(TMapLinedef MapLinedef)
    {
        bool Result = false;
        if (MapDefinition.MapNamespace == TMapNamespace.MapNamespaceZDoom)
            if ((MapLinedef.Special == 160) && ((((MapLinedef.Arg1 & 0x0003) == 0x0001) || ((MapLinedef.Arg1 & 0x0003) == 0x0002))))
                Result = true;
        return Result;
    }
    /// <summary>
    /// Function <c>GetGridExtent</c> gets the limiting grid coordinates of the specified line (X1, Y1) - (X2, Y2).
    /// </summary>
    internal static void GetGridExtent(int X1, int Y1, int X2, int Y2, out int MinX, out int MaxX, out int MinY, out int MaxY)
    {
        if (X1 > X2)
        {
            MaxX = X1;
            MinX = X2;
        }
        else
        {
            MaxX = X2;
            MinX = X1;
        }
        if (Y2 > Y1)
        {
            MaxY = Y2;
            MinY = Y1;
        }
        else
        {
            MaxY = Y1;
            MinY = Y2;
        }
        MinX = (MinX + GridOffset) >> 8;
        MaxX = (MaxX + GridOffset) >> 8;
        MinY = (MinY + GridOffset) >> 8;
        MaxY = (MaxY + GridOffset) >> 8;
    }
    /// <summary>
    /// Function <c>PreProcessMapData</c> caches some structures of the MapDefinition and stores 3D floors information.
    /// </summary>
    internal void PreProcessMapData()
    {
        SectorLines.Clear();
        GridLinedef.Clear();
        GridNavMeshLine.Clear();
        MapSectors3D.Clear();
        foreach (TMapSector MapSector in MapDefinition.MapSector)
        {
            // Ignore the doors that close after 30 seconds after level start.
            if (MapSector.Special == 10)
                MapSector.Ignored = true;
            if (MapSector.Ignored)
                continue;
            SectorLines.Add(MapSector.Index, new List<int>());
        }
        foreach (TMapLinedef MapLinedef in MapDefinition.MapLinedef)
        {
            if (MapLinedef.SideFront >= 0)
            {
                int SideSector = MapDefinition.MapSidedef[MapLinedef.SideFront].Sector;
                if (SectorLines.TryGetValue(SideSector, out List<int>? Value))
                    Value.Add(MapLinedef.Index);
                // Process the 3D sectors.
                if (CheckLinedef3D(MapLinedef))
                    MapSectors3D.Add(new TMapSector3D(MapLinedef, MapDefinition.MapSector[SideSector]));
            }
            if (MapLinedef.SideBack >= 0)
            {
                int SideSector = MapDefinition.MapSidedef[MapLinedef.SideBack].Sector;
                if (SectorLines.TryGetValue(SideSector, out List<int>? Value))
                    Value.Add(MapLinedef.Index);
            }
            int MinX, MaxX, MinY, MaxY;
            GetGridExtent(MapDefinition.MapVertex[MapLinedef.V1].X, MapDefinition.MapVertex[MapLinedef.V1].Y, MapDefinition.MapVertex[MapLinedef.V2].X, MapDefinition.MapVertex[MapLinedef.V2].Y, out MinX, out MaxX, out MinY, out MaxY);
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    GridLinedef.Add(X, Y, MapLinedef.Index);
        }
    }
    /// <summary>
    /// Function <c>IsClosed</c> checks if the polygon is closed.
    /// </summary>
    /// <returns><c>True</c> if the polygon is closed.</returns>
    internal static bool IsClosed(TPolygon Polygon)
    {
        if (Polygon.Points.Count < 3)
            return false;
        bool[] CheckedLine = new bool[Polygon.Points.Count];
        for (int I = 0; I < Polygon.Points.Count; I++)
            CheckedLine[I] = false;
        int FirstLine = 0;
        int CurrentLine = FirstLine;
        do
        {
            CheckedLine[CurrentLine] = true;
            bool NotFound = true;
            int Index = 0;
            while ((NotFound) && (Index < Polygon.Points.Count))
                if (Polygon.Points[Index] == Polygon.Points[(CurrentLine + 1) % Polygon.Points.Count])
                    NotFound = false;
                else
                    Index++;
            if (NotFound)
                CurrentLine = -1;
            else
                CurrentLine = Index;
            if ((CurrentLine < 0) || ((CheckedLine[CurrentLine]) && (CurrentLine != FirstLine)))
                return false;
        } while ((CurrentLine != 0));
        return true;
    }
    /// <summary>
    /// Function <c>SortLines</c> sorts the lines in a continuous path between points.
    /// </summary>
    internal static void SortLines(TPolygon Polygon)
    {
        if (Polygon.Points.Count < 3)
            return;
        int[] LinesIndexes = new int[Polygon.Points.Count];
        int CurrentIndex = 0;
        int ActualIndex = 1;
        LinesIndexes[0] = 0;
        do
        {
            TPoint CurrentLine = Polygon.Points[(CurrentIndex + 1) % Polygon.Points.Count];
            bool NotFound = true;
            CurrentIndex = 0;
            while ((NotFound) && (CurrentIndex <= Polygon.Points.Count))
                if (Polygon.Points[(CurrentIndex) % Polygon.Points.Count] == CurrentLine)
                    NotFound = false;
                else
                    CurrentIndex++;
            if (CurrentIndex < 0)
                return; // Only if not closed!
            if (CurrentIndex > 0)
            {
                LinesIndexes[ActualIndex] = CurrentIndex;
                ActualIndex++;
            }
        } while (CurrentIndex > 0);
        for (int I = 0; I < Polygon.Points.Count; I++)
        {
            if (LinesIndexes[I] != I)
            {
                TPoint AA = Polygon.Points[LinesIndexes[I]];
                TPoint AB = Polygon.Points[(LinesIndexes[I] + 1) % Polygon.Points.Count];
                TPoint BA = Polygon.Points[I];
                TPoint BB = Polygon.Points[(I + 1) % Polygon.Points.Count];
                Polygon.Points[LinesIndexes[I]] = BA;
                Polygon.Points[(LinesIndexes[I] + 1) % Polygon.Points.Count] = BB;
                Polygon.Points[I] = AA;
                Polygon.Points[(I + 1) % Polygon.Points.Count] = AB;
                int IndexA = LinesIndexes[LinesIndexes[I]];
                int IndexB = LinesIndexes[I];
                LinesIndexes[LinesIndexes[I]] = IndexB;
                LinesIndexes[I] = IndexA;
            }
        }
    }
    /// <summary>
    /// Function <c>GetPolygonGroups</c> creates the list of SectorGroup from a SECTOR.
    /// </summary>
    /// <param name="VertexBegin"><c>VertexBegin</c> containes the beginning VERTEX of the LINEDEFs of the SECTOR.</param>
    /// <param name="VertexEnd"><c>VertexBegin</c> containes the ending VERTEX of the LINEDEFs of the SECTOR.</param>
    /// <param name="PolygonGroups"><c>PolygonGroups</c> will be filled with the closed regions found.</param>
    /// <returns><c>True</c> if the process is completed successfully.</returns>
    internal bool GetPolygonGroups(List<Int32> VertexBegin, List<Int32> VertexEnd, List<TPolygonGroup> PolygonGroups)
    {
        // If the SECTOR has less than 3 LINEDEF, then it's scrapped.
        if (VertexBegin.Count < 3)
            return false;
        // Split the closed regions of the SECTOR.
        List<TPolygon> Polygons = new List<TPolygon>();
        bool[] CheckedLine = new bool[VertexBegin.Count];
        for (int I = 0; I < VertexBegin.Count; I++)
            CheckedLine[I] = false;
        bool HasMoreLines;
        do
        {
            bool NotFound = true;
            int FirstLine = 0;
            while ((NotFound) && (FirstLine < VertexBegin.Count))
                if (!CheckedLine[FirstLine]) 
                    NotFound = false; 
                else 
                    FirstLine++;
            if (!NotFound)
            {
                TPolygon Polygon = new TPolygon();
                Polygon.Points.Add(new TPoint(MapDefinition.MapVertex[VertexBegin[FirstLine]].X, MapDefinition.MapVertex[VertexBegin[FirstLine]].Y));
                CheckedLine[FirstLine] = true;
                int CurrentLine = FirstLine;
                int NextLine;
                do
                {
                    NotFound = true;
                    NextLine = 0;
                    while ((NotFound) && (NextLine < VertexBegin.Count))
                        if (VertexBegin[NextLine] == VertexEnd[CurrentLine])
                            NotFound = false;
                        else
                            NextLine++;
                    if (NotFound)
                        return false;
                    if ((!NotFound) && (CheckedLine[NextLine]))
                        break;
                    if ((!NotFound) && (NextLine != FirstLine))
                    {
                        Polygon.Points.Add(new TPoint(MapDefinition.MapVertex[VertexBegin[NextLine]].X, MapDefinition.MapVertex[VertexBegin[NextLine]].Y));
                        CheckedLine[NextLine] = true;
                        CurrentLine = NextLine;
                    }
                } while ((NextLine >= 0) && (NextLine != FirstLine));
                if (IsClosed(Polygon))
                {
                    SortLines(Polygon);
                    Polygon.Hole = false;
                    Polygons.Add(Polygon);
                }
            }
            HasMoreLines = false;
            for (int I = 0; I < VertexBegin.Count; I++)
                if (!CheckedLine[I])
                    HasMoreLines = true;
        } while (HasMoreLines);
        if (Polygons.Count == 0)
            return false;
        if (Polygons.Count == 1)
        {
            // Only one closed region.
            TPolygonGroup PolygonGroup = new TPolygonGroup(Polygons[0]);
            PolygonGroups.Add(PolygonGroup);
        }
        else
        {
            // Multiple closed regions: check the holes and nested regions.
            int[] PolygonDepthLevel = new int[Polygons.Count];
            int MaxDepthLevel = 0;
            for (int I = 0; I < Polygons.Count; I++)
                PolygonDepthLevel[I] = 0;
            for (int I = 0; I < Polygons.Count; I++)
                for (int J = 0; J < Polygons.Count; J++)
                    if (I != J)
                        if (PolygonInsidePolygon(Polygons[I], Polygons[J]))
                        {
                            PolygonDepthLevel[J]++;
                            if (PolygonDepthLevel[J] > MaxDepthLevel)
                                MaxDepthLevel = PolygonDepthLevel[J];
                        }
            for (int DepthLevel = 0; DepthLevel <= MaxDepthLevel; DepthLevel += 2)
                for (int I = 0; I < Polygons.Count; I++)
                    if (PolygonDepthLevel[I] == DepthLevel)
                    {
                        TPolygonGroup PolygonGroup = new TPolygonGroup(Polygons[I]);
                        for (int J = 0; J < Polygons.Count; J++)
                            if ((I != J) && (PolygonInsidePolygon(Polygons[I], Polygons[J])))
                            {
                                Polygons[J].Hole = true;
                                PolygonGroup.Holes.Add(Polygons[J]);
                            }
                        PolygonGroups.Add(PolygonGroup);
                    }
        }
        return true;
    }
    /// <summary>
    /// Function <c>ProcessPolygonMesh</c> adds a mesh to the navigation mesh.
    /// </summary>
    /// <param name="Polygon"><c>Polygon</c> is the mesh to be added.</param>
    internal void ProcessPolygonMesh(TNavMeshPolygon Polygon)
    {
        // Check if there is enough vertical space.
        if ((Polygon.HeightCeiling - Polygon.HeightFloor) < ActorHeight)
            return;
        // Check for portals.
        SortedList<int, int> Lines = new SortedList<int, int>();
        foreach (TNavMeshLine Line in Polygon.Lines)
        {
            // Search for the map LINEDEF, using the cached grid.
            Lines.Clear();
            GetGridExtent(Line.A.X, Line.A.Y, Line.B.X, Line.B.Y, out int MinX, out int MaxX, out int MinY, out int MaxY);
            GridLinedef.Fill(MinX, MaxX, MinY, MaxY, Lines);
            bool NotFound = true;
            int MapLinedefIndex = 0;
            while ((NotFound) && (MapLinedefIndex < Lines.Count))
            {
                TMapVertex V1 = MapDefinition.MapVertex[MapDefinition.MapLinedef[Lines.Keys[MapLinedefIndex]].V1];
                TMapVertex V2 = MapDefinition.MapVertex[MapDefinition.MapLinedef[Lines.Keys[MapLinedefIndex]].V2];
                if (((Line.A.X == V1.X) && (Line.A.Y == V1.Y) && (Line.B.X == V2.X) && (Line.B.Y == V2.Y))
                    || ((Line.A.X == V2.X) && (Line.A.Y == V2.Y) && (Line.B.X == V1.X) && (Line.B.Y == V1.Y)))
                    NotFound = false;
                else
                    MapLinedefIndex++;
            }
            if (NotFound)
                MapLinedefIndex = -1;
            else
                MapLinedefIndex = Lines.Keys[MapLinedefIndex];
            Line.MapLinedef = MapLinedefIndex;
            // Check for portals.
            Lines.Clear();
            GridNavMeshLine.Fill(MinX, MaxX, MinY, MaxY, Lines);
            for (int Index = 0; Index < Lines.Count; Index++)
            {
                int I = Lines.Keys[Index];
                int CurrentPolygonIndex = 0;
                int CurrentPolygonStartLine = 0;
                bool PolygonNotFound = true;
                do
                {
                    int NextPolygonStart = CurrentPolygonStartLine + NavMeshPolygons[CurrentPolygonIndex].LineCount;
                    if (NextPolygonStart > I)
                        PolygonNotFound = false;
                    else
                    {
                        CurrentPolygonStartLine = NextPolygonStart;
                        CurrentPolygonIndex++;
                    }
                } while ((PolygonNotFound) && (CurrentPolygonIndex < NavMeshPolygons.Count));
                if (((Line.A == NavMeshLines[I].A) && (Line.B == NavMeshLines[I].B)) || ((Line.A == NavMeshLines[I].B) && (Line.B == NavMeshLines[I].A)))
                {
                    bool LineIsPortal = true;
                    // If the line is generated from the splitting of the SECTOR, then check for 3D floors, else check further.
                    if (MapLinedefIndex >= 0)
                    {
                        // Check if the LINEDEF blocks monsters.
                        TMapLinedef MapLinedef = MapDefinition.MapLinedef[MapLinedefIndex];
                        if ((MapLinedef.Blocking) || (MapLinedef.SideFront < 0) || (MapLinedef.SideBack < 0) || (MapLinedef.Ignored))
                            LineIsPortal = false;
                        // Check if the two floor heights are too different.
                        int HeightFloorDifference = Math.Abs(Polygon.HeightFloor - NavMeshPolygons[CurrentPolygonIndex].HeightFloor);
                        if (HeightFloorDifference > 24)
                            LineIsPortal = false;
                        // Check if there is enough vertical space between the two connecting sectors.
                        int VerticalSpace = Math.Min(Polygon.HeightCeiling, NavMeshPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, NavMeshPolygons[CurrentPolygonIndex].HeightFloor);
                        if (VerticalSpace < ActorHeight)
                            LineIsPortal = false;
                    }
                    else
                    {
                        // Check if the two floor heights are too different.
                        int HeightFloorDifference = Math.Abs(Polygon.HeightFloor - NavMeshPolygons[CurrentPolygonIndex].HeightFloor);
                        if (HeightFloorDifference > 24)
                            LineIsPortal = false;
                        // Check if there is enough vertical space between the two connecting sectors.
                        int VerticalSpace = Math.Min(Polygon.HeightCeiling, NavMeshPolygons[CurrentPolygonIndex].HeightCeiling) - Math.Max(Polygon.HeightFloor, NavMeshPolygons[CurrentPolygonIndex].HeightFloor);
                        if (VerticalSpace < ActorHeight)
                            LineIsPortal = false;
                    }
                    if (LineIsPortal)
                    {
                        Line.Portal = CurrentPolygonIndex;
                        NavMeshLines[I].Portal = NavMeshPolygons.Count;
                    }
                }
            }
        }
        // Add the polygon.
        Polygon.LineFirst = NavMeshLines.Count;
        Polygon.LineCount = Polygon.Lines.Count;
        NavMeshPolygons.Add(Polygon);
        // Add the lines.
        foreach (TNavMeshLine Line in Polygon.Lines)
        {
            GetGridExtent(Line.A.X, Line.A.Y, Line.B.X, Line.B.Y, out int MinX, out int MaxX, out int MinY, out int MaxY);
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    GridNavMeshLine.Add(X, Y, NavMeshLines.Count);
            NavMeshLines.Add(Line);
        }
    }
    /// <summary>
    /// Function <c>ProcessPolygons</c> receives the polygons from the a group of polygons from a map SECTORS and processes them.
    /// </summary>
    /// <param name="Polygons"><c>Polygons</c> contains the list of PolygonGroup from the map SECTOR.</param>
    /// <param name="HeightCeiling"><c>HeightCeiling</c> is the height of the ceiling of the map SECTOR or 3D sector.</param>
    /// <param name="HeightFloor"><c>HeightFloor</c> is the height of the floor of the map SECTOR or 3D sector.</param>
    /// <param name="MapSector"><c>MapSector</c> is the index of the map SECTOR.</param>
    /// <param name="Flags"><c>Flags</c> contains additional information for the NavMesh.</param>
    internal void ProcessPolygons(List<TPolygon> Polygons, int HeightFloor, int HeightCeiling, int MapSector, int Flags = 0)
    {
        foreach (TPolygon Polygon in Polygons)
        {
            // Generate the mesh polygon.
            TNavMeshPolygon NavMeshPolygon = new TNavMeshPolygon();
            NavMeshPolygon.HeightFloor = HeightFloor;
            NavMeshPolygon.HeightCeiling = HeightCeiling;
            NavMeshPolygon.MapSector = MapSector;
            NavMeshPolygon.Flags = Flags;
            for (int I = 0; I < Polygon.Points.Count; I++)
            {
                int J = (I + 1) % Polygon.Points.Count;
                NavMeshPolygon.Lines.Add(
                    new TNavMeshLine(
                        new TNavMeshPoint(Convert.ToInt32(Polygon.Points[I].X), Convert.ToInt32(Polygon.Points[I].Y)),
                        new TNavMeshPoint(Convert.ToInt32(Polygon.Points[J].X), Convert.ToInt32(Polygon.Points[J].Y))
                    )
                );
            }
            // Append the mesh polygon to the navigation mesh.
            Polygon.SetOrientation(TOrientation.CounterClockwise);
            ProcessPolygonMesh(NavMeshPolygon);
        }
    }
    /// <summary>
    /// Function <c>ProcessMapData</c> processes the map lines and sectors into convex polygons.
    /// </summary>
    internal void ProcessMapData()
    {
        List<Int32> VertexBegin = new List<Int32>();
        List<Int32> VertexEnd = new List<Int32>();
        List<TPolygonGroup> PolygonGroups = new List<TPolygonGroup>();
        List<TPolygon> InputPolygons = new List<TPolygon>();
        List<TPolygon> OutputPolygons = new List<TPolygon>();
        foreach (TMapSector MapSector in MapDefinition.MapSector)
        {
            if (MapSector.Ignored)
                continue;
            VertexBegin.Clear();
            VertexEnd.Clear();
            // Get the LINEDEFs using the cache.
            if (SectorLines.TryGetValue(MapSector.Index, out List<Int32>? CachedLines))
            {
                foreach (Int32 MapLinedefIndex in CachedLines)
                {
                    if ((MapDefinition.MapLinedef[MapLinedefIndex].SideFront >= 0) && (MapDefinition.MapSidedef[MapDefinition.MapLinedef[MapLinedefIndex].SideFront].Sector == MapSector.Index))
                    {
                        VertexBegin.Add(MapDefinition.MapLinedef[MapLinedefIndex].V1);
                        VertexEnd.Add(MapDefinition.MapLinedef[MapLinedefIndex].V2);
                    }
                    else
                    {
                        VertexBegin.Add(MapDefinition.MapLinedef[MapLinedefIndex].V2);
                        VertexEnd.Add(MapDefinition.MapLinedef[MapLinedefIndex].V1);
                    }
                }
            }
            else
                continue;
            if (VertexBegin.Count < 3)
            {
                Messages.Add($"Map SECTOR # {MapSector.Index} has less than 3 LINEDEFs.");
                continue;
            }
            // Split the map sectors into a list of TPolygonGroup.
            PolygonGroups.Clear();
            if (!GetPolygonGroups(VertexBegin, VertexEnd, PolygonGroups))
            {
                Messages.Add($"Map SECTOR # {MapSector.Index} could not be split into regions.");
                continue;
            }
            foreach (TPolygonGroup PolygonGroup in PolygonGroups)
            {
                // Perform the polygon partitioning into convex subpolygons.
                InputPolygons.Clear();
                OutputPolygons.Clear();
                if (TPartition.RemoveHoles(PolygonGroup, InputPolygons))
                {
                    foreach (TPolygon Polygon1 in InputPolygons)
                        if (!TPartition.ConvexPartition_HM(Polygon1, OutputPolygons))
                            Messages.Add($"Map SECTOR # {MapSector.Index} could be processed incompletely.");
                }
                else
                    Messages.Add($"Map SECTOR # {MapSector.Index} could not be processed.");
                if (OutputPolygons.Count > 0)
                {
                    // Search for 3D sectors.
                    int Sector3D = MapSectors3D.FindIndex((MapSector3D) => MapSector3D.SectorTag == MapSector.ID);
                    if (Sector3D >= 0)
                    {
                        int MiddleFloor = MapSectors3D[Sector3D].ControlSector.HeightFloor;
                        int MiddleCeiling = MapSectors3D[Sector3D].ControlSector.HeightCeiling;
                        if (MiddleFloor > MapSector.HeightFloor)
                            ProcessPolygons(OutputPolygons, MapSector.HeightFloor, MiddleFloor, MapSector.Index, 0);
                        if (MiddleCeiling < MapSector.HeightCeiling)
                            ProcessPolygons(OutputPolygons, MiddleCeiling, MapSector.HeightCeiling, MapSector.Index, MapSectors3D[Sector3D].Swimmable ? 0x0003 : 0x0001);
                    }
                    else
                        ProcessPolygons(OutputPolygons, MapSector.HeightFloor, MapSector.HeightCeiling, MapSector.Index);
                }
            }
        }
    }
    /// <summary>
    /// Function <c>ProcessCells</c> builds the cell space partitioning system of the navigation mesh.
    /// </summary>
    internal void ProcessCells()
    {
        int MaxX = Int32.MinValue;
        int MaxY = Int32.MinValue;
        int MinX = Int32.MaxValue;
        int MinY = Int32.MaxValue;
        foreach (TNavMeshLine Line in NavMeshLines)
        {
            if (Line.A.X > MaxX)
                MaxX = Line.A.X;
            if (Line.A.Y > MaxY)
                MaxY = Line.A.Y;
            if (Line.B.X > MaxX)
                MaxX = Line.B.X;
            if (Line.B.Y > MaxY)
                MaxY = Line.B.Y;
            if (Line.A.X < MinX)
                MinX = Line.A.X;
            if (Line.A.Y < MinY)
                MinY = Line.A.Y;
            if (Line.B.X < MinX)
                MinX = Line.B.X;
            if (Line.B.Y < MinY)
                MinY = Line.B.Y;
        }
        OffsetCellX = (MinX + GridOffset) >> 8;
        OffsetCellY = (MinY + GridOffset) >> 8;
        int LastCellX = (MaxX + GridOffset) >> 8;
        int LastCellY = (MaxY + GridOffset) >> 8;
        NumCellX = LastCellX - OffsetCellX + 1;
        NumCellY = LastCellY - OffsetCellY + 1;
        Cells = new List<Int32>[NumCellY, NumCellX];
        for (int Y = 0; Y < NumCellY; Y++)
            for (int X = 0; X < NumCellX; X++)
                Cells[Y, X] = new List<Int32>();
        for (int PolygonIndex = 0; PolygonIndex < NavMeshPolygons.Count; PolygonIndex++)
        {
            MaxX = Int32.MinValue;
            MaxY = Int32.MinValue;
            MinX = Int32.MaxValue;
            MinY = Int32.MaxValue;
            foreach (TNavMeshLine Line in NavMeshPolygons[PolygonIndex].Lines)
            {
                if (Line.A.X > MaxX)
                    MaxX = Line.A.X;
                if (Line.A.Y > MaxY)
                    MaxY = Line.A.Y;
                if (Line.B.X > MaxX)
                    MaxX = Line.B.X;
                if (Line.B.Y > MaxY)
                    MaxY = Line.B.Y;
                if (Line.A.X < MinX)
                    MinX = Line.A.X;
                if (Line.A.Y < MinY)
                    MinY = Line.A.Y;
                if (Line.B.X < MinX)
                    MinX = Line.B.X;
                if (Line.B.Y < MinY)
                    MinY = Line.B.Y;
            }
            MinX = (MinX + GridOffset) >> 8;
            MinY = (MinY + GridOffset) >> 8;
            MaxX = (MaxX + GridOffset) >> 8;
            MaxY = (MaxY + GridOffset) >> 8;
            for (int Y = MinY; Y <= MaxY; Y++)
                for (int X = MinX; X <= MaxX; X++)
                    Cells[Y - OffsetCellY, X - OffsetCellX].Add(PolygonIndex);
        }
    }
    /// <summary>
    /// Function <c>Build</c> produces a NavMesh with the specified map and settings.
    /// </summary>
    /// <param name="NavMeshSettings"><c>NavMeshSettings</c> stores the settings of the process.</param>
    /// <param name="MapDefinition"><c>MapDefinition</c> stores the map being processed.</param>
    public void Build(int ActorHeight, int ActorRadius)
    {
        this.ActorHeight = ActorHeight;
        this.ActorRadius = ActorRadius;
        // Performs some filtering.
        PreProcessMapData();
        // Process the map data.
        ProcessMapData();
        // Final processing.
        ProcessCells();
    }
    /// <summary>
    /// Function <c>ToString</c> returns the NavMesh in plain text format.
    /// </summary>
    /// <returns>A string that contains the NavMesh in plain text format.</returns>
    public override string ToString()
    {
        StringBuilder SB = new StringBuilder();
        SB.AppendLine("# ZDOOMNAVMESH");
        SB.AppendLine();
        SB.AppendLine("# lines");
        for (int I = 0; I < NavMeshLines.Count; I++)
            SB.AppendFormat("l {0} {1} {2} {3} {4} {5} {6}", NavMeshLines[I].A.X, NavMeshLines[I].A.Y, NavMeshLines[I].B.X, NavMeshLines[I].B.Y, NavMeshLines[I].Portal, NavMeshLines[I].MapLinedef, NavMeshLines[I].Flags).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# polygons");
        for (int I = 0; I < NavMeshPolygons.Count; I++)
            SB.AppendFormat("p {0} {1} {2} {3} {4} {5}", NavMeshPolygons[I].HeightFloor, NavMeshPolygons[I].HeightCeiling, NavMeshPolygons[I].LineFirst, NavMeshPolygons[I].LineCount, NavMeshPolygons[I].MapSector, NavMeshPolygons[I].Flags).AppendLine();
        SB.AppendLine();
        SB.AppendLine("# cells space partitioning");
        SB.AppendFormat("o {0} {1} {2} {3}", OffsetCellX, OffsetCellY, NumCellX, NumCellY).AppendLine();
        for (int Y = 0; Y < NumCellY; Y++)
            for (int X = 0; X < NumCellX; X++)
                if (Cells![Y, X].Count > 0)
                {
                    SB.AppendFormat("c {0}", Y * NumCellX + X);
                    foreach (Int32 PolygonIndex in Cells[Y, X])
                        SB.AppendFormat(" {0}", PolygonIndex);
                    SB.AppendLine();
                }
        return SB.ToString();
    }
}
